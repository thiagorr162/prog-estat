[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso de Programação Estatística",
    "section": "",
    "text": "Curso de Programação Estatística",
    "crumbs": [
      "Curso de Programação Estatística"
    ]
  },
  {
    "objectID": "index.html#objetivo-geral",
    "href": "index.html#objetivo-geral",
    "title": "Curso de Programação Estatística",
    "section": "Objetivo Geral",
    "text": "Objetivo Geral\nEste curso visa explorar o impacto das representações numéricas nos resultados de algoritmos de análise estatística. O foco será na programação, visualização e preparação de dados, além de discutir tópicos importantes como aleatoriedade, pseudoaleatoriedade, erros de truncamento e arredondamento, entre outros. O curso inclui ainda uma introdução à inferência por simulação estocástica, utilizando métodos como Monte Carlo e integrações numéricas. O material do curso foi amplamente baseado nas discussões apresentadas em Ross (2006).\nEste livro apresenta códigos tanto em R quanto em Python\nAutores: Andressa Cerqueira, Danilo Lourenço Lopes, Rafael Izbicki, Thiago Rodrigo Ramos\n\n\n\n\nRoss, Sheldon M. 2006. Simulation, Fourth Edition. USA: Academic Press, Inc.",
    "crumbs": [
      "Curso de Programação Estatística"
    ]
  },
  {
    "objectID": "0_py.html",
    "href": "0_py.html",
    "title": "1  Breve introdução ao Python",
    "section": "",
    "text": "1.1 Variáveis e Tipos de Dados\nEm Python, variáveis são usadas para armazenar informações que podem ser manipuladas ao longo do código. Existem diferentes tipos de dados que podem ser atribuídos a uma variável. Vamos explorar os principais tipos básicos em Python: int, float, str, bool, e None.\nMostrar código\n## Exemplo de variáveis e tipos de dados\nnome = \"Thiago\"              ## String\nidade = 35                   ## Inteiro (int)\nsaldo_bancario = 1023.75      ## Float\nestudante = True              ## Booleano (bool)\nendereco = None               ## None, indicando ausência de valor\n\n## Usando o método .format() para formatar a string\nprint(\"Nome: {} (Tipo: {})\".format(nome, type(nome)))\nprint(\"Idade: {} (Tipo: {})\".format(idade, type(idade)))\nprint(\"Saldo Bancário: {} (Tipo: {})\".format(saldo_bancario, type(saldo_bancario)))\nprint(\"Estudante: {} (Tipo: {})\".format(estudante, type(estudante)))\nprint(\"Endereço: {} (Tipo: {})\".format(endereco, type(endereco)))\n\n\nNome: Thiago (Tipo: &lt;class 'str'&gt;)\nIdade: 35 (Tipo: &lt;class 'int'&gt;)\nSaldo Bancário: 1023.75 (Tipo: &lt;class 'float'&gt;)\nEstudante: True (Tipo: &lt;class 'bool'&gt;)\nEndereço: None (Tipo: &lt;class 'NoneType'&gt;)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#variáveis-e-tipos-de-dados",
    "href": "0_py.html#variáveis-e-tipos-de-dados",
    "title": "1  Breve introdução ao Python",
    "section": "",
    "text": "1.1.1 f-strings: Formatação de Strings em Python (*)\nIntroduzidas na versão Python 3.6, as f-strings (ou “formatted string literals”) são uma forma eficiente e legível de formatar strings, permitindo a inclusão de expressões e variáveis diretamente dentro de uma string.\nA sintaxe das f-strings utiliza a letra f antes da string e permite a inclusão de expressões dentro de chaves {}. Essas expressões são avaliadas em tempo de execução, e seus resultados são inseridos na string.\n\n\nMostrar código\n## Usando f-strings para formatar a string\nprint(f\"Nome: {nome} (Tipo: {type(nome)})\")\nprint(f\"Idade: {idade} (Tipo: {type(idade)})\")\nprint(f\"Saldo Bancário: {saldo_bancario} (Tipo: {type(saldo_bancario)})\")\nprint(f\"Estudante: {estudante} (Tipo: {type(estudante)})\")\nprint(f\"Endereço: {endereco} (Tipo: {type(endereco)})\")\n\n\nNome: Thiago (Tipo: &lt;class 'str'&gt;)\nIdade: 35 (Tipo: &lt;class 'int'&gt;)\nSaldo Bancário: 1023.75 (Tipo: &lt;class 'float'&gt;)\nEstudante: True (Tipo: &lt;class 'bool'&gt;)\nEndereço: None (Tipo: &lt;class 'NoneType'&gt;)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#o-comando-help-em-python",
    "href": "0_py.html#o-comando-help-em-python",
    "title": "1  Breve introdução ao Python",
    "section": "1.2 O Comando help() em Python",
    "text": "1.2 O Comando help() em Python\nPython possui uma função embutida chamada help(), que é muito útil para obter informações sobre funções, módulos, objetos, e classes. Ele fornece uma explicação detalhada de como determinado elemento funciona, quais parâmetros aceita e o que retorna, entre outros detalhes. Essa função é especialmente útil quando você está começando ou precisa de uma rápida referência sem ter que sair do ambiente de desenvolvimento.\n\n\nMostrar código\nhelp(len)\n\n\nHelp on built-in function len in module builtins:\n\nlen(obj, /)\n    Return the number of items in a container.\n\n\n\n\n\nMostrar código\ndef exemplo():\n    \"\"\"Esta é uma função de exemplo.\"\"\"\n    pass\n\nhelp(exemplo)\n\n\nHelp on function exemplo in module __main__:\n\nexemplo()\n    Esta é uma função de exemplo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#armazenando-resultados-em-variáveis",
    "href": "0_py.html#armazenando-resultados-em-variáveis",
    "title": "1  Breve introdução ao Python",
    "section": "1.3 Armazenando Resultados em Variáveis",
    "text": "1.3 Armazenando Resultados em Variáveis\nEm Python, as variáveis são usadas para armazenar resultados de cálculos ou operações para uso posterior no código. Ao armazenar um valor em uma variável, você pode acessá-lo facilmente quando precisar, sem ter que repetir o cálculo ou operação.\nQuando você atribui um valor ou resultado de uma operação a uma variável, o Python guarda esse valor na memória e o associa ao nome que você escolheu para a variável. Isso permite que você reutilize o valor sempre que necessário.\n\n\nMostrar código\nresultado = 5 + 3  ## Armazenando a soma de 5 e 3 em uma variável\nprint(resultado)    ## Resultado: 8\n\n\n8\n\n\n\n\nMostrar código\nx = 2 + 3\nprint(x)\n\n\n5\n\n\n\n\nMostrar código\ny = 2 * x\ny\n\n\n10",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#variáveis-lógicas",
    "href": "0_py.html#variáveis-lógicas",
    "title": "1  Breve introdução ao Python",
    "section": "1.4 Variáveis Lógicas",
    "text": "1.4 Variáveis Lógicas\nPython, assim como R, possui operadores lógicos para comparar valores e trabalhar com variáveis booleanas. Abaixo estão alguns dos principais operadores lógicos usados em Python:\n\n\n\n\n\n\n\n\n##\nOperador\nDescrição\n\n\n\n\n1\nx &lt; y\nx é menor que y?\n\n\n2\nx &lt;= y\nx é menor ou igual a y?\n\n\n3\nx &gt; y\nx é maior que y?\n\n\n4\nx &gt;= y\nx é maior ou igual a y?\n\n\n5\nx == y\nx é igual a y?\n\n\n6\nx != y\nx é diferente de y?\n\n\n7\nnot x\nNegativa de x (inverte o valor lógico)\n\n\n8\nx or y\nx ou y são verdadeiros? (ou inclusivo)\n\n\n9\nx and y\nx e y são verdadeiros? (e lógico)\n\n\n10\nx ^ y\nx ou y, mas não ambos, são verdadeiros? (xor lógico)\n\n\n\n\n\nMostrar código\na = 5\nb = 10\nprint(a &lt; b)  ## True\nprint(a == b)  ## False\n\n\nTrue\nFalse\n\n\n\n\nMostrar código\nx = True\nprint(not x)  ## False\n\n\nFalse\n\n\n\n\nMostrar código\nx = False\ny = True\nprint(x or y)  ## True\n\n\nTrue\n\n\n\n\nMostrar código\nx = True\ny = False\nprint(x and y)  ## False\n\n\nFalse\n\n\n\n\nMostrar código\nx = True\ny = False\nprint(x ^ y)  ## True (apenas um dos dois é verdadeiro)\n\n\nTrue\n\n\n\n1.4.1 Cuidado!\nEm Python, o operador ^ não é usado para exponenciação. Em vez disso, ele é o operador bitwise XOR (ou exclusivo) para manipulação de bits.\nO operador XOR (ou exclusivo) compara os bits de dois números. Ele retorna 1 quando os bits são diferentes e 0 quando os bits são iguais.\n\n\nMostrar código\na = 5   ## Em binário: 101\nb = 3   ## Em binário: 011\n\nresultado = a ** b  ## Faz XOR bit a bit\n\nprint(resultado)  ## Saída: 6 (Em binário: 110)\n\n\n125\n\n\n\n\nMostrar código\na = 5   ## Em binário: 101\nb = 3   ## Em binário: 011\n\nresultado = a ^ b  ## Faz XOR bit a bit\n\nprint(resultado)  ## Saída: 6 (Em binário: 110)\n\n\n6",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#caracteresstrings-em-python",
    "href": "0_py.html#caracteresstrings-em-python",
    "title": "1  Breve introdução ao Python",
    "section": "1.5 Caracteres/Strings em Python",
    "text": "1.5 Caracteres/Strings em Python\nEm Python, uma string é uma sequência de caracteres que pode ser usada para armazenar e manipular textos. Strings são um dos tipos de dados mais comuns e úteis, e Python oferece uma grande variedade de métodos e operações para trabalhar com elas.\nAs strings em Python podem ser definidas de diferentes maneiras, usando aspas simples (’) ou aspas duplas (“).\n\n\nMostrar código\n## Definindo strings\nnome = 'Thiago'\ncidade = \"São Carlos\"\n\n\n\nConcatenar Strings: Você pode unir duas ou mais strings usando o operador +.\n\n\n\nMostrar código\n## Concatenação\nnome_completo = \"Thiago\" + \" \" + \"Rodrigo\"\nprint(nome_completo)  ## Resultado: Thiago Rodrigo\n\n\nThiago Rodrigo\n\n\n\nRepetir Strings: Você pode repetir uma string múltiplas vezes usando o operador *.\n\n\n\nMostrar código\nrepeticao = \"Oi! \" * 3\nprint(repeticao)  ## Resultado: Oi! Oi! Oi! \n\n\nOi! Oi! Oi! \n\n\n\nAcessar Caracteres por Índice: As strings em Python são indexadas, e você pode acessar um caractere específico usando o índice (começando em 0).\n\n\n\nMostrar código\nnome = \"Thiago\"\nprint(nome[0])  ## Resultado: T\nprint(nome[-1])  ## Resultado: o (último caractere)\n\n\nT\no\n\n\n\nFatiar Strings (Slicing): Você pode pegar uma parte da string usando fatias (substrings).\n\n\n\nMostrar código\nnome = \"Thiago\"\nprint(nome[0:3])  ## Resultado: Thi (caracteres do índice 0 ao 2)\n\n\nThi\n\n\n\nComprimento de Strings: Para saber quantos caracteres uma string tem, use a função len().\n\n\n\nMostrar código\nnome = \"Thiago\"\nprint(len(nome))  ## Resultado: 6\n\n\n6\n\n\n\n1.5.1 Métodos Úteis para Strings\n\nlower() e upper(): Convertem todas as letras para minúsculas ou maiúsculas, respectivamente.\n\n\n\nMostrar código\nnome = \"Thiago\"\nprint(nome.lower())  ## Resultado: thiago\nprint(nome.upper())  ## Resultado: THIAGO\n\n\nthiago\nTHIAGO\n\n\n\nstrip(): Remove espaços em branco no início e no final da string.\n\n\n\nMostrar código\nfrase = \"   Olá!   \"\nprint(frase.strip())  ## Resultado: Olá!\n\n\nOlá!\n\n\n\nreplace(): Substitui parte de uma string por outra.\n\n\n\nMostrar código\nfrase = \"Eu gosto de R\"\nnova_frase = frase.replace(\"R\", \"Python\")\nprint(nova_frase)  ## Resultado: Eu gosto de programação\n\n\nEu gosto de Python\n\n\n\nsplit(): Divide uma string em uma lista, utilizando um delimitador (por padrão, espaço).\n\n\n\nMostrar código\nfrase = \"Eu gosto de Python\"\npalavras = frase.split()\nprint(palavras)  ## Resultado: ['Eu', 'gosto', 'de', 'Python']\n\n\n['Eu', 'gosto', 'de', 'Python']\n\n\n\njoin(): Une uma lista de strings em uma única string, usando um delimitador.\n\n\n\nMostrar código\nlista = ['Thiago', 'Rodrigo', 'Ramos']\nnome_completo = \" \".join(lista)\nprint(nome_completo)  ## Resultado: Thiago Rodrigo Ramos\n\n\nThiago Rodrigo Ramos",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#listas",
    "href": "0_py.html#listas",
    "title": "1  Breve introdução ao Python",
    "section": "1.6 Listas",
    "text": "1.6 Listas\nEm Python, listas são coleções ordenadas e mutáveis, o que significa que você pode modificar os elementos após sua criação. Elas são definidas usando colchetes [] e podem armazenar múltiplos tipos de dados, como inteiros, strings ou até mesmo outras listas.\nCaracterísticas principais:\n\nMutáveis: você pode adicionar, remover ou modificar elementos.\nOrdenadas: os elementos mantêm a ordem em que são inseridos.\nAcesso por índice: os elementos podem ser acessados pelo índice, começando por 0.\n\n\n\nMostrar código\n## Criando uma lista\nfrutas = ['maçã', 'banana', 'laranja']\n\n## Acessando elementos\nprint(frutas[1])  ## banana\n\n## Modificando a lista\nfrutas.append('uva')  ## Adiciona 'uva' ao final\nfrutas[0] = 'kiwi'    ## Substitui 'maçã' por 'kiwi'\n\n## Removendo um elemento\nfrutas.remove('banana')\n\nprint(frutas)  ## ['kiwi', 'laranja', 'uva']\n\n\nbanana\n['kiwi', 'laranja', 'uva']",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#tuplas",
    "href": "0_py.html#tuplas",
    "title": "1  Breve introdução ao Python",
    "section": "1.7 Tuplas",
    "text": "1.7 Tuplas\nAs tuplas em Python são semelhantes às listas, porém, diferentemente das listas, são imutáveis, ou seja, seus elementos não podem ser modificados após a criação. Elas são úteis quando você deseja garantir que uma sequência de valores permaneça inalterada. As tuplas são definidas usando parênteses (). Características principais:\n\nImutáveis: uma vez criadas, seus elementos não podem ser alterados, adicionados ou removidos.\nOrdenadas: os elementos mantêm a ordem de inserção.\nAcesso por índice: assim como nas listas, os elementos podem ser acessados por índices, começando do 0.\n\n\n\nMostrar código\n## Criando uma tupla\ncoordenadas = (10, 20)\n\n## Acessando elementos\nprint(coordenadas[0])  ## 10\n\n\n## Tuplas podem armazenar diferentes tipos de dados\ndados = ('Thiago', 30, True)\n\nprint(dados)  ## ('Thiago', 30, True)\n\n\n10\n('Thiago', 30, True)\n\n\n\n\nMostrar código\n### Tentando modificar a tupla (resultará em erro)\n## coordenadas[0] = 15  # TypeError: 'tuple' object does not support item assignment",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#dicionários",
    "href": "0_py.html#dicionários",
    "title": "1  Breve introdução ao Python",
    "section": "1.8 Dicionários",
    "text": "1.8 Dicionários\nOs dicionários em Python são coleções não ordenadas de pares chave-valor. Eles permitem associar valores a uma chave específica, sendo muito úteis quando você precisa acessar elementos por meio de uma chave, em vez de um índice. Eles são definidos com chaves {}.\nCaracterísticas principais:\n\nMutáveis: você pode adicionar, remover ou modificar pares chave-valor.\nNão ordenados: a ordem dos elementos não é garantida nas versões anteriores ao Python 3.7.\nAcesso por chave: os valores são acessados por suas chaves, que podem ser de tipos imutáveis (como strings ou números).\n\n\n\nMostrar código\n## Criando um dicionário\nestudante = {\n    'nome': 'Ana',\n    'idade': 22,\n    'curso': 'Estatística'\n}\n\n## Acessando valores\nprint(estudante['nome'])  ## Ana\n\n## Modificando o dicionário\nestudante['idade'] = 23  ## Atualiza o valor da chave 'idade'\n\n## Adicionando um novo par chave-valor\nestudante['matricula'] = 12345\n\n## Removendo um elemento\ndel estudante['curso']\n\nprint(estudante)  ## {'nome': 'Ana', 'idade': 23, 'matricula': 12345}\n\n\nAna\n{'nome': 'Ana', 'idade': 23, 'matricula': 12345}",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#funções-em-python",
    "href": "0_py.html#funções-em-python",
    "title": "1  Breve introdução ao Python",
    "section": "1.9 Funções em Python",
    "text": "1.9 Funções em Python\nAs funções em Python são blocos de código reutilizáveis que realizam uma tarefa específica. Elas ajudam a organizar o código, tornando-o mais modular e legível. Você pode definir suas próprias funções usando a palavra-chave def, e elas podem receber parâmetros, retornar valores ou simplesmente executar uma ação. Características principais:\n\nReutilizáveis: uma vez definida, a função pode ser chamada várias vezes no código.\nModulares: permitem dividir o código em partes menores e mais organizadas.\nParâmetros opcionais ou obrigatórios: funções podem receber parâmetros (ou argumentos) para realizar operações com base neles.\n\n\n\nMostrar código\ndef saudacao(nome):\n    \"\"\"Exibe uma saudação personalizada.\"\"\"\n    print(f\"Olá, {nome}!\")\n\n## Chamando a função\nsaudacao(\"Thiago\")  ## Olá, Thiago!\n\n\nOlá, Thiago!\n\n\n\n1.9.1 Return\nFunções podem retornar valores usando a palavra-chave return. Isso permite que o resultado da função seja usado em outras partes do código.\n\n\nMostrar código\ndef soma(a, b):\n    \"\"\"Retorna a soma de dois números.\"\"\"\n    return a + b\n\nresultado = soma(3, 5)\nprint(resultado)  ## 8\n\n\n8\n\n\n\n\n1.9.2 Parâmetros Opcionais e Valores Padrão\nVocê pode definir parâmetros opcionais em uma função, atribuindo valores padrão a eles.\n\n\nMostrar código\ndef saudacao(nome=\"amigo\"):\n    \"\"\"Exibe uma saudação personalizada, com um nome padrão.\"\"\"\n    print(f\"Olá, {nome}!\")\n\nsaudacao()         ## Olá, amigo!\nsaudacao(\"Rafael\")  ## Olá, Rafael!\n\n\nOlá, amigo!\nOlá, Rafael!\n\n\n\n\n1.9.3 Lambda\nPython também oferece funções anônimas (ou funções lambda), que são funções curtas e sem nome. Elas são úteis quando você precisa de uma função simples e temporária.\n\n\nMostrar código\n## Função lambda para multiplicar dois números\nmultiplicar = lambda x, y: x * y\nprint(multiplicar(3, 4))  ## 12\n\n\n12",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#loops",
    "href": "0_py.html#loops",
    "title": "1  Breve introdução ao Python",
    "section": "1.10 Loops",
    "text": "1.10 Loops\nOs loops são estruturas fundamentais de programação que permitem executar um bloco de código repetidamente enquanto uma condição for verdadeira ou para cada item de uma sequência. Python oferece dois tipos principais de loops: for e while.\n\n1.10.1 for\nO loop for é usado para iterar sobre uma sequência (como uma lista, tupla, string ou range) e executar um bloco de código para cada item dessa sequência. É especialmente útil quando o número de iterações é conhecido ou quando você deseja percorrer uma estrutura de dados.\n\n\nMostrar código\n## Iterando sobre uma lista\nfrutas = ['maçã', 'banana', 'laranja']\nfor fruta in frutas:\n    print(fruta)\n\n\nmaçã\nbanana\nlaranja\n\n\n\n\nMostrar código\n## Iterando de 0 a 4\nfor i in range(5):\n    print(i)\n\n\n0\n1\n2\n3\n4\n\n\n\n\nMostrar código\nfrutas = ['maçã', 'banana', 'laranja']\nfor i, fruta in enumerate(frutas):\n    print(i, fruta)\n\n\n0 maçã\n1 banana\n2 laranja\n\n\n\n\n1.10.2 while\nO loop while executa um bloco de código repetidamente enquanto uma condição for verdadeira. Ele é útil quando o número de iterações não é conhecido antecipadamente e depende de uma condição dinâmica.\n\n\nMostrar código\n## Loop enquanto o valor de x for menor que 5\nx = 0\nwhile x &lt; 5:\n    print(x)\n    x += 1\n\n\n0\n1\n2\n3\n4\n\n\n\n\n1.10.3 Controle de Loops: break e continue\nbreak: interrompe o loop imediatamente, mesmo que a condição ainda seja verdadeira (no caso do while) ou ainda restem itens na sequência (no caso do for).\ncontinue: pula para a próxima iteração do loop, ignorando o código restante naquela iteração.\n\n\nMostrar código\nfor i in range(10):\n    if i == 5:\n        break  ## Interrompe o loop quando i é igual a 5\n    print(i)\n\n\n0\n1\n2\n3\n4\n\n\n\n\nMostrar código\nfor i in range(5):\n    if i == 3:\n        continue  ## Pula a iteração quando i é igual a 3\n    print(i)\n\n\n0\n1\n2\n4",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#estruturas-condicionais-if-else-e-elif-em-python",
    "href": "0_py.html#estruturas-condicionais-if-else-e-elif-em-python",
    "title": "1  Breve introdução ao Python",
    "section": "1.11 Estruturas Condicionais: if, else e elif em Python",
    "text": "1.11 Estruturas Condicionais: if, else e elif em Python\nAs estruturas condicionais em Python permitem que o programa tome decisões e execute blocos de código diferentes com base em condições específicas. As principais instruções condicionais são if, else e elif.\n\n1.11.1 if\nA instrução if é usada para executar um bloco de código se uma condição for verdadeira. Se a condição avaliada for True, o bloco de código indentado após o if será executado.\n\n\nMostrar código\nidade = 20\nif idade &gt;= 18:\n    print(\"Você é maior de idade\")\n\n\nVocê é maior de idade\n\n\n\n\n1.11.2 else\nA instrução else é usada para executar um bloco de código se a condição do if for falsa. É como uma segunda opção, caso a primeira condição não seja atendida.\n\n\nMostrar código\nidade = 16\nif idade &gt;= 18:\n    print(\"Você é maior de idade\")\nelse:\n    print(\"Você é menor de idade\")\n\n\nVocê é menor de idade\n\n\n\n\n1.11.3 elif\nA instrução elif (abreviação de else if) permite testar múltiplas condições. Se a condição if for falsa, o Python verificará a condição do elif. Você pode ter vários blocos elif em uma estrutura condicional.\n\n\nMostrar código\nnota = 85\nif nota &gt;= 90:\n    print(\"Aprovado com excelência\")\nelif nota &gt;= 70:\n    print(\"Aprovado\")\nelse:\n    print(\"Reprovado\")\n\n\nAprovado\n\n\n\n\n1.11.4 Operadores lógicos\nAs condições podem usar operadores lógicos para combinar mais de uma verificação:\n\nand: todas as condições devem ser verdadeiras.\nor: pelo menos uma condição deve ser verdadeira.\nnot: inverte o resultado da condição.\n\n\n\nMostrar código\nidade = 20\npossui_carteira = True\n\nif idade &gt;= 18 and possui_carteira:\n    print(\"Você pode dirigir\")\nelse:\n    print(\"Você não pode dirigir\")\n\n\nVocê pode dirigir",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#bibliotecas-essenciais-para-estatística-numpy-pandas-e-matplotlib",
    "href": "0_py.html#bibliotecas-essenciais-para-estatística-numpy-pandas-e-matplotlib",
    "title": "1  Breve introdução ao Python",
    "section": "1.12 Bibliotecas Essenciais para Estatística: NumPy, Pandas e Matplotlib",
    "text": "1.12 Bibliotecas Essenciais para Estatística: NumPy, Pandas e Matplotlib\nEm Python, as bibliotecas NumPy, Pandas, e Matplotlib são amplamente utilizadas para análise de dados e computação científica. Elas fornecem ferramentas poderosas para lidar com grandes volumes de dados, realizar cálculos matemáticos eficientes e criar visualizações de alta qualidade. Vamos detalhar cada uma delas:\n\n1.12.1 NumPy\nNumPy (Numerical Python) é uma biblioteca fundamental para cálculos matemáticos em Python. Ela fornece suporte para arrays e matrizes multidimensionais, além de uma coleção de funções para operações com esses arrays. Principais características:\n\nArray multidimensional (ndarray): O ndarray é a estrutura central da NumPy, oferecendo suporte a vetores e matrizes de várias dimensões, com operações eficientes em termos de memória e tempo de execução.\nOperações vetorizadas: Permite realizar operações em todos os elementos de um array sem a necessidade de loops explícitos.\nFunções matemáticas: Inclui uma vasta gama de funções para álgebra linear, estatística, trigonometria, entre outros.\n\n\n\nMostrar código\nimport numpy as np\n\n## Criando um array NumPy\narray = np.array([1, 2, 3, 4, 5])\n\n## Operações elementares\nprint(array * 2)  ## Multiplicação por escalar: [2 4 6 8 10]\n\n## Matrizes e operações matriciais\nmatriz = np.array([[1, 2], [3, 4]])\nprint(np.dot(matriz, matriz))  ## Multiplicação de matrizes\n\n\n[ 2  4  6  8 10]\n[[ 7 10]\n [15 22]]\n\n\n\n\nMostrar código\ndados = np.array([1, 2, 3, 4, 5])\nmedia = np.mean(dados)\nprint(media)  ## Saída: 3.0\n\n\n3.0\n\n\n\n\nMostrar código\nmediana = np.median(dados)\nprint(mediana)  ## Saída: 3.0\n\n\n3.0\n\n\n\n\nMostrar código\nvariancia = np.var(dados)\nprint(variancia)  ## Saída: 2.0\n\n\n2.0\n\n\n\n\nMostrar código\ndesvio_padrao = np.std(dados)\nprint(desvio_padrao)  ## Saída: 1.4142135623730951\n\n\n1.4142135623730951\n\n\n\n\nMostrar código\nminimo = np.min(dados)\nmaximo = np.max(dados)\nprint(minimo, maximo)  ## Saída: 1 5\n\n\n1 5\n\n\n\n\nMostrar código\np25 = np.percentile(dados, 25)\np50 = np.percentile(dados, 50)\np75 = np.percentile(dados, 75)\nprint(p25, p50, p75)  ## Saída: 2.0 3.0 4.0\n\n\n2.0 3.0 4.0\n\n\n\n\n1.12.2 Pandas\nPandas é uma biblioteca poderosa para manipulação de dados em Python, frequentemente usada em projetos de ciência de dados, análise estatística e processamento de dados tabulares. Ela oferece estruturas de dados como DataFrames e Series que facilitam a organização, limpeza e análise de dados, tornando-a uma das ferramentas mais populares para lidar com grandes volumes de dados.\n\n1.12.2.1 Séries\nUma Series é uma coluna de dados unidimensional, semelhante a um array de NumPy, mas com rótulos (índices) associados a cada valor. A Series pode armazenar qualquer tipo de dado, como inteiros, floats, strings, ou objetos.\n\n\nMostrar código\nimport pandas as pd\n\n## Criando uma Series\ns = pd.Series([1, 2, 3, 4, 5], index=['a', 'b', 'c', 'd', 'e'])\nprint(s)\n\n## Acessando elementos por índice\nprint(s['b'])  ## Saída: 2\n\n\na    1\nb    2\nc    3\nd    4\ne    5\ndtype: int64\n2\n\n\n\n\n1.12.2.2 DataFrame\nO DataFrame é a estrutura de dados mais importante do Pandas. Ele é uma tabela bidimensional (semelhante a uma planilha ou tabela SQL) com rótulos para as linhas e colunas. Cada coluna de um DataFrame é uma Series, e as colunas podem ter diferentes tipos de dados.\n\n\nMostrar código\n## Criando um DataFrame a partir de um dicionário\ndados = {\n    'Nome': ['Ana', 'Pedro', 'João'],\n    'Idade': [23, 34, 19],\n    'Cidade': ['São Paulo', 'Rio de Janeiro', 'Curitiba']\n}\n\ndf = pd.DataFrame(dados)\nprint(df)\n\n\n    Nome  Idade          Cidade\n0    Ana     23       São Paulo\n1  Pedro     34  Rio de Janeiro\n2   João     19        Curitiba\n\n\n\n\n1.12.2.3 Operações Essenciais com DataFrames\n\nSelecionar Colunas\nFiltragem de Dados\nAlteração de Dados\nAgrupamento e Agregação\nTratamento de Dados Faltantes\n\n\n\nMostrar código\n## Selecionando uma única coluna\nprint(df['Nome'])\n\n\n0      Ana\n1    Pedro\n2     João\nName: Nome, dtype: object\n\n\n\n\nMostrar código\n## Selecionando múltiplas colunas\nprint(df[['Nome', 'Cidade']])\n\n\n    Nome          Cidade\n0    Ana       São Paulo\n1  Pedro  Rio de Janeiro\n2   João        Curitiba\n\n\n\n\nMostrar código\n## Filtrando o DataFrame para mostrar apenas pessoas com mais de 20 anos\nfiltro = df[df['Idade'] &gt; 20]\nprint(filtro)\n\n\n    Nome  Idade          Cidade\n0    Ana     23       São Paulo\n1  Pedro     34  Rio de Janeiro\n\n\n\n\nMostrar código\n## Alterando o valor de uma célula\ndf.loc[0, 'Idade'] = 24\n## Alterando uma coluna inteira\ndf['Idade'] = df['Idade'] + 1\n\n\n\n\nMostrar código\n## Agrupando por 'Cidade' e calculando a média de 'Idade'\nagrupado = df.groupby('Cidade')['Idade'].mean()\nprint(agrupado)\n\n\nCidade\nCuritiba          20.0\nRio de Janeiro    35.0\nSão Paulo         25.0\nName: Idade, dtype: float64\n\n\n\n\nMostrar código\n## Verificando valores faltantes\nprint(df.isnull().sum())\n\n## Removendo linhas com dados faltantes\ndf_limpo = df.dropna()\n\n## Preenchendo valores faltantes\ndf['Idade'].fillna(df['Idade'].mean())\n\n\nNome      0\nIdade     0\nCidade    0\ndtype: int64\n\n\n0    25\n1    35\n2    20\nName: Idade, dtype: int64\n\n\n\n\n1.12.2.4 Estatísticas e Operações com Dados\nPandas facilita o cálculo de estatísticas descritivas, como média, desvio padrão, contagem, entre outras.\n\n\nMostrar código\n## Estatísticas descritivas\nprint(df.describe())\n\n\n           Idade\ncount   3.000000\nmean   26.666667\nstd     7.637626\nmin    20.000000\n25%    22.500000\n50%    25.000000\n75%    30.000000\nmax    35.000000\n\n\n\n\nMostrar código\n## Soma, contagem e média de colunas específicas\nprint(df['Idade'].sum())\nprint(df['Idade'].count())\nprint(df['Idade'].mean())\n\n\n80\n3\n26.666666666666668\n\n\n\n\n\n1.12.3 Matplotlib: Biblioteca de Visualização de Dados em Python\nMatplotlib é uma biblioteca poderosa e flexível para visualização de dados em Python. Ela permite criar uma ampla gama de gráficos, desde simples gráficos de linha até visualizações complexas e altamente customizadas. Embora outras bibliotecas como Seaborn ou Plotly sejam populares para visualizações avançadas, Matplotlib continua sendo o núcleo para muitas dessas bibliotecas e é amplamente utilizado por sua versatilidade e integração com NumPy e Pandas.\nA maneira mais comum de usar Matplotlib é através do submódulo pyplot, que fornece uma interface simples para criar gráficos. A estrutura básica de um gráfico com pyplot envolve definir os dados e criar o gráfico com funções que controlam o comportamento do gráfico.\n\n\nMostrar código\nimport matplotlib.pyplot as plt\n\n## Dados\nx = [0, 1, 2, 3, 4]\ny = [0, 1, 4, 9, 16]\n\n## Criando um gráfico de linha\nplt.plot(x, y)\n\n## Adicionando título e rótulos aos eixos\nplt.title('Gráfico de Quadrados')\nplt.xlabel('Eixo X')\nplt.ylabel('Eixo Y')\n\n## Exibindo o gráfico\nplt.show()\n\n\n\n\n\n\n\n\n\n\n1.12.3.1 Tipos de Gráficos Comuns\n\n1.12.3.1.1 Linha\n\n\nMostrar código\nx = [0, 1, 2, 3, 4]\ny = [0, 1, 4, 9, 16]\nplt.plot(x, y)\nplt.title('Gráfico de Linha')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n1.12.3.1.2 Dispersão\n\n\nMostrar código\nplt.scatter(x, y)\nplt.title('Gráfico de Dispersão')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n1.12.3.1.3 Barras\n\n\nMostrar código\ncategorias = ['A', 'B', 'C']\nvalores = [5, 7, 3]\nplt.bar(categorias, valores)\nplt.title('Gráfico de Barras')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n1.12.3.1.4 Histograma\n\n\nMostrar código\nimport numpy as np\n\ndados = np.random.randn(1000)\nplt.hist(dados, bins=30, color='skyblue', edgecolor='black')\nplt.title('Histograma de Dados Aleatórios')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n1.12.3.1.5 Pizza\n\n\nMostrar código\ntamanhos = [15, 30, 45, 10]\nlabels = ['A', 'B', 'C', 'D']\nplt.pie(tamanhos, labels=labels, autopct='%1.1f%%')\nplt.title('Gráfico de Pizza')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n1.12.3.2 Customização\n\n1.12.3.2.1 Alterando Cores e Estilos de Linha\n\n\nMostrar código\nplt.plot(x, y, color='red', linestyle='--', marker='o')  ## Linha vermelha com marcador\nplt.title('Gráfico Customizado')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n1.12.3.2.2 Adicionando Títulos e Rótulos aos Eixos\n\n\nMostrar código\nplt.plot(x, y)\nplt.title('Título do Gráfico')\nplt.xlabel('Eixo X')\nplt.ylabel('Eixo Y')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n1.12.3.2.3 Legendas\n\n\nMostrar código\nplt.plot(x, y, label='Quadrados')\nplt.plot(x, [i**3 for i in x], label='Cubos')\nplt.title('Gráfico com Legenda')\nplt.legend()  ## Adiciona legenda\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n1.12.3.2.4 Ajustando os Eixos\n\n\nMostrar código\nplt.plot(x, y)\nplt.xlim(0, 5)\nplt.ylim(0, 20)\nplt.title('Ajuste de Eixos')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n1.12.3.2.5 Subplot\n\n\nMostrar código\n## Criando uma figura com dois gráficos lado a lado\nplt.figure(figsize=(10, 4))\n\nplt.subplot(1, 2, 1)  ## 1 linha, 2 colunas, 1º gráfico\nplt.plot(x, y)\nplt.title('Gráfico de Linha')\n\nplt.subplot(1, 2, 2)  ## 1 linha, 2 colunas, 2º gráfico\nplt.bar(categorias, valores)\nplt.title('Gráfico de Barras')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n1.12.3.3 Integração com Pandas\n\n\nMostrar código\nimport pandas as pd\n\n## Criando um DataFrame\ndados = {\n    'Dia': [1, 2, 3, 4, 5],\n    'Vendas': [200, 300, 250, 400, 350]\n}\ndf = pd.DataFrame(dados)\n\n## Plotando os dados\ndf.plot(x='Dia', y='Vendas', kind='line')\nplt.title('Vendas ao Longo dos Dias')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_py.html#exercícios",
    "href": "0_py.html#exercícios",
    "title": "1  Breve introdução ao Python",
    "section": "1.13 Exercícios",
    "text": "1.13 Exercícios\n\n1.13.1 Exercício 1.\nExecute as seguintes operações no Python e interprete os resultados:\n\nUse a função math.log() para calcular o logaritmo natural de 10 e depois o logaritmo na base 10 de 1000.\nDescubra a função que calcula a raiz quadrada de um número utilizando a função help(), e aplique-a ao número 144.\n\n\n\n1.13.2 Exercício 2.\nArmazene o resultado de 2 * 7 em uma variável chamada resultado. Use resultado para calcular o valor de resultado ** 2.\nListe todas as variáveis no ambiente do Python usando a função globals(). Exclua a variável resultado usando del e verifique novamente as variáveis presentes.\n\n\n1.13.3 Exercício 3.\nCrie um vetor NumPy v contendo os números 4, 8, 15, 16, 23, 42. Use subsetting para selecionar: - O segundo e o quarto elemento. - Todos os elementos exceto o terceiro. - Os elementos que são maiores que 10.\nMultiplique cada elemento do vetor NumPy v por 2 e armazene o resultado em um novo vetor v2.\n\n\n1.13.4 Exercício 4.\nVerifique se 8 &gt; 5 e se 8 == 10.\nCrie dois vetores NumPy lógicos a = np.array([True, False, True]) e b = np.array([False, True, False]). Aplique os operadores &, | e np.logical_xor() nesses vetores.\n\n\n1.13.5 Exercício 5.\nEscreva uma função soma_quadrados que receba dois números como argumentos e retorne a soma de seus quadrados. Teste sua função com os números 3 e 4.\nModifique a função soma_quadrados para que o segundo argumento tenha um valor padrão de 2. Teste a função chamando-a com apenas um argumento.\n\n\n1.13.6 Exercício 6.\nEscreva um laço for que calcule a soma dos números de 1 a 100.\nCrie um laço while que multiplique os números de 1 a 6 e retorne o resultado.\n\n\n1.13.7 Exercício 7.\nCrie duas variáveis com o seu primeiro e último nome. Use a função f-string para juntar as duas variáveis em uma frase que diga “Meu nome completo é [nome completo]”.\nAltere o separador para um traço - e junte novamente as variáveis.\n\n\n1.13.8 Exercício 8.\nCrie um DataFrame com os dados fictícios a seguir utilizando pandas:\n\n\n\nNome\nIdade\nCidade\n\n\n\n\nAna\n23\nSão Paulo\n\n\nPedro\n34\nRio de Janeiro\n\n\nJoão\n19\nCuritiba\n\n\n\nFiltre as observações onde a idade é maior que 20.\nOrdene o DataFrame pela coluna Idade em ordem decrescente.\n\n\n1.13.9 Exercício 9.\nUsando o DataFrame criado no exercício anterior, crie um gráfico de barras (plt.bar) que mostre a idade de cada pessoa.\nNo gráfico anterior, mude a cor de cada barra.\n\n\n1.13.10 Exercício 10.\nCrie um DataFrame com os dados de temperatura de uma semana:\n\n\n\nDia\nTemperatura (°C)\n\n\n\n\nSeg\n22\n\n\nTer\n24\n\n\nQua\n19\n\n\nQui\n21\n\n\nSex\n23\n\n\nSáb\n25\n\n\nDom\n20\n\n\n\nAgora, responda às perguntas abaixo:\n\nFiltre todos os dias em que a temperatura foi maior que 21°C.\nCalcule a média das temperaturas da semana.\nCrie um gráfico de linha (plt.plot) que mostre a variação da temperatura ao longo da semana.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Breve introdução ao Python</span>"
    ]
  },
  {
    "objectID": "0_R.html",
    "href": "0_R.html",
    "title": "2  Breve Introdução ao R",
    "section": "",
    "text": "2.1 Variáveis Numéricas\nAqui vão alguns exemplos para começarmos a entender como o R funciona. Inicialmente, veremos como podemos usar o R como calculadora.\n2 * 7\n\n[1] 14\n\n0 / 0\n\n[1] NaN\n\n10^1000\n\n[1] Inf\n\nlog(1)\n\n[1] 0\n\nexp(1)\n\n[1] 2.718282\nPara entender o que uma função faz, você pode digitar o símbolo de interrogação seguido do nome da função, por exemplo:\n?exp\nO help contém as seguintes informações:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#variáveis-numéricas",
    "href": "0_R.html#variáveis-numéricas",
    "title": "2  Breve Introdução ao R",
    "section": "",
    "text": "Description: Resumo geral sobre o uso da função.\nUsage: Mostra como a função deve ser utilizada e quais argumentos podem ser especificados.\nArguments: Explica o que é cada um dos argumentos.\nDetails: Explica alguns detalhes sobre o uso e aplicação da função.\nValue: Mostra o que sai no output após usar a função (os resultados).\nNote: Notas sobre a função.\nAuthors: Lista os autores da função.\nReferences: Referências para os métodos usados.\nSee also: Outras funções relacionadas que podem ser consultadas.\nExamples: Exemplos do uso da função.\n\n\n2.1.1 Armazenando resultados em variáveis\nPodemos também armazenar resultados de contas em variáveis. Por exemplo:\n\nx = 2 + 3\nx\n\n[1] 5\n\ny = 2 * x\ny\n\n[1] 10\n\nprint(y)\n\n[1] 10\n\n\nNúmeros grandes são impressos usando notação científica:\n\ny = 2 * 10^10\nprint(y)\n\n[1] 2e+10\n\n\nPara listar quais variáveis estão declaradas no ambiente, podemos usar:\n\nls()\n\n[1] \"x\" \"y\"\n\n\nPara remover uma variável:\n\nrm(x)\nls()\n\n[1] \"y\"\n\n\nPara remover todas as variáveis existentes:\n\nrm(list = ls())  # Essa função apaga todas as variáveis existentes\ngc()  # Essa função libera a memória utilizada\n\n          used (Mb) gc trigger (Mb) max used (Mb)\nNcells  624768 33.4    1280200 68.4  1280200 68.4\nVcells 1176378  9.0    8388608 64.0  1932265 14.8",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#variáveis-lógicas",
    "href": "0_R.html#variáveis-lógicas",
    "title": "2  Breve Introdução ao R",
    "section": "2.2 Variáveis Lógicas",
    "text": "2.2 Variáveis Lógicas\nAlguns operadores lógicos definidos no R são mostrados na tabela abaixo:\n\n\n\n#\nOperador\nDescrição\n\n\n\n\n1\nx &lt; y\nx menor que y?\n\n\n2\nx &lt;= y\nx menor ou igual a y?\n\n\n3\nx &gt; y\nx maior que y?\n\n\n4\nx &gt;= y\nx maior ou igual a y?\n\n\n5\nx == y\nx igual a y?\n\n\n6\nx != y\nx diferente de y?\n\n\n7\n!x\nNegativa de x\n\n\n8\nx | y\nx ou y são verdadeiros?\n\n\n9\nx & y\nx e y são verdadeiros?\n\n\n10\nxor(x, y)\nApenas um dos dois é verdadeiro?\n\n\n\n\n2.2.1 Exemplos de uso de operadores lógicos\n\n1 == 3\n\n[1] FALSE\n\n1 == 1\n\n[1] TRUE\n\n1 &lt;= 3\n\n[1] TRUE\n\nx = 1 &gt; 3\nprint(x)\n\n[1] FALSE\n\nx = 1; y = 3\nx &lt; y\n\n[1] TRUE\n\n(x == 1) & (y == 3)\n\n[1] TRUE\n\n(x == 1) & (y != 3)\n\n[1] FALSE\n\n!TRUE\n\n[1] FALSE\n\nx = TRUE; y = FALSE\nx | y\n\n[1] TRUE\n\n\nO número um tem o valor verdadeiro, e o número zero tem o valor falso:\n\nx = 1; y = 0\nx | y\n\n[1] TRUE\n\n\nNote que ao fazermos contas com variáveis lógicas, elas são transformadas em zero e um:\n\n(TRUE | FALSE) + 2\n\n[1] 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#caracteresstrings",
    "href": "0_R.html#caracteresstrings",
    "title": "2  Breve Introdução ao R",
    "section": "2.3 Caracteres/Strings",
    "text": "2.3 Caracteres/Strings\nPara declarar cadeias de caracteres, usamos aspas no R:\n\nx = \"Rafael\"\ny = \"Izbicki\"\n\nVárias operações podem ser feitas com esses objetos. Um exemplo é a função paste:\n\npaste(x, y)\n\n[1] \"Rafael Izbicki\"\n\npaste(x, y, sep = \"+\")\n\n[1] \"Rafael+Izbicki\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#vetores-e-sequências",
    "href": "0_R.html#vetores-e-sequências",
    "title": "2  Breve Introdução ao R",
    "section": "2.4 Vetores e Sequências",
    "text": "2.4 Vetores e Sequências\nUsualmente declaramos vetores usando o operador c (concatenação):\n\nx = c(2, 5, 7, 1)\nx\n\n[1] 2 5 7 1\n\n\nPara acessar seus componentes, fazemos:\n\nx[2]\n\n[1] 5\n\n# [1] 5\n\nx = x[c(2, 3)]\nx[2:3]\n\n[1]  7 NA\n\nx[-c(2, 3)]\n\n[1] 5\n\n\nAs operações x[c(2, 3)] e x[-c(2, 3)] são chamadas de subsetting; subsetting é a seleção de um subconjunto de um objeto. Veremos mais à frente outras maneiras de fazermos isso.\nPodemos mudar alguns dos valores deste vetor usando:\n\nx[2:3] = 0\nx\n\n[1] 5 0 0\n\n\nOperações aritméticas podem ser facilmente feitas para cada elemento de um vetor. Alguns exemplos:\n\nx = x - 1\nx\n\n[1]  4 -1 -1\n\nx = 2 * x\nx\n\n[1]  8 -2 -2\n\n\nUma função útil para criar vetores é a seq:\n\nx = seq(from = 1, to = 100, by = 2)\nx\n\n [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49\n[26] 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99\n\ny = seq(from = 1, to = 100, length = 5)\ny\n\n[1]   1.00  25.75  50.50  75.25 100.00\n\n\nPodemos também usar operadores lógicos em vetores:\n\nx &gt; 5\n\n [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[49]  TRUE  TRUE\n\n\nNote que x &gt; 5 é um vetor lógico.\nPodemos usar as operações lógicas em vetores lógicos:\n\nx = c(TRUE, TRUE, FALSE, FALSE)\ny = c(TRUE, FALSE, TRUE, FALSE)\n\nx | y\n\n[1]  TRUE  TRUE  TRUE FALSE\n\nx & y\n\n[1]  TRUE FALSE FALSE FALSE\n\n\nOperadores lógicos também podem ser usados para fazer subsetting:\n\nx[x &gt; 5] = 0\nx\n\n[1] 1 1 0 0\n\nx[!(x &lt;= 0)] = -1\nx\n\n[1] -1 -1  0  0\n\n\nPodemos ter vetores de caracteres:\n\nx = c(\"a\", \"c\", \"fgh\")\nx[-c(2, 3)]\n\n[1] \"a\"\n\npaste(x, \"add\")\n\n[1] \"a add\"   \"c add\"   \"fgh add\"\n\npaste(x, \"add\", collapse = \"+\")\n\n[1] \"a add+c add+fgh add\"\n\n\nAlgumas funções adicionais úteis:\n\nrep(2, 5)\n\n[1] 2 2 2 2 2\n\nrep(c(1, 2), 5)\n\n [1] 1 2 1 2 1 2 1 2 1 2\n\nrep(c(1, 2), each = 5)\n\n [1] 1 1 1 1 1 2 2 2 2 2\n\nsort(c(5, 10, 0, 20))\n\n[1]  0  5 10 20\n\norder(c(5, 10, 0, 20))\n\n[1] 3 1 2 4",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#funções",
    "href": "0_R.html#funções",
    "title": "2  Breve Introdução ao R",
    "section": "2.5 Funções",
    "text": "2.5 Funções\nPara declarar funções em R, fazemos:\nminhaFuncao &lt;- function(argumento1, argumento2) {\n  # corpo da função\n}\nPor exemplo:\n\npotencia &lt;- function(x, y) {\n  return(x^y)\n}\npotencia(2, 3)\n\n[1] 8\n\n# [1] 8\n\nNote que x e y podem ser vetores:\n\npotencia(x = c(1, 2, 3), y = c(0, 1, 2))\n\n[1] 1 2 9\n\n\nVocê pode inverter a ordem dos argumentos, desde que eles sejam nomeados:\n\npotencia(y = c(0, 1, 2), x = c(1, 2, 3))\n\n[1] 1 2 9\n\n\n\n2.5.1 Argumentos com valores default\nOs argumentos podem ter valores default. Por exemplo:\n\npotencia &lt;- function(x, y = rep(1, length(x))) {\n  return(x^y)\n}\n\nNeste caso, se o argumento y não for fornecido, ele será um vetor de uns do tamanho de x:\n\npotencia(2)\n\n[1] 2\n\npotencia(2, 3)\n\n[1] 8",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#laços",
    "href": "0_R.html#laços",
    "title": "2  Breve Introdução ao R",
    "section": "2.6 Laços",
    "text": "2.6 Laços\nPara calcular o fatorial de um número n, podemos usar um laço while:\n\nn &lt;- 4\ni &lt;- 1\nnFatorial &lt;- 1\nwhile(i &lt;= n) {\n  nFatorial &lt;- nFatorial * i\n  i &lt;- i + 1\n}\nnFatorial\n\n[1] 24\n\n\nOu podemos usar um laço for:\n\nn &lt;- 4\nnFatorial &lt;- 1\nfor(i in 1:n) {\n  nFatorial &lt;- nFatorial * i\n}\nnFatorial\n\n[1] 24\n\n\nLembre-se de que laços podem ser lentos no R, especialmente se o tamanho do objeto não for previamente declarado. Vamos comparar o tempo de execução de diferentes abordagens usando a função system.time. Para isso, vamos calcular a soma acumulada de um vetor.\n\nx &lt;- 1:100000\n\n\nLaço sem declaração de tamanho:\n\n\naux &lt;- function(x) {\n  somaAcumulada &lt;- NULL\n  somaAcumulada[1] &lt;- x[1]\n  for(i in 2:length(x)) {\n    somaAcumulada[i] &lt;- somaAcumulada[i - 1] + x[i]\n  }\n}\nsystem.time(aux(x))[1]\n\nuser.self \n    0.018 \n\n\n\nLaço com declaração de tamanho:\n\n\naux &lt;- function(x) {\n  somaAcumulada &lt;- rep(NA, length(x))\n  somaAcumulada[1] &lt;- x[1]\n  for(i in 2:length(x)) {\n    somaAcumulada[i] &lt;- somaAcumulada[i - 1] + x[i]\n  }\n}\nsystem.time(aux(x))[1]\n\nuser.self \n    0.007 \n\n\n\nFunção nativa do R:\n\n\naux &lt;- function(x) {\n  cumsum(x)\n}\nsystem.time(aux(x))[1]\n\nuser.self \n        0 \n\n\nNote que, em geral, funções nativas do R são muito mais rápidas.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#ifelse",
    "href": "0_R.html#ifelse",
    "title": "2  Breve Introdução ao R",
    "section": "2.7 If/Else",
    "text": "2.7 If/Else\nO R permite o uso de condicionais if e else para controlar o fluxo de execução. A sintaxe básica é:\nif (condição1) {\n  # código se a condição1 for verdadeira\n} else if (condição2) {\n  # código se a condição1 for falsa e condição2 verdadeira\n} else {\n  # código se todas as condições forem falsas\n}\nExemplo:\n\ntestaX &lt;- function(x) {\n  if (!is.numeric(x)) {\n    print(\"x não é um número\")\n  } else if (x &gt; 0) {\n    print(\"x é positivo\")\n  } else if (x &lt; 0) {\n    print(\"x é negativo\")\n  } else {\n    print(\"x é nulo\")\n  }\n}\ntestaX(5)\n\n[1] \"x é positivo\"\n\ntestaX(-5)\n\n[1] \"x é negativo\"\n\ntestaX(\"5\")\n\n[1] \"x não é um número\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#listas",
    "href": "0_R.html#listas",
    "title": "2  Breve Introdução ao R",
    "section": "2.8 Listas",
    "text": "2.8 Listas\nListas são como vetores, mas podem conter componentes de diferentes tipos (inclusive outras listas).\n\nminhaLista &lt;- list(\"um\", TRUE, 3, c(\"q\", \"u\", \"a\", \"t\", \"r\", \"o\"), \"cinco\")\nminhaLista[[3]]\n\n[1] 3\n\n\nVocê também pode atribuir nomes aos elementos de uma lista:\n\nminhaLista &lt;- list(primeiro = \"um\", segundo = TRUE, terceiro = 3, \n                   quarto = c(\"q\", \"u\", \"a\", \"t\", \"r\", \"o\"), quinto = \"cinco\")\nminhaLista$quinto\n\n[1] \"cinco\"\n\n\nListas são frequentemente usadas para retornar várias saídas de uma função. Por exemplo, ao ajustar um modelo de regressão linear, os resultados são armazenados em uma lista:\n\nx &lt;- rnorm(100)\ny &lt;- 1 + 2*x + rnorm(length(x), 0.1)\najuste &lt;- lm(y ~ x)\ntypeof(ajuste)\n\n[1] \"list\"\n\n\nOs componentes da lista podem ser acessados com:\n\nnames(ajuste)\n\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n\n\nPara ver os coeficientes ajustados:\n\najuste$coefficients\n\n(Intercept)           x \n   1.180955    1.998515 \n\n\nPara adicionar a reta estimada ao gráfico:\n\nplot(x, y, pch = 18, bty = \"l\")\nabline(ajuste, col = 2, lwd = 3)\n\n\n\n\n\n\n\n\nVocê também pode inicializar uma lista vazia:\n\nminhaLista &lt;- list()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#estatística-descritiva",
    "href": "0_R.html#estatística-descritiva",
    "title": "2  Breve Introdução ao R",
    "section": "2.9 Estatística Descritiva",
    "text": "2.9 Estatística Descritiva\nO R é uma ferramenta poderosa para realizar análises descritivas. Vamos explorar alguns recursos para calcular estatísticas de variáveis quantitativas e qualitativas.\n\n2.9.1 Variáveis quantitativas\n\nx &lt;- c(30, 1, 20, 5, 20, 60)\ny &lt;- c(12, 0, 2, 15, 22, 20)\n\nmean(x)\n\n[1] 22.66667\n\nvar(x)\n\n[1] 448.6667\n\nmin(x)\n\n[1] 1\n\nwhich.min(x)\n\n[1] 2\n\nmax(x)\n\n[1] 60\n\nwhich.max(x)\n\n[1] 6\n\nsort(x)\n\n[1]  1  5 20 20 30 60\n\norder(x)\n\n[1] 2 4 3 5 1 6\n\nmedian(x)\n\n[1] 20\n\ncor(x, y)\n\n[1] 0.5229211\n\nwhich(x &gt; 10)\n\n[1] 1 3 5 6\n\nmean(y[x &gt; 10])\n\n[1] 14\n\n\n\n\n2.9.2 Variáveis qualitativas\n\nx &lt;- c(\"S\", \"R\", \"P\", \"P\", \"Q\", \"P\")\ny &lt;- c(\"a\", \"a\", \"b\", \"a\", \"c\", \"d\")\n\nx[y %in% c(\"a\", \"c\")]\n\n[1] \"S\" \"R\" \"P\" \"Q\"\n\ntable(x)\n\nx\nP Q R S \n3 1 1 1 \n\ntable(x, y)\n\n   y\nx   a b c d\n  P 1 1 0 1\n  Q 0 0 1 0\n  R 1 0 0 0\n  S 1 0 0 0\n\n\n\n\n2.9.3 Subconjuntos\nPodemos utilizar subsetting para trabalhar com subconjuntos de interesse. Por exemplo, suponha que dados é um banco de dados com informações de alunos e queremos selecionar os alunos com idade menor que 20, altura maior que 1,70 e que estejam no primeiro ou segundo ano.\n\ndados[dados$idade &lt; 20 & dados$altura &gt; 1.70 & dados$ano %in% c(\"Primeiro\", \"Segundo\"), ]\n\n\n\n2.9.4 Funções Apply\nAs funções da família apply (como apply, lapply, sapply) são úteis para aplicar uma função a um conjunto de dados. Vamos criar um banco de dados artificial para exemplificar:\n\ndados &lt;- data.frame(altura = rnorm(100, 1.7, 0.2), salario = rnorm(100, 3000, 500))\ndados$peso &lt;- dados$altura * 35 + rnorm(100, 0, 10)\n\n\n2.9.4.1 apply\nPara calcular a média de cada coluna de dados, usamos:\n\napply(dados, 2, mean)\n\n     altura     salario        peso \n   1.661098 3016.864026   57.587183 \n\n\nAqui, o argumento 2 indica que a operação deve ser aplicada a cada coluna. Para calcular a soma de cada linha:\n\napply(dados, 1, sum)\n\n  [1] 2935.744 3054.520 3122.833 2785.382 2371.067 2374.897 3276.086 3599.872\n  [9] 3202.849 3335.403 3472.275 3506.096 3756.092 3515.777 2690.263 3475.250\n [17] 2410.579 2624.613 3957.345 4322.016 3627.880 3083.212 1664.785 3396.747\n [25] 1776.396 2422.286 3242.161 2928.739 3170.352 2508.977 3081.274 3694.196\n [33] 2802.322 3556.047 2570.867 2494.644 3192.393 4000.127 2678.139 2865.978\n [41] 3376.748 2564.606 3125.919 2476.885 3431.457 3177.050 3456.207 3417.807\n [49] 2549.082 2935.835 3405.988 3407.850 3457.041 3483.907 3368.209 3209.721\n [57] 3777.841 2797.109 2687.254 2689.787 2336.480 2926.791 2630.097 3403.019\n [65] 2814.302 3870.016 3382.403 3060.693 3178.307 3119.302 3287.427 3744.860\n [73] 2642.255 2826.829 3163.568 2231.616 3488.286 3113.651 2092.198 3233.338\n [81] 3868.429 3240.360 3592.499 3273.448 2255.725 2876.201 3541.237 2827.023\n [89] 3166.821 2359.415 2276.909 3086.540 3072.376 4402.089 2861.671 2959.195\n [97] 2985.327 2326.707 3372.387 3378.654\n\n\n\n\n2.9.4.2 Funções anônimas\nUsando funções anônimas, podemos calcular várias estatísticas descritivas ao mesmo tempo:\n\nestatisticas &lt;- apply(dados, 2, function(x) {\n  listaResultados &lt;- list()\n  listaResultados$media &lt;- mean(x)\n  listaResultados$mediaAparada &lt;- mean(x, trim = 0.1)\n  listaResultados$mediana &lt;- median(x)\n  listaResultados$maximo &lt;- max(x)\n  return(listaResultados)\n})\n\nestatisticas$altura\n\n$media\n[1] 1.661098\n\n$mediaAparada\n[1] 1.663011\n\n$mediana\n[1] 1.667594\n\n$maximo\n[1] 2.066719",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#o-operador-pipe",
    "href": "0_R.html#o-operador-pipe",
    "title": "2  Breve Introdução ao R",
    "section": "2.10 O operador %>% (pipe)",
    "text": "2.10 O operador %&gt;% (pipe)\n\nO operador pipe foi uma das grandes revoluções recentes do R, tornando o código mais legível. Esse operador está definido no pacote magrittr, e vários outros pacotes, como o dplyr, fazem uso dele (veja a próxima seção).\nA ideia é simples: o operador %&gt;% usa o resultado do lado esquerdo como o primeiro argumento da função do lado direito. Um exemplo:\n\nlibrary(magrittr)\nx &lt;- c(1, 2, 3, 4)\nx %&gt;% sum() %&gt;% sqrt()\n\n[1] 3.162278\n\n\nIsso é equivalente a:\n\nsqrt(sum(x))\n\n[1] 3.162278\n\n\nMas a leitura com pipe é mais clara. No RStudio, você pode inserir o pipe com o atalho ctrl + shift + m.\nO pipe envia o valor à esquerda apenas para o primeiro argumento da função à direita. Para utilizar o valor da esquerda em outro argumento, utilize o \".\":\n\ny &lt;- rnorm(10)\ny %&gt;% plot(x = 1:length(y), y = ., pch = 18)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#o-pacote-dplyr",
    "href": "0_R.html#o-pacote-dplyr",
    "title": "2  Breve Introdução ao R",
    "section": "2.11 O pacote dplyr",
    "text": "2.11 O pacote dplyr\nO pacote dplyr é muito útil para manipulação eficiente de data frames. Vamos demonstrar alguns exemplos usando o conjunto de dados hflights.\n\nlibrary(dplyr)\nlibrary(hflights)\ndata(hflights)\n\nPrimeiro, converta os dados para o formato tbl_df, uma variação mais amigável do data.frame:\n\nflights &lt;- tbl_df(hflights)\n\n\n2.11.1 Filter\nA função filter retorna todas as linhas que satisfazem uma condição. Por exemplo, para mostrar todos os voos do dia 1º de janeiro:\n\nflights %&gt;% filter(Month == 1, DayofMonth == 1)\n\n# A tibble: 552 × 21\n    Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum\n   &lt;int&gt; &lt;int&gt;      &lt;int&gt;     &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;chr&gt;             &lt;int&gt;\n 1  2011     1          1         6    1400    1500 AA                  428\n 2  2011     1          1         6     728     840 AA                  460\n 3  2011     1          1         6    1631    1736 AA                 1121\n 4  2011     1          1         6    1756    2112 AA                 1294\n 5  2011     1          1         6    1012    1347 AA                 1700\n 6  2011     1          1         6    1211    1325 AA                 1820\n 7  2011     1          1         6     557     906 AA                 1994\n 8  2011     1          1         6    1824    2106 AS                  731\n 9  2011     1          1         6     654    1124 B6                  620\n10  2011     1          1         6    1639    2110 B6                  622\n# ℹ 542 more rows\n# ℹ 13 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;,\n#   ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;,\n#   TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;,\n#   Diverted &lt;int&gt;\n\n\nPara condições alternativas, podemos usar o operador | (ou) ou %in%:\n\nflights %&gt;% filter(UniqueCarrier %in% c(\"AA\", \"UA\"))\n\n# A tibble: 5,316 × 21\n    Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum\n   &lt;int&gt; &lt;int&gt;      &lt;int&gt;     &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;chr&gt;             &lt;int&gt;\n 1  2011     1          1         6    1400    1500 AA                  428\n 2  2011     1          2         7    1401    1501 AA                  428\n 3  2011     1          3         1    1352    1502 AA                  428\n 4  2011     1          4         2    1403    1513 AA                  428\n 5  2011     1          5         3    1405    1507 AA                  428\n 6  2011     1          6         4    1359    1503 AA                  428\n 7  2011     1          7         5    1359    1509 AA                  428\n 8  2011     1          8         6    1355    1454 AA                  428\n 9  2011     1          9         7    1443    1554 AA                  428\n10  2011     1         10         1    1443    1553 AA                  428\n# ℹ 5,306 more rows\n# ℹ 13 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;,\n#   ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;,\n#   TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;,\n#   Diverted &lt;int&gt;\n\n\n\n\n2.11.2 Select\nA função select seleciona colunas específicas de um data frame. Para selecionar as colunas DepTime, ArrTime, e FlightNum:\n\nflights %&gt;% select(DepTime, ArrTime, FlightNum)\n\n# A tibble: 227,496 × 3\n   DepTime ArrTime FlightNum\n     &lt;int&gt;   &lt;int&gt;     &lt;int&gt;\n 1    1400    1500       428\n 2    1401    1501       428\n 3    1352    1502       428\n 4    1403    1513       428\n 5    1405    1507       428\n 6    1359    1503       428\n 7    1359    1509       428\n 8    1355    1454       428\n 9    1443    1554       428\n10    1443    1553       428\n# ℹ 227,486 more rows\n\n\nPara selecionar todas as colunas que contêm “Taxi” ou “Delay”:\n\nflights %&gt;% select(contains(\"Taxi\"), contains(\"Delay\"))\n\n# A tibble: 227,496 × 4\n   TaxiIn TaxiOut ArrDelay DepDelay\n    &lt;int&gt;   &lt;int&gt;    &lt;int&gt;    &lt;int&gt;\n 1      7      13      -10        0\n 2      6       9       -9        1\n 3      5      17       -8       -8\n 4      9      22        3        3\n 5      9       9       -3        5\n 6      6      13       -7       -1\n 7     12      15       -1       -1\n 8      7      12      -16       -5\n 9      8      22       44       43\n10      6      19       43       43\n# ℹ 227,486 more rows\n\n\n\n\n2.11.3 Arrange\nA função arrange ordena o data frame de acordo com algum critério. Para ordenar pelo atraso de partida (DepDelay):\n\nflights %&gt;% arrange(DepDelay)\n\n# A tibble: 227,496 × 21\n    Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum\n   &lt;int&gt; &lt;int&gt;      &lt;int&gt;     &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;chr&gt;             &lt;int&gt;\n 1  2011    12         24         6    1112    1314 OO                 5440\n 2  2011     2         14         1    1917    2027 MQ                 3328\n 3  2011     4         10         7    2101    2206 XE                 2669\n 4  2011     8          3         3    1741    1810 XE                 2603\n 5  2011     1         18         2    1542    1936 CO                 1688\n 6  2011    10          4         2    1438    1813 EV                 5412\n 7  2011     1         26         3    2248    2343 XE                 2450\n 8  2011     3          8         2     953    1156 CO                 1882\n 9  2011     3         18         5    2103    2156 XE                 2261\n10  2011     4          3         7    1048    1307 MQ                 3796\n# ℹ 227,486 more rows\n# ℹ 13 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;,\n#   ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;,\n#   TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;,\n#   Diverted &lt;int&gt;\n\n\nPara ordem decrescente:\n\nflights %&gt;% arrange(desc(DepDelay))\n\n# A tibble: 227,496 × 21\n    Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum\n   &lt;int&gt; &lt;int&gt;      &lt;int&gt;     &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;chr&gt;             &lt;int&gt;\n 1  2011     8          1         1     156     452 CO                    1\n 2  2011    12         12         1     650     808 AA                 1740\n 3  2011    11          8         2     721     948 MQ                 3786\n 4  2011     6         21         2    2334     124 UA                  855\n 5  2011     6          9         4    2029    2243 MQ                 3859\n 6  2011     5         20         5     858    1027 MQ                 3328\n 7  2011     1         20         4     635     807 CO                   59\n 8  2011     6         22         3     908    1040 CO                  595\n 9  2011    10         25         2    2310     149 DL                 1215\n10  2011    12         13         2     706     824 MQ                 3328\n# ℹ 227,486 more rows\n# ℹ 13 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;,\n#   ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;,\n#   TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;,\n#   Diverted &lt;int&gt;\n\n\n\n\n2.11.4 Mutate\nA função mutate cria novas variáveis. Para criar a variável Speed (velocidade) e adicioná-la ao banco:\n\nflights &lt;- flights %&gt;% mutate(Speed = Distance / AirTime * 60)\n\n\n\n2.11.5 Summarise e Group_by\nA função summarise calcula estatísticas resumo. Para calcular o atraso médio de chegada por destino:\n\nflights %&gt;% group_by(Dest) %&gt;% summarise(avg_delay = mean(ArrDelay, na.rm = TRUE))\n\n# A tibble: 116 × 2\n   Dest  avg_delay\n   &lt;chr&gt;     &lt;dbl&gt;\n 1 ABQ        7.23\n 2 AEX        5.84\n 3 AGS        4   \n 4 AMA        6.84\n 5 ANC       26.1 \n 6 ASE        6.79\n 7 ATL        8.23\n 8 AUS        7.45\n 9 AVL        9.97\n10 BFL      -13.2 \n# ℹ 106 more rows\n\n\nA função summarise_each aplica uma função a várias colunas ao mesmo tempo. Para calcular a média de Cancelled e Diverted por companhia aérea:\n\nflights %&gt;% group_by(UniqueCarrier) %&gt;% summarise_each(funs(mean), Cancelled, Diverted)\n\n# A tibble: 15 × 3\n   UniqueCarrier Cancelled Diverted\n   &lt;chr&gt;             &lt;dbl&gt;    &lt;dbl&gt;\n 1 AA              0.0185   0.00185\n 2 AS              0        0.00274\n 3 B6              0.0259   0.00576\n 4 CO              0.00678  0.00263\n 5 DL              0.0159   0.00303\n 6 EV              0.0345   0.00318\n 7 F9              0.00716  0      \n 8 FL              0.00982  0.00327\n 9 MQ              0.0290   0.00194\n10 OO              0.0139   0.00349\n11 UA              0.0164   0.00241\n12 US              0.0113   0.00147\n13 WN              0.0155   0.00229\n14 XE              0.0155   0.00345\n15 YV              0.0127   0      \n\n\nTambém podemos aplicar várias funções a uma mesma coluna:\n\nflights %&gt;% group_by(UniqueCarrier) %&gt;% summarise_each(funs(mean, var), Cancelled, Diverted)\n\n# A tibble: 15 × 5\n   UniqueCarrier Cancelled_mean Diverted_mean Cancelled_var Diverted_var\n   &lt;chr&gt;                  &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 AA                   0.0185        0.00185       0.0182       0.00185\n 2 AS                   0             0.00274       0            0.00274\n 3 B6                   0.0259        0.00576       0.0253       0.00573\n 4 CO                   0.00678       0.00263       0.00674      0.00262\n 5 DL                   0.0159        0.00303       0.0157       0.00302\n 6 EV                   0.0345        0.00318       0.0333       0.00317\n 7 F9                   0.00716       0             0.00712      0      \n 8 FL                   0.00982       0.00327       0.00973      0.00326\n 9 MQ                   0.0290        0.00194       0.0282       0.00193\n10 OO                   0.0139        0.00349       0.0138       0.00347\n11 UA                   0.0164        0.00241       0.0161       0.00241\n12 US                   0.0113        0.00147       0.0111       0.00147\n13 WN                   0.0155        0.00229       0.0153       0.00229\n14 XE                   0.0155        0.00345       0.0153       0.00344\n15 YV                   0.0127        0             0.0127       0      \n\n\nAlém disso, podemos usar o operador \".\" para aplicar funções com múltiplos argumentos:\n\nflights %&gt;% group_by(UniqueCarrier) %&gt;% summarise_each(funs(min(., na.rm = TRUE), max(., na.rm = TRUE)), matches(\"Delay\"))\n\n# A tibble: 15 × 5\n   UniqueCarrier ArrDelay_min DepDelay_min ArrDelay_max DepDelay_max\n   &lt;chr&gt;                &lt;int&gt;        &lt;int&gt;        &lt;int&gt;        &lt;int&gt;\n 1 AA                     -39          -15          978          970\n 2 AS                     -43          -15          183          172\n 3 B6                     -44          -14          335          310\n 4 CO                     -55          -18          957          981\n 5 DL                     -32          -17          701          730\n 6 EV                     -40          -18          469          479\n 7 F9                     -24          -15          277          275\n 8 FL                     -30          -14          500          507\n 9 MQ                     -38          -23          918          931\n10 OO                     -57          -33          380          360\n11 UA                     -47          -11          861          869\n12 US                     -42          -17          433          425\n13 WN                     -44          -10          499          548\n14 XE                     -70          -19          634          628\n15 YV                     -32          -11           72           54\n\n\nPor fim, podemos realizar agrupamentos múltiplos:\n\nflights %&gt;% group_by(UniqueCarrier, DayOfWeek) %&gt;% summarise_each(funs(min(., na.rm = TRUE), max(., na.rm = TRUE)), matches(\"Delay\"))\n\n# A tibble: 105 × 6\n# Groups:   UniqueCarrier [15]\n   UniqueCarrier DayOfWeek ArrDelay_min DepDelay_min ArrDelay_max DepDelay_max\n   &lt;chr&gt;             &lt;int&gt;        &lt;int&gt;        &lt;int&gt;        &lt;int&gt;        &lt;int&gt;\n 1 AA                    1          -30          -14          978          970\n 2 AA                    2          -30          -12          265          286\n 3 AA                    3          -33          -15          179          168\n 4 AA                    4          -38          -15          663          653\n 5 AA                    5          -28          -13          255          234\n 6 AA                    6          -39          -13          685          677\n 7 AA                    7          -34          -15          507          525\n 8 AS                    1          -30          -12          183          172\n 9 AS                    2          -34          -12           92           68\n10 AS                    3          -29          -12          123          138\n# ℹ 95 more rows\n\n\nAqui está a seção sobre o pacote ggplot2 e tidyr atualizada, mantendo a clareza e estrutura para fins didáticos:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#o-pacote-ggplot2",
    "href": "0_R.html#o-pacote-ggplot2",
    "title": "2  Breve Introdução ao R",
    "section": "2.12 O pacote ggplot2",
    "text": "2.12 O pacote ggplot2\nNota: Esta seção foi adaptada de curso-r.com.\nO ggplot2 é um pacote do R voltado para a criação de gráficos estatísticos. Ele é baseado na Gramática dos Gráficos (Grammar of Graphics) de Leland Wilkinson. Segundo essa gramática, um gráfico estatístico é um mapeamento dos dados por meio de atributos estéticos (cores, formas, tamanho) de formas geométricas (pontos, linhas, barras).\n\nlibrary(ggplot2)\n\n\n2.12.1 Construindo gráficos\nVamos discutir os aspectos básicos para a construção de gráficos com o ggplot2, utilizando o conjunto de dados mtcars. Para visualizar as primeiras linhas:\n\nhead(mtcars)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n\n\n2.12.2 As camadas de um gráfico\nOs gráficos no ggplot2 são construídos camada por camada. A primeira camada é criada com a função ggplot. Um exemplo de gráfico simples:\n\nggplot(data = mtcars) +\n  geom_point(aes(x = disp, y = mpg))\n\n\n\n\n\n\n\n\nA função aes define o mapeamento entre as variáveis e os aspectos visuais. Neste caso, estamos criando um gráfico de dispersão (com geom_point) entre disp (cilindradas) e mpg (milhas por galão).\n\n\n2.12.3 Aesthetics\nPodemos mapear variáveis a diferentes aspectos estéticos, como cor e tamanho. Por exemplo, para mapear a variável am (transmissão) para a cor dos pontos:\n\nggplot(data = mtcars) +\n  geom_point(aes(x = disp, y = mpg, colour = as.factor(am)))\n\n\n\n\n\n\n\n\n\n\n2.12.4 Geoms\nOs geoms definem as formas geométricas usadas para a visualização dos dados. Além de geom_point, podemos usar:\n\ngeom_line para linhas\ngeom_boxplot para boxplots\ngeom_histogram para histogramas\n\nExemplo de um boxplot:\n\nggplot(mtcars) +\n  geom_boxplot(aes(x = as.factor(cyl), y = mpg))\n\n\n\n\n\n\n\n\n\n\n2.12.5 Personalizando os gráficos\n\n2.12.5.1 Cores\nPara mudar as cores do gráfico, podemos usar o argumento colour ou fill:\n\nggplot(mtcars) +\n  geom_boxplot(aes(x = as.factor(cyl), y = mpg, fill = as.factor(cyl)))\n\n\n\n\n\n\n\n\n\n\n2.12.5.2 Eixos\nPara alterar os rótulos dos eixos:\n\nggplot(mtcars) +\n  geom_histogram(aes(x = mpg)) +\n  xlab(\"Milhas por galão\") +\n  ylab(\"Frequência\")\n\n\n\n\n\n\n\n\n\n\n2.12.5.3 Legendas\nPodemos personalizar ou remover legendas facilmente:\n\nggplot(mtcars) +\n  geom_bar(aes(x = as.factor(cyl), fill = as.factor(cyl))) +\n  labs(fill = \"Cilindros\") +\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\n2.12.6 Facets\nO facet_grid permite dividir o gráfico em subgráficos com base em uma variável:\n\nggplot(mtcars) +\n  geom_point(aes(x = mpg, y = disp, colour = as.factor(cyl))) +\n  facet_grid(am ~ .)\n\n\n\n\n\n\n\n\n\n\n2.12.7 Temas\nPodemos mudar o tema de um gráfico com a função theme_set:\n\ntheme_set(theme_light(base_size = 10))\nggplot(mtcars) +\n  geom_point(aes(x = mpg, y = disp, colour = as.factor(cyl))) +\n  facet_grid(. ~ am)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#o-pacote-tidyr",
    "href": "0_R.html#o-pacote-tidyr",
    "title": "2  Breve Introdução ao R",
    "section": "2.13 O pacote tidyr",
    "text": "2.13 O pacote tidyr\nO pacote tidyr facilita a transformação e organização de dados no R. Para converter os dados de formato “wide” (largo) para “long” (longo), podemos utilizar a função pivot_longer, que substitui a antiga função gather. Considere os dados a seguir:\n\ndados.originais &lt;- data.frame(\n  paciente = c(\"João\", \"Marcos\", \"Antonio\"),\n  pressao.antes = c(67, 80, 64),\n  pressao.durante = c(54, 70, 60),\n  pressao.depois = c(56, 90, 50)\n)\ndados.originais\n\n  paciente pressao.antes pressao.durante pressao.depois\n1     João            67              54             56\n2   Marcos            80              70             90\n3  Antonio            64              60             50\n\n\nPara reorganizar esses dados em um formato “long”, usando pivot_longer:\n\nlibrary(tidyr)\ndados.novo.formato &lt;- dados.originais %&gt;%\n  pivot_longer(cols = pressao.antes:pressao.depois,\n               names_to = \"instante\",\n               values_to = \"pressao.arterial\")\ndados.novo.formato\n\n# A tibble: 9 × 3\n  paciente instante        pressao.arterial\n  &lt;chr&gt;    &lt;chr&gt;                      &lt;dbl&gt;\n1 João     pressao.antes                 67\n2 João     pressao.durante               54\n3 João     pressao.depois                56\n4 Marcos   pressao.antes                 80\n5 Marcos   pressao.durante               70\n6 Marcos   pressao.depois                90\n7 Antonio  pressao.antes                 64\n8 Antonio  pressao.durante               60\n9 Antonio  pressao.depois                50\n\n\nA função pivot_wider é usada para converter dados de formato “long” (longo) para “wide” (largo), espalhando uma variável por várias colunas. Vamos começar com um conjunto de dados em formato “long” e então reorganizá-los para o formato “wide”.\nConsidere o conjunto de dados dados.novo.formato que organizamos anteriormente:\n\ndados.novo.formato &lt;- data.frame(\n  paciente = c(\"João\", \"Marcos\", \"Antonio\", \"João\", \"Marcos\", \"Antonio\", \"João\", \"Marcos\", \"Antonio\"),\n  instante = c(\"pressao.antes\", \"pressao.antes\", \"pressao.antes\", \"pressao.durante\", \"pressao.durante\", \"pressao.durante\", \"pressao.depois\", \"pressao.depois\", \"pressao.depois\"),\n  pressao.arterial = c(67, 80, 64, 54, 70, 60, 56, 90, 50)\n)\ndados.novo.formato\n\n  paciente        instante pressao.arterial\n1     João   pressao.antes               67\n2   Marcos   pressao.antes               80\n3  Antonio   pressao.antes               64\n4     João pressao.durante               54\n5   Marcos pressao.durante               70\n6  Antonio pressao.durante               60\n7     João  pressao.depois               56\n8   Marcos  pressao.depois               90\n9  Antonio  pressao.depois               50\n\n\nAgora, vamos usar pivot_wider para transformar esses dados de volta ao formato “wide”:\n\ndados.wide &lt;- dados.novo.formato %&gt;%\n  pivot_wider(names_from = instante, values_from = pressao.arterial)\ndados.wide\n\n# A tibble: 3 × 4\n  paciente pressao.antes pressao.durante pressao.depois\n  &lt;chr&gt;            &lt;dbl&gt;           &lt;dbl&gt;          &lt;dbl&gt;\n1 João                67              54             56\n2 Marcos              80              70             90\n3 Antonio             64              60             50\n\n\nTemos os seguintes argumentos: - names_from especifica a coluna cujos valores serão usados para criar novos nomes de colunas (neste caso, a variável instante). - values_from especifica a coluna cujos valores serão preenchidos nas novas colunas criadas (neste caso, a variável pressao.arterial).\nAqui está um exemplo de como o pacote tidyr pode ser usado para manipular os dados antes de visualizá-los com gráficos no ggplot2.\n\n2.13.1 Exemplo: Manipulação e Visualização com pivot_longer e ggplot2\nO pacote tidyr é particularmente últil dentro do ggplot2. Vamos continuar com o exemplo dos dados de pressão arterial. Suponha que você queira visualizar as variações da pressão arterial dos pacientes em diferentes instantes.\nPrimeiro, vamos reorganizar os dados usando pivot_longer para colocar os dados no formato “long”, que é mais adequado para gráficos com o ggplot2:\n\nlibrary(tidyr)\nlibrary(ggplot2)\n\n# Dados originais no formato \"wide\"\ndados.originais &lt;- data.frame(\n  paciente = c(\"João\", \"Marcos\", \"Antonio\"),\n  pressao.antes = c(67, 80, 64),\n  pressao.durante = c(54, 70, 60),\n  pressao.depois = c(56, 90, 50)\n)\ndados.originais\n\n  paciente pressao.antes pressao.durante pressao.depois\n1     João            67              54             56\n2   Marcos            80              70             90\n3  Antonio            64              60             50\n\n\nPara usá-los no ggplot, vamos os reorganizar no formato “long”:\n\ndados.long &lt;- dados.originais %&gt;%\n  pivot_longer(cols = pressao.antes:pressao.depois,\n               names_to = \"instante\",\n               values_to = \"pressao.arterial\")\ndados.long\n\n# A tibble: 9 × 3\n  paciente instante        pressao.arterial\n  &lt;chr&gt;    &lt;chr&gt;                      &lt;dbl&gt;\n1 João     pressao.antes                 67\n2 João     pressao.durante               54\n3 João     pressao.depois                56\n4 Marcos   pressao.antes                 80\n5 Marcos   pressao.durante               70\n6 Marcos   pressao.depois                90\n7 Antonio  pressao.antes                 64\n8 Antonio  pressao.durante               60\n9 Antonio  pressao.depois                50\n\n\nAgora, vamos criar um gráfico de linhas que mostra as mudanças na pressão arterial ao longo do tempo para cada paciente. Note que estamos reordenando o eixo x para levar em conta o carater temporal do problema.\n\nggplot(dados.long, aes(x = factor(instante, levels = c(\"pressao.antes\", \"pressao.durante\", \"pressao.depois\")),\n                       y = pressao.arterial, group = paciente, color = paciente)) +\n  geom_line(size = 1) +\n  geom_point(size = 3) +\n  labs(title = \"Variação da Pressão Arterial dos Pacientes\",\n       x = \"Instante\",\n       y = \"Pressão Arterial\") +\n  theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#leitura-de-arquivos-com-readr",
    "href": "0_R.html#leitura-de-arquivos-com-readr",
    "title": "2  Breve Introdução ao R",
    "section": "2.14 Leitura de Arquivos com readr",
    "text": "2.14 Leitura de Arquivos com readr\nO readr é um pacote eficiente para leitura de arquivos de dados no R. Vamos explorar como utilizar o readr para ler e manipular arquivos CSV. Um arquivo CSV (Comma-Separated Values) é um formato comum para armazenar dados tabulares.\nPara começar, carregue o pacote readr:\n\nlibrary(readr)\n\n\n2.14.1 Exemplo: Leitura de um CSV com Dados Públicos\nVamos usar um banco de dados público disponível na internet. Um exemplo muito comum é o conjunto de dados de passageiros do Titanic, disponível em formato CSV. Para carregar diretamente da internet:\n\nurl &lt;- \"https://raw.githubusercontent.com/datasciencedojo/datasets/master/titanic.csv\"\ndados_titanic &lt;- read_csv(url)\n\nAqui, estamos carregando os dados diretamente de um link. Após a leitura, podemos visualizar os primeiros registros:\n\nhead(dados_titanic)\n\n# A tibble: 6 × 12\n  PassengerId Survived Pclass Name    Sex     Age SibSp Parch Ticket  Fare Cabin\n        &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;\n1           1        0      3 Braund… male     22     1     0 A/5 2…  7.25 &lt;NA&gt; \n2           2        1      1 Cuming… fema…    38     1     0 PC 17… 71.3  C85  \n3           3        1      3 Heikki… fema…    26     0     0 STON/…  7.92 &lt;NA&gt; \n4           4        1      1 Futrel… fema…    35     1     0 113803 53.1  C123 \n5           5        0      3 Allen,… male     35     0     0 373450  8.05 &lt;NA&gt; \n6           6        0      3 Moran,… male     NA     0     0 330877  8.46 &lt;NA&gt; \n# ℹ 1 more variable: Embarked &lt;chr&gt;\n\n\n\n\n2.14.2 Manipulando os Dados Lidos\nO read_csv detecta automaticamente os tipos de dados de cada coluna. No exemplo dos dados do Titanic, podemos realizar algumas análises rápidas, como visualizar a distribuição de sobreviventes:\n\ntable(dados_titanic$Survived)\n\n\n  0   1 \n549 342 \n\n\n\n\n2.14.3 Salvando o Conjunto de Dados\nSe você quiser salvar o conjunto de dados em seu computador após manipulações, basta usar o write_csv:\n\nwrite_csv(dados_titanic, \"titanic_local.csv\")\n\nAqui está o conjunto de exercícios no formato solicitado:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#exercícios",
    "href": "0_R.html#exercícios",
    "title": "2  Breve Introdução ao R",
    "section": "2.15 Exercícios",
    "text": "2.15 Exercícios\nExercício 1.\nExecute as seguintes operações no R e interprete os resultados: - \\(5 + 9\\) - \\(\\frac{0}{0}\\) - \\(10^{5}\\)\nUtilize a função log para calcular o logaritmo natural de 10 e depois o logaritmo na base 10 de 1000.\nDescubra a função que calcula a raiz quadrada de um número utilizando o símbolo de interrogação (?), e aplique-a ao número 144.\nExercício 2.\nArmazene o resultado de \\(15 \\times 7\\) em uma variável chamada resultado. Use resultado para calcular o valor de \\(2 \\times resultado\\).\nListe todas as variáveis no ambiente do R usando a função ls(). Exclua a variável resultado e verifique novamente as variáveis presentes.\nExercício 3.\nCrie um vetor v contendo os números 4, 8, 15, 16, 23, 42. Use subsetting para selecionar: - O segundo e o quarto elemento. - Todos os elementos exceto o terceiro. - Os elementos que são maiores que 10.\nMultiplique cada elemento do vetor v por 2 e armazene o resultado em um novo vetor v2.\nExercício 4.\nVerifique se 8 é maior que 5 e se 8 é igual a 10.\nCrie dois vetores lógicos a = c(TRUE, FALSE, TRUE) e b = c(FALSE, TRUE, FALSE). Aplique os operadores &, | e xor() nesses vetores.\nExercício 5.\nEscreva uma função soma_quadrados que receba dois números como argumentos e retorne a soma de seus quadrados. Teste sua função com os números 3 e 4.\nModifique a função soma_quadrados para que o segundo argumento tenha um valor padrão de 2. Teste a função chamando-a com apenas um argumento.\nExercício 6.\nEscreva um laço for que calcule a soma dos números de 1 a 100.\nCrie um laço while que multiplique os números de 1 a 6 e retorne o resultado.\nExercício 7.\nCrie duas variáveis com o seu primeiro e último nome. Use a função paste() para juntar as duas variáveis em uma frase que diga “Meu nome completo é [nome completo]”.\nAltere o separador na função paste() para um traço - e junte novamente as variáveis.\nExercício 8.\nCarregue o pacote dplyr e use o dataset mtcars. Selecione apenas as colunas mpg, cyl, e hp.\nFiltre as observações onde mpg é maior que 20 e hp é menor que 150.\nOrdene o dataset filtrado pela coluna mpg em ordem decrescente.\nExercício 9.\nUsando o dataset mtcars, crie um gráfico de dispersão (geom_point) que mostre a relação entre hp (horsepower) e mpg (milhas por galão).\nNo gráfico anterior, mapeie a variável cyl para a cor dos pontos.\nExercício 10. Utilize a base pública de dados de voos da nycflights13 para responder às perguntas abaixo.\n\nCarregue o pacote nycflights13 e explore o dataset flights. Visualize as primeiras 6 linhas da base.\nFiltre todos os voos que decolaram no mês de junho e aterrissaram com atraso maior que 1 hora.\nAgrupe os dados por companhia aérea (carrier) e calcule o atraso médio de chegada (arr_delay) para cada companhia.\nCrie um gráfico de barras que mostre o atraso médio de chegada por companhia aérea.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "1_intro.html",
    "href": "1_intro.html",
    "title": "3  Geração de Números Aleatórios e Aplicação em Estatística",
    "section": "",
    "text": "3.1 Objetivo da Aula\nNesta aula, vamos introduzir o conceito de números pseudoaleatórios e como eles podem ser usados para resolver problemas estatísticos por meio de simulação. Vamos abordar a importância da aleatoriedade em estatísticas e em algoritmos de Monte Carlo.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Estatística</span>"
    ]
  },
  {
    "objectID": "1_intro.html#conteúdo-teórico",
    "href": "1_intro.html#conteúdo-teórico",
    "title": "3  Geração de Números Aleatórios e Aplicação em Estatística",
    "section": "3.2 Conteúdo Teórico",
    "text": "3.2 Conteúdo Teórico\nA geração de números aleatórios é essencial em várias áreas da estatística e da ciência de dados. Esses números são utilizados em simulações estocásticas, amostragem e para resolver problemas que envolvem incerteza. Contudo, em computadores, os números “aleatórios” gerados são na verdade pseudoaleatórios, pois seguem uma sequência previsível, gerada por um algoritmo determinístico.\nOs números pseudoaleatórios são amplamente usados em algoritmos de Monte Carlo, que dependem da simulação repetida de processos aleatórios para estimar soluções para problemas matemáticos e estatísticos.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Estatística</span>"
    ]
  },
  {
    "objectID": "1_intro.html#exemplo-de-problema",
    "href": "1_intro.html#exemplo-de-problema",
    "title": "3  Geração de Números Aleatórios e Aplicação em Estatística",
    "section": "3.3 Exemplo de Problema",
    "text": "3.3 Exemplo de Problema\nVamos resolver o problema de estimar o valor de π (Pi) usando um método de Monte Carlo. A ideia é simular a área de um quarto de círculo inscrito em um quadrado. Gerando pontos aleatórios dentro do quadrado, podemos calcular a proporção desses pontos que também caem dentro do círculo e usar essa proporção para estimar o valor de Pi.\nComo fazer isso?\n\nRPython\n\n\n\n\nMostrar código\n# Definindo o número de pontos a serem gerados\nn_pontos &lt;- 1000\n\n# Gerando pontos aleatórios (x, y) no intervalo [0, 1]\nx &lt;- runif(n_pontos, 0, 1)\ny &lt;- runif(n_pontos, 0, 1)\n\n# Calculando a distância de cada ponto à origem\ndistancia &lt;- sqrt(x^2 + y^2)\n\n# Contando quantos pontos estão dentro do quarto de círculo (distância &lt;= 1)\ndentro_circulo &lt;- distancia &lt;= 1\npi_estimado &lt;- 4 * sum(dentro_circulo) / n_pontos\n\n# Exibindo o valor estimado de Pi\ncat(\"Valor estimado de π:\", pi_estimado, \"\\n\")\n\n\nValor estimado de π: 3.124 \n\n\nMostrar código\n# Visualizando a distribuição dos pontos\nlibrary(ggplot2)\n\ndados &lt;- data.frame(x = x, y = y, dentro_circulo = dentro_circulo)\n\nggplot(dados, aes(x = x, y = y, color = dentro_circulo)) +\n  geom_point(size = 1) +\n  scale_color_manual(values = c(\"red\", \"blue\")) +\n  ggtitle(paste0(\"Estimativa de π usando Monte Carlo\\nValor estimado: \", round(pi_estimado, 5))) +\n  theme_minimal() +\n  coord_equal() +\n  labs(x = \"x\", y = \"y\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo o número de pontos a serem gerados\nn_pontos = 1000\n\n# Gerando pontos aleatórios (x, y) no intervalo [0, 1]\nx = np.random.uniform(0, 1, n_pontos)\ny = np.random.uniform(0, 1, n_pontos)\n\n# Calculando a distância de cada ponto à origem\ndistancia = np.sqrt(x**2 + y**2)\n\n# Contando quantos pontos estão dentro do quarto de círculo (distância &lt;= 1)\ndentro_circulo = distancia &lt;= 1\npi_estimado = 4 * np.sum(dentro_circulo) / n_pontos\n\n# Exibindo o valor estimado de Pi\nprint(f\"Valor estimado de π: {pi_estimado}\")\n\n\nValor estimado de π: 3.216\n\n\nMostrar código\n# Visualizando a distribuição dos pontos\nplt.figure(figsize=(6,6))\nplt.scatter(x, y, c=dentro_circulo, cmap='coolwarm', s=1)\nplt.title(f'Estimativa de π usando Monte Carlo\\nValor estimado: {pi_estimado}')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Estatística</span>"
    ]
  },
  {
    "objectID": "1_intro.html#exemplo-simulação-de-um-jogo-de-dados-com-dado-viciado",
    "href": "1_intro.html#exemplo-simulação-de-um-jogo-de-dados-com-dado-viciado",
    "title": "3  Geração de Números Aleatórios e Aplicação em Estatística",
    "section": "3.4 Exemplo: Simulação de um Jogo de Dados com Dado “Viciado”",
    "text": "3.4 Exemplo: Simulação de um Jogo de Dados com Dado “Viciado”\nImagine que estamos jogando um jogo em que o dado é “viciado” e não segue uma distribuição uniforme, ou seja, alguns números têm uma chance maior de serem sorteados. Por exemplo, o número 6 pode ter uma probabilidade maior, e os outros números, menores.\nIsso nos permite mostrar como alterar a probabilidade de ocorrência de eventos em uma distribuição discreta.\n\nRPython\n\n\n\n\nMostrar código\n# Definindo as faces do dado e as probabilidades\nfaces &lt;- 1:6\nprobabilidades &lt;- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.25)  # Probabilidades associadas às faces do dado\n\n# Verificando que a soma das probabilidades é 1\ncat(\"Soma das probabilidades:\", sum(probabilidades), \"\\n\")\n\n\nSoma das probabilidades: 1 \n\n\nMostrar código\n# Simulando 10000 lançamentos de um dado viciado\nn_lancamentos &lt;- 10000\nset.seed(123)  # Definindo seed para reprodutibilidade\nresultados &lt;- sample(faces, size = n_lancamentos, replace = TRUE, prob = probabilidades)\n\n# Contando as frequências de cada face\nfrequencias &lt;- table(resultados) / n_lancamentos\n\n# Exibindo os resultados da simulação\ncat(\"Frequências de cada face após\", n_lancamentos, \"lançamentos:\\n\")\n\n\nFrequências de cada face após 10000 lançamentos:\n\n\nMostrar código\nfor (face in faces) {\n  cat(\"Face\", face, \":\", frequencias[as.character(face)], \"vezes\\n\")\n}\n\n\nFace 1 : 0.0473 vezes\nFace 2 : 0.0975 vezes\nFace 3 : 0.1504 vezes\nFace 4 : 0.1991 vezes\nFace 5 : 0.2582 vezes\nFace 6 : 0.2475 vezes\n\n\nMostrar código\n# Visualizando os resultados em um gráfico de barras\nlibrary(ggplot2)\n\ndados &lt;- data.frame(faces = as.factor(faces), frequencias = as.numeric(frequencias))\n\nggplot(dados, aes(x = faces, y = frequencias)) +\n  geom_bar(stat = \"identity\", fill = \"lightcoral\", color = \"black\") +\n  ggtitle(paste0(\"Simulação de Lançamentos de um Dado Viciado\\n\", n_lancamentos, \" lançamentos\")) +\n  xlab(\"Face do Dado\") +\n  ylab(\"Frequência de Ocorrência\") +\n  theme_minimal() +\n  geom_text(aes(label = round(frequencias, 4)), vjust = -0.5) +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo as faces do dado e as probabilidades\nfaces = [1, 2, 3, 4, 5, 6]\nprobabilidades = [0.05, 0.1, 0.15, 0.2, 0.25, 0.25]  # Probabilidades associadas às faces do dado\n\n# Verificando que a soma das probabilidades é 1\nprint(f\"Soma das probabilidades: {sum(probabilidades)}\")\n\n\nSoma das probabilidades: 1.0\n\n\nMostrar código\n# Simulando 10000 lançamentos de um dado viciado\nn_lancamentos = 10000\nresultados = np.random.choice(faces, size=n_lancamentos, p=probabilidades)\n\n# Contando as frequências de cada face\nfrequencias = [np.sum(resultados == face) / n_lancamentos for face in faces]\n\n# Exibindo os resultados da simulação\nprint(f\"Frequências de cada face após {n_lancamentos} lançamentos:\")\n\n\nFrequências de cada face após 10000 lançamentos:\n\n\nMostrar código\nfor face, freq in zip(faces, frequencias):\n    print(f\"Face {face}: {freq} vezes\")\n\n\nFace 1: 0.0512 vezes\nFace 2: 0.0981 vezes\nFace 3: 0.1496 vezes\nFace 4: 0.2055 vezes\nFace 5: 0.2548 vezes\nFace 6: 0.2408 vezes\n\n\nMostrar código\n# Visualizando os resultados em um gráfico de barras\nplt.figure(figsize=(8,6))\nplt.bar(faces, frequencias, color='lightcoral', edgecolor='black')\nplt.title(f'Simulação de Lançamentos de um Dado Viciado\\n{n_lancamentos} lançamentos')\nplt.xlabel('Face do Dado')\nplt.ylabel('Frequência de Ocorrência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Estatística</span>"
    ]
  },
  {
    "objectID": "1_intro.html#conseguimos-repetir-o-experimento-anterior-utilizando-apenas-uma-uniforme",
    "href": "1_intro.html#conseguimos-repetir-o-experimento-anterior-utilizando-apenas-uma-uniforme",
    "title": "3  Geração de Números Aleatórios e Aplicação em Estatística",
    "section": "3.5 Conseguimos repetir o experimento anterior utilizando apenas uma uniforme?",
    "text": "3.5 Conseguimos repetir o experimento anterior utilizando apenas uma uniforme?\nPodemos utilizar uma única distribuição uniforme para simular o lançamento de um dado viciado. Ao dividir o intervalo [0, 1] em partes proporcionais às probabilidades das faces do dado, podemos mapear cada número aleatório gerado a uma das faces, de acordo com o intervalo no qual o número cai. Abaixo está um exemplo de como realizar essa simulação.\n\nRPython\n\n\n\n\nMostrar código\n# Definindo as faces do dado e as probabilidades associadas (não uniformes)\nfaces &lt;- 1:6\nprobabilidades &lt;- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.25)  # Probabilidades associadas às faces do dado\n\n# Função para gerar uma amostra baseada em intervalos de probabilidades\ngerar_amostra_por_intervalos &lt;- function(probabilidades, faces) {\n  u &lt;- runif(1)  # Gerando um número aleatório uniforme\n  limite_inferior &lt;- 0  # Limite inferior do intervalo\n  \n  # Percorrendo as probabilidades e verificando em qual intervalo o número cai\n  for (i in seq_along(probabilidades)) {\n    limite_superior &lt;- limite_inferior + probabilidades[i]  # Definindo o limite superior do intervalo\n    if (limite_inferior &lt;= u && u &lt; limite_superior) {\n      return(faces[i])  # Retorna a face correspondente ao intervalo\n    }\n    limite_inferior &lt;- limite_superior  # Atualiza o limite inferior para o próximo intervalo\n  }\n}\n\n# Simulando lançamentos do dado viciado utilizando a verificação dos intervalos\nn_lancamentos &lt;- 10000\nset.seed(123)  # Definindo seed para reprodutibilidade\nresultados &lt;- replicate(n_lancamentos, gerar_amostra_por_intervalos(probabilidades, faces))\n\n# Contando as frequências de cada face\nfrequencias &lt;- sapply(faces, function(face) sum(resultados == face) / n_lancamentos)\n\n# Exibindo os resultados da simulação\ncat(\"Frequências de cada face após\", n_lancamentos, \"lançamentos:\\n\")\n\n\nFrequências de cada face após 10000 lançamentos:\n\n\nMostrar código\nfor (i in seq_along(faces)) {\n  cat(\"Face\", faces[i], \":\", frequencias[i], \"vezes\\n\")\n}\n\n\nFace 1 : 0.0521 vezes\nFace 2 : 0.0964 vezes\nFace 3 : 0.1527 vezes\nFace 4 : 0.2045 vezes\nFace 5 : 0.2508 vezes\nFace 6 : 0.2435 vezes\n\n\nMostrar código\n# Visualizando os resultados em gráficos\n\nlibrary(ggplot2)\n\n# Gráfico das probabilidades ajustadas\ndados_probabilidades &lt;- data.frame(faces = as.factor(faces), probabilidades = probabilidades)\nggplot(dados_probabilidades, aes(x = faces, y = probabilidades)) +\n  geom_bar(stat = \"identity\", fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Probabilidades Ajustadas para o Dado Viciado\") +\n  xlab(\"Face do Dado\") +\n  ylab(\"Probabilidade\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n\n\n\n\n\n\nMostrar código\n# Gráfico das frequências obtidas\ndados_frequencias &lt;- data.frame(faces = as.factor(faces), frequencias = frequencias)\nggplot(dados_frequencias, aes(x = faces, y = frequencias)) +\n  geom_bar(stat = \"identity\", fill = \"lightcoral\", color = \"black\") +\n  ggtitle(paste0(\"Simulação de Lançamentos de um Dado Viciado\\n\", n_lancamentos, \" lançamentos\")) +\n  xlab(\"Face do Dado\") +\n  ylab(\"Frequência de Ocorrência\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo as faces do dado e as probabilidades associadas (não uniformes)\nfaces = [1, 2, 3, 4, 5, 6]\nprobabilidades = [0.05, 0.1, 0.15, 0.2, 0.25, 0.25]  # Probabilidades associadas às faces do dado\n\n# Gerando um número aleatório e verificando em qual intervalo ele cai\ndef gerar_amostra_por_intervalos(probabilidades, faces):\n    u = np.random.uniform(0, 1)  # Gerando um número aleatório uniforme\n    limite_inferior = 0  # Limite inferior do intervalo\n    \n    # Percorrendo as probabilidades e verificando em qual intervalo o número cai\n    for i, p in enumerate(probabilidades):\n        limite_superior = limite_inferior + p  # Definindo o limite superior do intervalo\n        if limite_inferior &lt;= u &lt; limite_superior:\n            return faces[i]  # Retorna a face correspondente ao intervalo\n        limite_inferior = limite_superior  # Atualiza o limite inferior para o próximo intervalo\n\n# Simulando lançamentos do dado viciado utilizando a verificação dos intervalos\nn_lancamentos = 10000\nresultados = [gerar_amostra_por_intervalos(probabilidades, faces) for _ in range(n_lancamentos)]\n\n# Contando as frequências de cada face\nfrequencias = [np.sum(np.array(resultados) == face) / n_lancamentos for face in faces]\n\n# Exibindo os resultados da simulação\nprint(f\"Frequências de cada face após {n_lancamentos} lançamentos:\")\n\n\nFrequências de cada face após 10000 lançamentos:\n\n\nMostrar código\nfor face, freq in zip(faces, frequencias):\n    print(f\"Face {face}: {freq} vezes\")\n\n\nFace 1: 0.0494 vezes\nFace 2: 0.1011 vezes\nFace 3: 0.1529 vezes\nFace 4: 0.1991 vezes\nFace 5: 0.2504 vezes\nFace 6: 0.2471 vezes\n\n\nMostrar código\n# Gráfico das probabilidades ajustadas\nplt.figure(figsize=(8,6))\nplt.bar(faces, probabilidades, color='skyblue', edgecolor='black')\nplt.title('Probabilidades Ajustadas para o Dado Viciado')\nplt.xlabel('Face do Dado')\nplt.ylabel('Probabilidade')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nMostrar código\n# Gráfico das frequências obtidas\nplt.figure(figsize=(8,6))\nplt.bar(faces, frequencias, color='lightcoral', edgecolor='black')\nplt.title(f'Simulação de Lançamentos de um Dado Viciado\\n{n_lancamentos} lançamentos')\nplt.xlabel('Face do Dado')\nplt.ylabel('Frequência de Ocorrência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nOu seja, se conseguimos simular uma distribuição uniforme, conseguimos simular uma distribuição discreta. Isso vale de forma mais geral?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Estatística</span>"
    ]
  },
  {
    "objectID": "1_intro.html#importância-da-geração-de-números-aleatórios-em-algoritmos-de-machine-learning",
    "href": "1_intro.html#importância-da-geração-de-números-aleatórios-em-algoritmos-de-machine-learning",
    "title": "3  Geração de Números Aleatórios e Aplicação em Estatística",
    "section": "3.6 Importância da Geração de Números Aleatórios em Algoritmos de Machine Learning",
    "text": "3.6 Importância da Geração de Números Aleatórios em Algoritmos de Machine Learning\nA geração de números aleatórios também desempenha um papel crucial em vários algoritmos de Machine Learning. Muitos algoritmos utilizam aleatoriedade em diferentes etapas do processo de modelagem, como na inicialização de pesos, na amostragem de dados e na divisão de conjuntos de treino e teste. Esses elementos aleatórios influenciam diretamente o desempenho e os resultados dos modelos.\n\n3.6.1 Exemplo: Algoritmo de Random Forest\nO Random Forest é um algoritmo de aprendizado supervisionado que utiliza números aleatórios em várias etapas do processo. Ele consiste em construir múltiplas árvores de decisão de forma aleatória, e cada árvore é gerada a partir de um subconjunto aleatório de dados de treino e de variáveis (features). A aleatoriedade ajuda a reduzir o overfitting e a melhorar a robustez do modelo.\nAbaixo está um exemplo de como o Random Forest utiliza aleatoriedade na escolha dos subconjuntos de dados:\n\nRPython\n\n\n\n\nMostrar código\n# Carregando o dataset Iris e definindo as variáveis preditoras e resposta\ndata(iris)\nX &lt;- iris[, 1:4]\ny &lt;- iris[, 5]\n\n# Dividindo os dados de forma aleatória em treino e teste\nset.seed(42)\nindex &lt;- sample(1:nrow(iris), 0.7 * nrow(iris))\nX_train &lt;- X[index, ]\nX_test &lt;- X[-index, ]\ny_train &lt;- y[index]\ny_test &lt;- y[-index]\n\n# Treinando o modelo Random Forest\nlibrary(randomForest)\nmodelo &lt;- randomForest(X_train, as.factor(y_train), ntree=100, seed=42)\n\n# Avaliando o modelo no conjunto de teste\npredicoes &lt;- predict(modelo, X_test)\naccuracy &lt;- sum(predicoes == y_test) / length(y_test)\ncat(\"Acurácia do modelo:\", accuracy, \"\\n\")\n\n\nAcurácia do modelo: 0.9555556 \n\n\n\n\n\n\nMostrar código\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\n\n# Carregando o dataset Iris\niris = load_iris()\nX = iris.data\ny = iris.target\n\n# Dividindo os dados de forma aleatória em treino e teste\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n\n# Treinando o modelo Random Forest\nclf = RandomForestClassifier(n_estimators=100, random_state=42)\nclf.fit(X_train, y_train)\n\n\nRandomForestClassifier(random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.  RandomForestClassifier?Documentation for RandomForestClassifieriFittedRandomForestClassifier(random_state=42) \n\n\nMostrar código\n# Avaliando o modelo no conjunto de teste\naccuracy = clf.score(X_test, y_test)\nprint(f\"Acurácia do modelo: {accuracy:.2f}\")\n\n\nAcurácia do modelo: 1.00",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Estatística</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html",
    "href": "2_pseudorandom.html",
    "title": "4  Números Pseudoaleatórios",
    "section": "",
    "text": "4.1 O que é um número pseudoaleatório?\nUm número pseudoaleatório é gerado a partir de uma fórmula matemática que, a partir de uma semente (um valor inicial), gera uma sequência de números que tem as propriedades desejadas de uma sequência aleatória. Essa sequência parece aleatória, mas se a mesma semente for usada, a sequência será a mesma.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html#geração-de-números-pseudoaleatórios-com-o-gerador-linear-congruente-lcg",
    "href": "2_pseudorandom.html#geração-de-números-pseudoaleatórios-com-o-gerador-linear-congruente-lcg",
    "title": "4  Números Pseudoaleatórios",
    "section": "4.2 Geração de Números Pseudoaleatórios com o Gerador Linear Congruente (LCG)",
    "text": "4.2 Geração de Números Pseudoaleatórios com o Gerador Linear Congruente (LCG)\nLink para o wikipedia\nO Gerador Linear Congruente (LCG) é um dos métodos mais antigos e simples para gerar números pseudoaleatórios. Ele segue a fórmula:\n\\[\nX_{n+1} = (a \\cdot X_n + c) \\mod m\n\\]\nOnde: - \\(X_n\\) é o número atual (ou a semente inicial), - \\(a\\) é o multiplicador, - \\(c\\) é o incremento, - \\(m\\) é o módulo, ou seja, o intervalo dos números gerados.\nA sequência gerada pelo LCG depende diretamente dos parâmetros \\(a\\), \\(c\\), \\(m\\) e da semente inicial \\(X_0\\). Um conjunto mal escolhido de parâmetros pode resultar em uma sequência com um período curto, o que compromete a aleatoriedade da sequência.\n\n4.2.1 O que é a Função Módulo?\nA função módulo (também conhecida como operação de resto) retorna o resto da divisão de um número por outro. Em termos matemáticos, para dois números inteiros \\(a\\) e \\(b\\), a operação módulo é representada como:\n\\[\nr = a \\mod b\n\\]\nOnde: - \\(a\\) é o dividendo, - \\(b\\) é o divisor, - \\(r\\) é o resto da divisão de \\(a\\) por \\(b\\).\nPor exemplo, se temos \\(a = 17\\) e \\(b = 5\\), a divisão de 17 por 5 dá 3 com um resto de 2, então:\n\\[\n17 \\mod 5 = 2\n\\]\nNo contexto do Gerador Linear Congruente (LCG), a função módulo é usada para garantir que os números gerados fiquem dentro de um intervalo específico, geralmente entre 0 e \\(m-1\\), onde \\(m\\) é o módulo definido no algoritmo.\n\nRPython\n\n\n\n\nMostrar código\n# Exemplo de uso da função módulo em R\n\n# Definindo os valores\na &lt;- 17\nb &lt;- 3\n\n# Calculando o módulo de a por b\nresto &lt;- a %% b\n\n# Exibindo o resultado\ncat(\"O resultado de\", a, \"%%\", b, \"é:\", resto, \"\\n\")\n\n\nO resultado de 17 %% 3 é: 2 \n\n\n\n\n\n\nMostrar código\n# Exemplo de uso da função módulo em Python\n\n# Definindo os valores\na = 17\nb = 3\n\n# Calculando o módulo de a por b\nresto = a % b\n\n# Exibindo o resultado\nprint(f\"O resultado de {a} % {b} é: {resto}\")\n\n\nO resultado de 17 % 3 é: 2",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html#por-que-o-gerador-linear-congruente-funciona",
    "href": "2_pseudorandom.html#por-que-o-gerador-linear-congruente-funciona",
    "title": "4  Números Pseudoaleatórios",
    "section": "4.3 Por que o Gerador Linear Congruente Funciona?",
    "text": "4.3 Por que o Gerador Linear Congruente Funciona?\nO Gerador Linear Congruente (LCG) é um dos métodos mais simples e eficientes para gerar números pseudoaleatórios. Sua eficácia se baseia em um bom equilíbrio entre a escolha dos parâmetros (multiplicador \\(a\\), incremento \\(c\\), módulo \\(m\\) e semente inicial \\(X_0\\)) e as propriedades matemáticas que garantem uma sequência suficientemente “aleatória”. Para que o LCG funcione bem, os parâmetros precisam ser cuidadosamente selecionados para garantir que a sequência gerada tenha um período longo, seja bem distribuída e evite padrões repetitivos.\n\n4.3.1 A Fórmula do LCG\nA fórmula básica do LCG é:\n\\[\nX_{n+1} = (a \\cdot X_n + c) \\mod m\n\\]\nOnde: - \\(X_n\\) é o número gerado na \\(n\\)-ésima iteração, - \\(a\\) é o multiplicador, - \\(c\\) é o incremento, - \\(m\\) é o módulo, - \\(X_0\\) é a semente inicial.\nO número gerado em cada iteração é o resto da divisão de \\((a \\cdot X_n + c)\\) por \\(m\\). Essa operação garante que os números fiquem dentro do intervalo \\([0, m-1]\\). A normalização posterior geralmente transforma esses números em valores no intervalo \\([0, 1)\\).\n\n\n4.3.2 O Papel de \\(m\\)\nO valor de \\(m\\), conhecido como módulo, define o intervalo no qual os números gerados estarão contidos. Em muitos casos, \\(m\\) é escolhido como uma potência de 2 (por exemplo, \\(m = 2^{32}\\) ou \\(m = 2^{64}\\)) porque cálculos modulares com potências de 2 são mais rápidos em hardware.\nA escolha de \\(m\\) também influencia o período máximo da sequência. Se todos os parâmetros forem escolhidos corretamente, o LCG pode gerar uma sequência com o período máximo, que é \\(m\\). Isso significa que a sequência não repetirá nenhum número até que \\(m\\) números tenham sido gerados.\n\n\n4.3.3 O Papel de \\(a\\), \\(c\\) e a Condição de Coprimos\nPara garantir que o gerador tenha o período máximo (ou seja, \\(m\\) números diferentes antes de repetir a sequência), a escolha dos parâmetros \\(a\\) (multiplicador), \\(c\\) (incremento) e \\(m\\) (módulo) deve satisfazer as seguintes condições baseadas em teorias de números:\n\nO incremento \\(c\\) deve ser coprimo com \\(m\\):\n\nDois números são coprimos se o maior divisor comum deles for 1, ou seja, \\(\\text{gcd}(c, m) = 1\\). Isso garante que, ao somar \\(c\\), todos os possíveis valores de \\(X_n\\) possam ser atingidos antes de repetir a sequência.\nSe \\(c\\) não for coprimo com \\(m\\), a sequência gerada pode pular certos valores, resultando em um período mais curto do que o esperado.\n\nO valor de \\(a - 1\\) deve ser divisível por todos os fatores primos de \\(m\\):\n\nSe \\(m\\) é uma potência de 2 (por exemplo, \\(m = 2^k\\)), a escolha de \\(a\\) deve ser tal que \\((a - 1)\\) seja divisível por 2 para garantir que o período seja maximizado.\n\nSe \\(m\\) for divisível por 4, então \\((a - 1)\\) também deve ser divisível por 4:\n\nIsso é necessário para garantir que todos os resíduos modulares possíveis possam ser gerados, especialmente quando \\(m\\) é uma potência de 2.\n\n\n\n\n4.3.4 Exemplo de uma Escolha Correta de Parâmetros\nUm exemplo clássico de um bom conjunto de parâmetros é:\n\n\\(m = 2^{32}\\) (módulo com 32 bits),\n\\(a = 1664525\\) (multiplicador),\n\\(c = 1013904223\\) (incremento),\n\\(X_0 = 42\\) (semente inicial, que pode ser qualquer valor).\n\nEsses parâmetros foram escolhidos para garantir que o LCG tenha um longo período e uma boa distribuição dos números gerados. O módulo \\(m = 2^{32}\\) é uma potência de 2, o que torna as operações modulares mais rápidas, e os valores de \\(a\\) e \\(c\\) satisfazem as condições matemáticas para maximizar o período.\n\nRPython\n\n\n\n\nMostrar código\n# Importando o pacote necessário\nlibrary(gmp)\n\n# Parâmetros do exemplo\nm &lt;- 2^32\na &lt;- 1664525\nc &lt;- 1013904223\n\n# Verificando as condições\n# 1. O incremento c deve ser coprimo com m\ncoprimo_c_m &lt;- gcd(c, m) == 1\n\n# 2. a - 1 deve ser divisível por todos os fatores primos de m\na_menos_1 &lt;- a - 1\n\nprint(a_menos_1)\n\n\n[1] 1664524\n\n\nMostrar código\n# Verificando se a - 1 é divisível por 2 (único fator primo de m = 2^32)\ndivisivel_por_2 &lt;- (a_menos_1 %% 2 == 0)\n\n# 3. Se m for divisível por 4, a - 1 também deve ser divisível por 4\ndivisivel_por_4 &lt;- (a_menos_1 %% 4 == 0)\n\nlist(coprimo_c_m, divisivel_por_2, divisivel_por_4)\n\n\n[[1]]\n[1] TRUE\n\n[[2]]\n[1] TRUE\n\n[[3]]\n[1] TRUE\n\n\n\n\n\n\nMostrar código\nimport math\n\n# Parâmetros do exemplo\nm = 2**32\na = 1664525\nc = 1013904223\n\n# Verificando as condições\n# 1. O incremento c deve ser coprimo com m\ncoprimo_c_m = math.gcd(c, m) == 1\n\n# 2. a - 1 deve ser divisível por todos os fatores primos de m\na_menos_1 = a - 1\n\nprint(a_menos_1)\n\n\n1664524\n\n\nMostrar código\n# Verificando se a - 1 é divisível por 2 (único fator primo de m = 2^32)\ndivisivel_por_2 = (a_menos_1 % 2 == 0)\n\n# 3. Se m for divisível por 4, a - 1 também deve ser divisível por 4\ndivisivel_por_4 = (a_menos_1 % 4 == 0)\n\ncoprimo_c_m, divisivel_por_2, divisivel_por_4\n\n\n(True, True, True)\n\n\n\n\n\n\n\n4.3.5 Por que o LCG Funciona Bem?\nO LCG funciona porque: - As operações modulares garantem que os números gerados estejam dentro de um intervalo fixo e possam cobrir todo o espaço de possíveis valores de maneira ordenada. - A escolha adequada dos parâmetros garante que a sequência tenha um longo período (o maior possível dado \\(m\\)), evita padrões repetitivos e assegura que a sequência seja pseudoaleatória o suficiente para muitas aplicações, como simulações e métodos de Monte Carlo.\nNo entanto, o LCG pode não ser adequado para todas as aplicações, especialmente em criptografia, onde a previsibilidade é um problema. Para a maioria dos usos científicos e de simulação, ele ainda é uma escolha eficiente e simples.\n\n\n4.3.6 Efeito dos Parâmetros no Gerador Linear Congruente (LCG)\nOs parâmetros no Gerador Linear Congruente (LCG) têm um impacto significativo sobre a qualidade e as propriedades da sequência de números pseudoaleatórios gerados. Os parâmetros principais são:\n\nMultiplicador \\(a\\):\n\nEsse parâmetro é essencial para garantir que a sequência de números gerados tenha um bom período (o número de valores distintos antes de a sequência começar a se repetir). Se o valor de \\(a\\) não for bem escolhido, o período da sequência pode ser curto e a qualidade dos números gerados diminui.\nBons valores de \\(a\\) são cruciais para evitar padrões repetitivos ou ciclos curtos.\n\nIncremento \\(c\\):\n\nO incremento \\(c\\) adiciona um valor fixo à sequência e é um dos fatores que pode garantir que todos os valores no intervalo \\([0, m)\\) sejam atingidos em algum momento, desde que os outros parâmetros também sejam bem escolhidos.\nQuando \\(c = 0\\), o gerador é chamado de multiplicativo. Nessa forma, o LCG pode ter um comportamento menos uniforme.\n\nMódulo \\(m\\):\n\nO módulo define o intervalo dos números gerados. Comumente, \\(m\\) é escolhido como uma potência de 2 (por exemplo, \\(m = 2^{32}\\)) para facilitar os cálculos modulares em hardware e software.\nO valor de \\(m\\) também determina o período máximo da sequência de números. Com um módulo de \\(m\\), o período máximo teórico que o LCG pode ter é \\(m\\), mas isso depende da escolha correta dos parâmetros \\(a\\) e \\(c\\).\n\nSemente \\(X_0\\):\n\nA semente é o valor inicial de \\(X_0\\) usado pelo LCG para iniciar a sequência. Mudar a semente resultará em uma sequência diferente, mas com o mesmo período e comportamento determinado pelos outros parâmetros.\nA semente garante que o algoritmo possa ser reproduzido. Se dois programas utilizarem a mesma semente com os mesmos parâmetros, ambos produzirão a mesma sequência de números.\n\n\n\n\n4.3.7 Impacto dos Parâmetros:\n\nPeríodo da Sequência:\n\nO período é a quantidade de números gerados antes que a sequência comece a se repetir. Para obter o período máximo, os parâmetros \\(a\\), \\(c\\), \\(m\\) e a semente \\(X_0\\) precisam ser cuidadosamente escolhidos.\nSe os parâmetros não forem bons, o gerador pode produzir uma sequência com um ciclo muito curto ou, pior, um conjunto pequeno de valores.\n\nDistribuição dos Números:\n\nEmbora o LCG gere números no intervalo \\([0, 1)\\), o quão bem distribuídos esses números estão nesse intervalo depende dos parâmetros.\nParâmetros mal escolhidos podem causar uma distribuição não uniforme, onde certos intervalos terão mais números gerados que outros, levando a um comportamento indesejável.\n\nPadrões Repetitivos:\n\nSe os parâmetros forem mal escolhidos, podem surgir padrões repetitivos que comprometem a aleatoriedade dos números. Esses padrões tornam o LCG inadequado para algumas aplicações, como criptografia ou simulações que exigem alta qualidade de aleatoriedade.\n\n\nPor essas razões, a escolha dos parâmetros \\(a\\), \\(c\\), \\(m\\) e da semente \\(X_0\\) é crítica para garantir que o LCG produza números pseudoaleatórios de alta qualidade e com um período longo.\n\nRPython\n\n\n\n\nMostrar código\n# Carregando o pacote ggplot2\nlibrary(ggplot2)\n\n# Classe para o Gerador Congruente Linear\nLinearCongruentialGenerator &lt;- setRefClass(\n  \"LinearCongruentialGenerator\",\n  fields = list(a = \"numeric\", c = \"numeric\", m = \"numeric\", semente = \"numeric\"),\n  methods = list(\n    initialize = function(semente, a = 1103515245, c = 12345, m = 2^32) {\n      .self$a &lt;- a\n      .self$c &lt;- c\n      .self$m &lt;- m\n      .self$semente &lt;- semente\n    },\n    gerar = function() {\n      # Atualizando a semente\n      .self$semente &lt;- (.self$a * .self$semente + .self$c) %% .self$m\n      return(.self$semente / .self$m)  # Normalizando para [0, 1)\n    }\n  )\n)\n\n# Inicializando o gerador com uma semente\nlcg &lt;- LinearCongruentialGenerator$new(semente = 5)\n\n# Gerando 1000 números pseudoaleatórios\nnumeros_gerados &lt;- sapply(1:100000, function(x) lcg$gerar())\n\n# Convertendo para um data.frame\ndados &lt;- data.frame(numeros_gerados = numeros_gerados)\n\n# Plotando o histograma dos números gerados\nggplot(dados, aes(x = numeros_gerados)) +\n  geom_histogram(bins = 20, fill = 'skyblue', color = 'black') +\n  ggtitle('Histograma dos Números Pseudoaleatórios Gerados pelo LCG') +\n  xlab('Valor') +\n  ylab('Frequência') +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport matplotlib.pyplot as plt\n\nclass LinearCongruentialGenerator:\n    def __init__(self, semente, a=1103515245, c=12345, m=2**32):\n        self.a = a\n        self.c = c\n        self.m = m\n        self.semente = semente\n\n    def gerar(self):\n        # Atualizando a semente\n        self.semente = (self.a * self.semente + self.c) % self.m\n        return self.semente / self.m  # Normalizando para [0, 1)\n\n# Inicializando o gerador com uma semente\nlcg = LinearCongruentialGenerator(semente=5)\n\n# Gerando 1000 números pseudoaleatórios\nnumeros_gerados = [lcg.gerar() for _ in range(100000)]\n\n# Plotando o histograma dos números gerados\nplt.figure(figsize=(10, 6))\nplt.hist(numeros_gerados, bins=20, color='skyblue', edgecolor='black')\nplt.title('Histograma dos Números Pseudoaleatórios Gerados pelo LCG')\nplt.xlabel('Valor')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html#gerando-números-uniformes-com-uma-moeda",
    "href": "2_pseudorandom.html#gerando-números-uniformes-com-uma-moeda",
    "title": "4  Números Pseudoaleatórios",
    "section": "4.4 Gerando números uniformes com uma moeda",
    "text": "4.4 Gerando números uniformes com uma moeda\nEste código mostra como é possível gerar números uniformemente distribuídos no intervalo [0, 1] utilizando o lançamento de uma moeda justa. A ideia central baseia-se na expansão binária, onde cada lançamento da moeda representa um bit da representação binária do número. Ao somar \\(2^{-(i+1))}\\) para cada bit, construímos o número em base 2, garantindo uma distribuição uniforme. Isso ocorre porque cada bit tem uma probabilidade igual de ser 0 ou 1, criando uma sequência que cobre uniformemente o intervalo desejado.\n\nRPython\n\n\n\n\nMostrar código\n# Carregando pacotes necessários\nlibrary(ggplot2)\n\n# Função para simular o lançamento de uma moeda justa\nlancar_moeda &lt;- function() {\n  # Lançar moeda justa: 0 para coroa (K) e 1 para cara (C)\n  sample(c(0, 1), 1)\n}\n\n# Função para gerar um número uniformemente distribuído usando uma moeda\ngerar_numero_uniforme &lt;- function(n_bits = 32) {\n  numero &lt;- 0\n  for (i in 1:n_bits) {\n    bit &lt;- lancar_moeda()\n    # Atualizando o número, multiplicando pela base 2\n    numero &lt;- numero + bit * (2^-(i))\n  }\n  return(numero)\n}\n\n# Gerando 10000 números uniformemente distribuídos\nnumeros_uniformes &lt;- sapply(1:10000, function(x) gerar_numero_uniforme())\n \n# Convertendo para um data.frame\ndados &lt;- data.frame(numeros_uniformes = numeros_uniformes)\n\n# Plotando o histograma dos números gerados\nggplot(dados, aes(x = numeros_uniformes)) +\n  geom_histogram(bins = 20, fill = 'skyblue', color = 'black') +\n  ggtitle('Histograma de Números Uniformes Gerados Usando uma Moeda Justa') +\n  xlab('Valor') +\n  ylab('Frequência') +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport random\nimport matplotlib.pyplot as plt\n\n# Função para simular o lançamento de uma moeda justa\ndef lancar_moeda():\n    # Lançar moeda justa: 0 para coroa (K) e 1 para cara (C)\n    return random.choice([0, 1])\n\n# Função para gerar um número uniformemente distribuído usando uma moeda\ndef gerar_numero_uniforme(n_bits=32):\n    numero = 0\n    for i in range(n_bits):\n        bit = lancar_moeda()\n        # Atualizando o número, multiplicando pela base 2\n        numero += bit * (2 ** -(i + 1))  # Cada bit tem um peso de 2^-(posição)\n    return numero\n\n# Gerando 1000 números uniformemente distribuídos\nnumeros_uniformes = [gerar_numero_uniforme() for _ in range(10000)]\n\n# Plotando o histograma dos números gerados\nplt.figure(figsize=(10, 6))\nplt.hist(numeros_uniformes, bins=20, color='skyblue', edgecolor='black')\nplt.title('Histograma de Números Uniformes Gerados Usando uma Moeda Justa')\nplt.xlabel('Valor')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html",
    "href": "3_discrete_inversion.html",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "",
    "text": "5.1 Inversa da CDF\nO método da inversão recebe esse nome pois seu algoritmo também pode ser caracterizado pela função inversa da CDF. A inversa da CDF (função de distribuição acumulada), também conhecida como a função quantil ou função percentil, é definida da seguinte forma:\nDefinição: Seja \\(F(x)\\) a função de distribuição acumulada (CDF) de uma variável aleatória \\(X\\). A inversa da CDF, denotada por \\(F^{-1}(p)\\), é definida como:\n\\[\nF^{-1}(p) = \\inf \\{ x \\in \\mathbb{R} : F(x) \\geq p \\}, \\quad \\text{para } p \\in [0, 1]\n\\]\nEm palavras: - A inversa da CDF \\(F^{-1}(p)\\) mapeia um número \\(p\\), que representa uma probabilidade acumulada, de volta ao valor \\(x\\) correspondente da variável aleatória \\(X\\), tal que a probabilidade acumulada até \\(x\\) é igual a \\(p\\). - Isso significa que, se \\(p = F(x)\\), então \\(F^{-1}(p) = x\\).\nAssim, o menor valor \\(x_i\\) tal que \\(F(x_i) \\geq u\\) é justamente \\(F^{-1}(u)\\), de modo que o algoritmo pode ser escrito como",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#inversa-da-cdf",
    "href": "3_discrete_inversion.html#inversa-da-cdf",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "",
    "text": "Gerar um número aleatório \\(u \\in [0, 1)\\).\nRetornar \\(F^{-1}(u)\\).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-discretas-genéricas",
    "href": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-discretas-genéricas",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "5.2 Geração de Variáveis Aleatórias Discretas Genéricas",
    "text": "5.2 Geração de Variáveis Aleatórias Discretas Genéricas\nConsidere uma v.a. discreta \\(X\\) que assume valores em em \\(x_1,x_2,\\ldots\\). Dadas as probabilidades de cada um desses valores \\(p(x_i)\\), a CDF \\(F(x)\\) é definida como:\n\\[\nF(x_i) = \\sum_{j=1}^{i} p(x_j)\n\\]\nO algoritmo da inversão para gerar uma variável aleatória discreta genérica é:\n\nGerar um número aleatório \\(u \\in [0, 1)\\).\nEncontrar o menor valor \\(x_i\\) tal que \\(F(x_i) \\geq u\\).\nRetornar \\(x_i\\).\n\n\nRPython\n\n\n\n\nMostrar código\n# Exemplo de valores e probabilidades de uma variável aleatória discreta\nvalores &lt;- c(0, 1, 2, 3, 4, 5, 6)\nprobabilidades &lt;- c(0, 0.1, 0.2, 0.3, 0.25, 0.15, 0) \n\n# Calculando a CDF\ncdf &lt;- cumsum(probabilidades)\n\n# Gerando um número aleatório uniforme\nu &lt;- runif(1)\n\n# Encontrando o valor correspondente na CDF\nvalor_gerado &lt;- NA\nfor (i in seq_along(valores)) {\n  if (u &lt; cdf[i]) {\n    valor_gerado &lt;- valores[i]\n    break\n  }\n}\n\n# Ajustando o gráfico para corrigir a visualização da CDF e garantir que os valores estejam corretamente posicionados\nlibrary(ggplot2)\n\n# Criando um dataframe para os valores e CDF\ndf &lt;- data.frame(valores = valores, cdf = cdf)\n\n# Gráfico da CDF com número aleatório e valor gerado\nggplot(df, aes(x = valores, y = cdf)) +\n  geom_step(direction = \"hv\", color = \"blue\", size = 1.5) +\n  geom_hline(yintercept = u, color = \"red\", linetype = \"dashed\") +\n  geom_vline(xintercept = valor_gerado, color = \"green\", linetype = \"dashed\") +\n  labs(title = \"Técnica da Inversão para Geração de Variável Aleatória Discreta\",\n       x = \"Valores da Variável Aleatória\", \n       y = \"CDF\") +\n  annotate(\"text\", x = max(valores), y = u, label = sprintf(\"u = %.2f\", u), hjust = -0.1, vjust = -1) +\n  annotate(\"text\", x = valor_gerado, y = max(cdf), label = paste(\"Valor gerado =\", valor_gerado), hjust = -0.1, vjust = -0.5) +\n  theme_minimal() +\n  theme(panel.grid = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n \n# Exemplo de valores e probabilidades de uma variável aleatória discreta\nvalores = [0, 1, 2, 3, 4, 5, 6]\nprobabilidades = [0, 0.1, 0.2, 0.3, 0.25, 0.15, 0]\n\n# Calculando a CDF\ncdf = np.cumsum(probabilidades)\n\n# Gerando um número aleatório uniforme\nu = np.random.uniform(0, 1)\n\n# Encontre o valor correspondente na CDF\nvalor_gerado = None\nfor i, valor in enumerate(valores):\n    if u &lt; cdf[i]:\n        valor_gerado = valor\n        break\n# Ajustando o gráfico para corrigir a visualização da CDF e garantir que os valores estejam corretamente posicionados\nplt.figure(figsize=(10, 6))\n\n# Ajustando o eixo x para que a CDF comece e termine corretamente\nplt.step(valores, cdf, label='CDF', color='blue', linewidth=2, where='post')\nplt.axhline(y=u, color='red', linestyle='--', label=f'Número aleatório u = {u:.2f}')\nplt.axvline(x=valor_gerado, color='green', linestyle='--', label=f'Valor gerado = {valor_gerado}')\nplt.title('Técnica da Inversão para Geração de Variável Aleatória Discreta')\nplt.xlabel('Valores da Variável Aleatória')\nplt.ylabel('CDF')\nplt.legend()\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#exemplo-1-geração-de-variáveis-aleatórias-com-distribuição-geométrica",
    "href": "3_discrete_inversion.html#exemplo-1-geração-de-variáveis-aleatórias-com-distribuição-geométrica",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "5.3 Exemplo 1: Geração de Variáveis Aleatórias com Distribuição Geométrica",
    "text": "5.3 Exemplo 1: Geração de Variáveis Aleatórias com Distribuição Geométrica\nA distribuição geométrica modela o número de tentativas até o primeiro sucesso em uma sequência de experimentos de Bernoulli. Se a probabilidade de sucesso em cada tentativa é \\(p\\), a PMF é dada por: \\[\nP(X = k) = (1 - p)^{k-1} p \\quad \\text{para} \\quad k = 1, 2, 3 \\dots\n\\] onde \\(k\\) representa o número de falhas antes do primeiro sucesso.\nVamos agora obter a fórmula da inversa da CDF para a distribuição geométrica foi obtida a partir da função de distribuição acumulada (CDF) da distribuição geométrica:\n\\[\n\\begin{aligned}\nF(k) & = \\mathbb{P}(X \\leq k) = \\sum_{x=1}^{k}(1 - p)^{x-1}p \\\\\n&= \\frac{p}{1 - p} \\sum_{x=1}^{k} (1 - p)^x\\\\\n& = \\frac{p}{1 - p} \\cdot \\frac{(1 - p)(1 - (1 - p)^k)}{p}\\\\\n&= 1 - (1 - p)^k.\n\\end{aligned}\n\\] Queremos encontrar a inversa da CDF, ou seja, a fórmula que, dado um valor \\(u\\) entre 0 e 1, nos permita calcular o valor \\(k\\) tal que \\(F(k) = u\\).\nSabemos que:\n\\[\nu = F(k) = 1 - (1 - p)^k\n\\]\nNosso objetivo é resolver essa equação para \\(k\\). Vamos fazer isso passo a passo.\nComeçamos isolando o termo \\((1 - p)^k\\):\n\\[\nu = 1 - (1 - p)^k\n\\]\nSubtraindo 1 de ambos os lados:\n\\[\nu - 1 = - (1 - p)^k\n\\]\nMultiplicando ambos os lados por \\(-1\\):\n\\[\n1 - u = (1 - p)^k\n\\]\nAgora aplicamos o logaritmo natural (log base \\(e\\)) em ambos os lados para resolver \\(k\\):\n\\[\n\\log(1 - u) = \\log((1 - p)^k)\n\\]\nUsando a propriedade dos logaritmos que permite trazer o expoente \\(k\\) para frente:\n\\[\n\\log(1 - u) = k \\cdot \\log(1 - p)\n\\]\nAgora, isolamos \\(k\\):\n\\[\nk = \\frac{\\log(1 - u)}{\\log(1 - p)}\n\\]\nComo \\(k\\) precisa ser um número inteiro (já que a distribuição geométrica conta o número de tentativas), usamos a função de arredondamento “para baixo” (\\(\\lfloor \\cdot \\rfloor\\)), conhecida como a função piso:\n\\[\nk = \\lfloor \\frac{\\log(1 - u)}{\\log(1 - p)} \\rfloor\n\\]\nPortanto, a fórmula da inversa da CDF da distribuição geométrica é:\n\\[\nk = \\lfloor \\frac{\\log(1 - u)}{\\log(1 - p)} \\rfloor\n\\]\nPodemos agora gerar variáveis aleatórias com distribuição geométrica a partir de um número aleatório uniforme \\(u \\in [0, 1)\\).\n\nRPython\n\n\n\n\nMostrar código\n# Função para gerar a inversa da CDF para a distribuição geométrica\ninversa_cdf_geometrica &lt;- function(p, u) {\n  # Usando a fórmula inversa da CDF geométrica: F⁻¹(u) = floor(log(1 - u) / log(1 - p))\n  k &lt;- floor(log(1 - u) / log(1 - p))\n  return(as.integer(k))\n}\n\n# Parâmetro p da distribuição geométrica\np &lt;- 0.5\n\n# Gerando 1000 números uniformemente distribuídos\nuniformes &lt;- runif(1000)\n\n# Gerando a variável aleatória geométrica correspondente para cada número uniforme\ngeometricas &lt;- sapply(uniformes, inversa_cdf_geometrica, p = p)\n\n# Plotando um histograma das variáveis geométricas geradas\nlibrary(ggplot2)\n\ndf &lt;- data.frame(geometricas = geometricas)\nggplot(df, aes(x = geometricas)) +\n  geom_histogram(bins = max(geometricas) + 1, color = \"black\", fill = \"skyblue\", boundary = 0, closed = \"left\") +\n  labs(title = \"Histograma de Variáveis Aleatórias Geométricas Usando a Inversa da CDF\",\n       x = \"Valor da Variável Aleatória Geométrica\", \n       y = \"Frequência\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n\n\nMostrar código\n# Função para calcular a CDF da distribuição geométrica\ncdf_geometrica &lt;- function(k, p) {\n  return(1 - (1 - p)^k)\n}\n\n# Gerando valores de k para plotar a CDF\nk_values &lt;- 1:20\ncdf_values &lt;- sapply(k_values, cdf_geometrica, p = p)\n\n# Plotando a CDF da distribuição geométrica\ndf_cdf &lt;- data.frame(k_values = k_values, cdf_values = cdf_values)\nggplot(df_cdf, aes(x = k_values, y = cdf_values)) +\n  geom_step(direction = \"hv\", color = \"blue\", size = 1.5) +\n  labs(title = \"CDF da Distribuição Geométrica (p = 0.5)\",\n       x = \"k (Número de tentativas até o primeiro sucesso)\", \n       y = \"F(k)\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Função para gerar a inversa da CDF para a distribuição geométrica\ndef inversa_cdf_geometrica(p, u):\n    # Usando a fórmula inversa da CDF geométrica: F⁻¹(u) = ceil(log(1 - u) / log(1 - p))\n    k = np.floor(np.log(1 - u) / np.log(1 - p))\n    return int(k)\n\n# Parâmetro p da distribuição geométrica\np = 0.5\n\n# Gerando 100 números uniformemente distribuídos\nuniformes = np.random.uniform(0, 1, 1000)\n\n# Gerando a variável aleatória geométrica correspondente para cada número uniforme\ngeometricas = [inversa_cdf_geometrica(p, u) for u in uniformes]\n\n# Plotando um histograma das variáveis geométricas geradas\nplt.figure(figsize=(10, 6))\nplt.hist(geometricas, bins=range(1, max(geometricas) + 1), color='skyblue', edgecolor='black', align='left')\nplt.title('Histograma de Variáveis Aleatórias Geométricas Usando a Inversa da CDF')\nplt.xlabel('Valor da Variável Aleatória Geométrica')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nMostrar código\n# Calculando a CDF para a distribuição geométrica\ndef cdf_geometrica(k, p):\n    return 1 - (1 - p)**k\n\n# Gerando valores de k para plotar a CDF\nk_values = np.arange(1, 21)\ncdf_values = [cdf_geometrica(k, p) for k in k_values]\n\n# Plotando a CDF da distribuição geométrica\nplt.figure(figsize=(10, 6))\nplt.step(k_values, cdf_values, where='post', color='blue', label='CDF Geométrica', linewidth=2)\nplt.title('CDF da Distribuição Geométrica (p = 0.3)')\nplt.xlabel('k (Número de tentativas até o primeiro sucesso)')\nplt.ylabel('F(k)')\nplt.grid(True)\nplt.legend()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#exemplo-2-geração-de-variáveis-aleatórias-com-distribuição-poisson",
    "href": "3_discrete_inversion.html#exemplo-2-geração-de-variáveis-aleatórias-com-distribuição-poisson",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "5.4 Exemplo 2: Geração de Variáveis Aleatórias com Distribuição Poisson",
    "text": "5.4 Exemplo 2: Geração de Variáveis Aleatórias com Distribuição Poisson\nA distribuição de Poisson é usada para modelar o número de eventos que ocorrem em um intervalo de tempo ou espaço fixo, onde os eventos ocorrem com uma taxa constante \\(\\lambda\\) e de forma independente.\nA função de probabilidade de massa (PMF) da distribuição de Poisson é dada por:\n\\[\nP(X = k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}, \\quad k = 0, 1, 2, \\ldots\n\\]\nA distribuição de Poisson tem uma fórmula recursiva que pode ser usada para calcular as probabilidades de forma mais eficiente. Em vez de recalcular a probabilidade \\(P(X = k)\\) a cada vez, podemos usar a seguinte relação recursiva:\n\\[\nP(X = k+1) = \\frac{\\lambda}{k+1} \\cdot P(X = k)\n\\]\nOnde \\(P(X = 0) = e^{-\\lambda}\\).\nEssa relação recursiva permite gerar variáveis aleatórias de Poisson sem precisar calcular fatoriais repetidamente, o que é mais eficiente para grandes valores de \\(\\lambda\\) ou grandes números de eventos \\(k\\).\n\n5.4.1 Técnica da Inversão Usando a Fórmula Recursiva\nPara gerar uma variável aleatória de Poisson usando a técnica da inversão e a fórmula recursiva, o processo é o seguinte:\n\nSeja \\(U \\sim \\text{Unif}(0,1)\\)\nFaça \\(i = 0\\), \\(p = e^{-\\lambda}\\) e \\(F = p\\)\nSe \\(U &lt; F\\), faça \\(X = i\\) e pare.\nSenão, atualize \\(p = \\frac{\\lambda p}{i + 1}\\), \\(F = F + p\\) e \\(i = i + 1\\)\nVolte para o passo (3)\n\nA seguir implementamos esse método:\n\nRPython\n\n\n\n\nMostrar código\n# Função para gerar a inversa da CDF para a distribuição Poisson usando a técnica de inversão e a fórmula recursiva\ninversa_cdf_poisson_recursiva &lt;- function(lam, u) {\n  k &lt;- 0\n  p &lt;- exp(-lam)  # P(X=0)\n  F_acm &lt;- p  # Iniciamos com a probabilidade P(X=0)\n  \n  # Continuamos somando até que F &gt;= u\n  while (u &gt; F_acm) {\n    k &lt;- k + 1\n    p &lt;- p * lam / k  # Atualiza a probabilidade recursivamente para o próximo valor\n    F_acm &lt;- F_acm + p\n  }\n  \n  return(k)\n}\n\n# Parâmetro lambda da distribuição Poisson\nlam &lt;- 3\n\n# Gerando 1000 números uniformemente distribuídos\nuniformes &lt;- runif(1000)\n\n# Gerando a variável aleatória Poisson correspondente para cada número uniforme\npoisson_vars &lt;- sapply(uniformes, inversa_cdf_poisson_recursiva, lam = lam)\n\n# Plotando o histograma das variáveis Poisson geradas\nlibrary(ggplot2)\n\ndf &lt;- data.frame(poisson_vars = poisson_vars)\nggplot(df, aes(x = poisson_vars)) +\n  geom_histogram(bins = max(poisson_vars) + 1, color = \"black\", fill = \"skyblue\", boundary = 0, closed = \"left\") +\n  labs(title = \"Histograma de Variáveis Aleatórias Poisson Usando a Fórmula Recursiva (λ = 3)\",\n       x = \"Valor da Variável Aleatória Poisson\", \n       y = \"Frequência\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n\n\nMostrar código\n# Função para calcular a CDF da distribuição Poisson\ncdf_poisson &lt;- function(k, lam) {\n  cdf &lt;- 0\n  p &lt;- exp(-lam)  # P(X=0)\n  for (i in 0:k) {\n    cdf &lt;- cdf + p  # Adiciona a probabilidade à CDF\n    if (i &lt; k) {\n      p &lt;- p * lam / (i + 1)  # Atualiza a probabilidade recursivamente\n    }\n  }\n  return(cdf)\n}\n\n# Gerando valores de k para a CDF\nk_values &lt;- 0:14\ncdf_values &lt;- sapply(k_values, cdf_poisson, lam = lam)\n\n# Plotando a CDF da distribuição Poisson\ndf_cdf &lt;- data.frame(k_values = k_values, cdf_values = cdf_values)\nggplot(df_cdf, aes(x = k_values, y = cdf_values)) +\n  geom_step(direction = \"hv\", color = \"blue\", size = 1.5) +\n  labs(title = \"CDF da Distribuição Poisson Usando a Fórmula Recursiva (λ = 3)\",\n       x = \"k (Número de eventos)\", \n       y = \"F(k)\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\n\n# Função para gerar a inversa da CDF para a distribuição Poisson usando a técnica de inversão e a fórmula recursiva\ndef inversa_cdf_poisson_recursiva(lam, u):\n    k = 0\n    p = math.exp(-lam)  # P(X=0)\n    F = p  # Iniciamos com a probabilidade P(X=0)\n    \n    # Continuamos somando até que F &gt;= u\n    while u &gt; F:\n        k += 1\n        p = p * lam / k  # Atualiza a probabilidade recursivamente para o próximo valor\n        F += p\n    \n    return k\n\n# Parâmetro lambda da distribuição Poisson\nlam = 3\n\n# Gerando 1000 números uniformemente distribuídos\nuniformes = np.random.uniform(0, 1, 1000)\n\n# Gerando a variável aleatória Poisson correspondente para cada número uniforme\npoisson_vars = [inversa_cdf_poisson_recursiva(lam, u) for u in uniformes]\n\n# Plotando o histograma das variáveis Poisson geradas\nplt.figure(figsize=(10, 6))\nplt.hist(poisson_vars, bins=range(0, max(poisson_vars) + 1), color='skyblue', edgecolor='black', align='left')\nplt.title('Histograma de Variáveis Aleatórias Poisson Usando a Fórmula Recursiva (λ = 3)')\nplt.xlabel('Valor da Variável Aleatória Poisson')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nMostrar código\n# Calculando a CDF da distribuição Poisson\ndef cdf_poisson(k, lam):\n    cdf = 0\n    p = math.exp(-lam)  # P(X=0)\n    for i in range(k+1):\n        cdf += p  # Adiciona a probabilidade à CDF\n        if i &lt; k:  # Atualiza a probabilidade recursivamente\n            p = p * lam / (i + 1)\n    return cdf\n\n# Gerando valores de k para a CDF\nk_values = np.arange(0, 15)\ncdf_values = [cdf_poisson(k, lam) for k in k_values]\n\n# Plotando a CDF da distribuição Poisson\nplt.figure(figsize=(10, 6))\nplt.step(k_values, cdf_values, where='post', color='blue', label='CDF Poisson', linewidth=2)\nplt.title('CDF da Distribuição Poisson Usando a Fórmula Recursiva (λ = 3)')\nplt.xlabel('k (Número de eventos)')\nplt.ylabel('F(k)')\nplt.grid(True)\nplt.legend()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#exercícios",
    "href": "3_discrete_inversion.html#exercícios",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "5.5 Exercícios",
    "text": "5.5 Exercícios\nExercício 1. Seja \\(X\\) uma v.a. tal que \\(\\mathbb P(X=1)=0.3,\\mathbb P(X=3)=0.1\\) e \\(\\mathbb P(X=4)=0.6\\).\n\nEscreva um pseudo-algoritmo para gerar um valor de \\(X\\).\nImplemente uma função para gerar \\(n\\) valores de \\(X\\).\nCompare a distribuição das frequências obtidas na amostra simulada com as probabilidades reais.\n\nExercício 2. Considere \\(X\\) uma v.a. tal que\n\\[\n\\mathbb{P}(X=i) = \\alpha \\mathbb{P}(X_1=i) + (1-\\alpha) \\mathbb{P}(X_2=i), \\quad i=0,1,\\dots\n\\]\nonde \\(0 \\leq \\alpha \\leq 1\\) e \\(X_1, X_2\\) são v.a. discretas.\nA distribuição de \\(X\\) é chamada de distribuição de mistura. Podemos escrever\n\\[\nX = \\begin{cases}\nX_1, & \\text{com probabilidade } \\alpha \\\\\nX_2, & \\text{com probabilidade } 1-\\alpha\n\\end{cases}\n\\]\nImplemente um algoritmo para gerar uma amostra de tamanho \\(n\\) da distribuição mistura de uma Poisson e de uma Geométrica com base nas funções implementadas nos exemplos (2) e (3).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html",
    "href": "4_continuous_inversion.html",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "",
    "text": "6.1 Função Inversa\nSabemos que \\(F: \\mathbb{R} \\to [0,1]\\) é estritamente crescente quando \\(X\\) é continua, e, portanto, podemos definir sua função inversa \\(F^{-1}: [0,1] \\to \\mathbb{R}\\). A seguinte figura ilustra \\(F\\) e sua inversa.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#função-inversa",
    "href": "4_continuous_inversion.html#função-inversa",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "",
    "text": "RPython\n\n\n\n\nMostrar código\n# Carregando as bibliotecas necessárias\nlibrary(ggplot2)\n\n# Definindo a função de distribuição acumulada F(x) - função logística\nF_ac &lt;- function(x) {\n  return(1 / (1 + exp(-x)))\n}\n\n# Definindo a inversa da função de distribuição acumulada F_inv(u)\nF_inv &lt;- function(u) {\n  return(-log((1 / u) - 1))\n}\n\n# Gerando valores de x e u\nx &lt;- seq(-4, 10, length.out = 400)\nu &lt;- seq(0.01, 0.99, length.out = 400)\n\n# Definindo o valor de U para plotar as linhas\nu_value &lt;- 0.7\nx_value &lt;- F_inv(u_value)\n\n# Criando o gráfico\nggplot(data = data.frame(x = x, F_x = F_ac(x))) +\n  geom_line(aes(x = x, y = F_x), color = \"black\") +\n  geom_hline(yintercept = u_value, linetype = \"dotted\", color = \"red\") +\n  geom_vline(xintercept = x_value, linetype = \"dotted\", color = \"red\") +\n  annotate(\"text\", x = x_value - 0.4, y = -0, label = expression(F^{-1}(u)), color = \"red\", size = 5) +\n  annotate(\"text\", x = -5.5, y = u_value - 0.02, label = \"u\", color = \"red\", size = 5) +\n  labs(title = \"Representação da Função de Distribuição Acumulada e sua Inversa\",\n       x = \"x\", y = \"F(x)\") +\n  ylim(0, 1.2) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n \n# Definindo a função de distribuição acumulada F(x)\ndef F(x):\n    return 1 / (1 + np.exp(-x))  # Função logística como exemplo de F(x)\n\n# Definindo a inversa da função de distribuição acumulada F_inv(u)\ndef F_inv(u):\n    return -np.log((1 / u) - 1)\n\n# Gerando valores de x e u para plotar\nx = np.linspace(-4, 10, 400)\nu = np.linspace(0.01, 0.99, 400)  # U entre 0 e 1 (evitando extremos para evitar erros na inversa)\n\n# Plotando a função de distribuição acumulada F(x) com truncamento do eixo y no zero\nplt.figure(figsize=(8, 6))\nplt.plot(x, F(x), color=\"black\")\n\n# Adicionando linhas pontilhadas para representar U e F_inv(U)\nu_value = 0.7  # Exemplo de valor de U\nx_value = F_inv(u_value)\n\nplt.hlines(u_value, min(x), x_value, linestyles='dotted', colors='red')\nplt.vlines(x_value, 0, u_value, linestyles='dotted', colors='red')\n\n# Etiquetas\nplt.text(x_value-0.4 , -0.05, r\"$F^{-1}(u)$\", fontsize=12, color='red')\nplt.text(-5.5, u_value - 0.02, r\"$u$\", fontsize=14, color='red')\n\n# Rótulos e estilo do gráfico\nplt.title(r'Representação da Função de Distribuição Acumulada e sua Inversa', fontsize=14)\nplt.xlabel(r'$x$', fontsize=12)\nplt.ylabel(r'$F(x)$', fontsize=12)\nplt.ylim(0, 1.2)\n\n\n(0.0, 1.2)\n\n\nMostrar código\nplt.xlim(-4, 10)\n\n\n(-4.0, 10.0)\n\n\nMostrar código\nplt.grid(True)\n\n# Exibir o gráfico\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#método-da-inversão",
    "href": "4_continuous_inversion.html#método-da-inversão",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "6.2 Método da Inversão",
    "text": "6.2 Método da Inversão\nUma maneira de gerar valores de uma variável aleatória contínua \\(X\\), é o método da inversão, que é originado da seguinte proposição:\nProposição: Seja \\(U \\sim \\text{Unif}(0,1)\\). Para qualquer variável aleatória contínua com função de distribuição acumulada \\(F\\), a variável: \\[\nX = F^{-1}(U)\n\\] tem distribuição \\(F\\).\nProva: \\[\n\\mathbb{P}(X \\leq x) = \\mathbb{P}(F^{-1}(U) \\leq x) = \\mathbb{P}(F(F^{-1}(U)) \\leq F(x)) = \\mathbb{P}(U \\leq F(x)) = F(x).\n\\]\nAssim, o método da inversão consiste em:\n\nGerar \\(U \\sim \\text{Unif}(0,1)\\).\nCalcular \\(X = F^{-1}(U)\\).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#exemplo-1",
    "href": "4_continuous_inversion.html#exemplo-1",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "6.3 Exemplo 1",
    "text": "6.3 Exemplo 1\nSeja \\(X\\) uma v.a. com: \\[\nF(x) = x^n, \\quad \\text{para } 0 &lt; x &lt; 1.\n\\]\nA função inversa é: \\[\nu = F(x) = x^n \\implies x = u^{1/n}.\n\\]\nPortanto, o pseudo-algoritmo para gerar \\(X\\) a partir do método da inversão é:\n\nGere \\(U \\sim \\text{Unif}(0,1)\\).\nCalcule \\(X = U^{1/n}\\).\n\n\n\n\nRPython\n\n\n\n\nMostrar código\n# Carregar a biblioteca ggplot2\nlibrary(ggplot2)\n\n# Definir o parâmetro n da distribuição F(x) = x^n\nn &lt;- 3\n\n# Gerar 1000 valores U de uma distribuição uniforme (0,1)\nU &lt;- runif(1000, min = 0, max = 1)\n\n# Calcular X = U^(1/n)\nX &lt;- U^(1/n)\n\n# Criar um dataframe para o ggplot2\ndata &lt;- data.frame(X = X)\n\n# Plotar o histograma usando ggplot2\np &lt;- ggplot(data, aes(x = X)) +\n  geom_histogram(aes(y = ..density..), bins = 30, fill = 'skyblue', color = 'black') +\n  labs(title = 'Histograma de variáveis geradas pela inversão: F(x) = x^n, n = 3',\n       x = 'Valor de X', y = 'Frequência') +\n  theme_minimal() +\n  theme(plot.title = element_text(size = 14),\n        axis.title.x = element_text(size = 12),\n        axis.title.y = element_text(size = 12))\n\n# Exibir o gráfico\nprint(p)\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parâmetro n da distribuição F(x) = x^n\nn = 3\n\n# Gerando 1000 valores U de uma distribuição uniforme (0,1)\nU = np.random.uniform(0, 1, 1000)\n\n# Calculando X = U^(1/n)\nX = U**(1/n)\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(X, bins=30, color='skyblue', edgecolor='black', density=True)\nplt.title('Histograma de variáveis geradas pela inversão: F(x) = x^n, n = 3')\nplt.xlabel('Valor de X')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.3.1 Exemplo 2\nSeja \\(X \\sim \\text{Exp}(\\lambda)\\), com: \\[\nF(x) = 1 - e^{-\\lambda x}, \\quad \\text{para } x &gt; 0.\n\\]\nA função inversa é: \\[\nu = F(x) = 1 - e^{-\\lambda x} \\implies x = -\\frac{\\log(1 - u)}{\\lambda}.\n\\]\nUm pseudo-algoritmo para gerar \\(X\\) é, portanto,:\n\nGere \\(U \\sim \\text{Unif}(0,1)\\).\nCalcule \\(X = -\\frac{\\log(1 - U)}{\\lambda}\\).\n\n\nRPython\n\n\n\n\nMostrar código\n# Carregar a biblioteca ggplot2\nlibrary(ggplot2)\n\n# Definir o parâmetro lambda da distribuição exponencial\nlambda &lt;- 2\n\n# Gerar 1000 valores U de uma distribuição uniforme (0,1)\nU &lt;- runif(1000, min = 0, max = 1)\n\n# Calcular X usando a inversa da CDF da distribuição exponencial\nX &lt;- -log(1 - U) / lambda\n\n# Criar um dataframe para o ggplot2\ndata &lt;- data.frame(X = X)\n\n# Plotar o histograma usando ggplot2\np &lt;- ggplot(data, aes(x = X)) +\n  geom_histogram(aes(y = ..density..), bins = 30, fill = 'lightcoral', color = 'black') +\n  labs(title = 'Histograma de variáveis geradas pela inversão: Distribuição Exponencial',\n       x = 'Valor de X', y = 'Frequência') +\n  theme_minimal() +\n  theme(plot.title = element_text(size = 14),\n        axis.title.x = element_text(size = 12),\n        axis.title.y = element_text(size = 12))\n\n# Exibir o gráfico\nprint(p)\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parâmetro lambda da distribuição exponencial\nlambd = 2\n\n# Gerando 1000 valores U de uma distribuição uniforme (0,1)\nU = np.random.uniform(0, 1, 1000)\n\n# Calculando X usando a inversa da CDF da exponencial\nX = -np.log(1 - U) / lambd\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(X, bins=30, color='lightcoral', edgecolor='black', density=True)\nplt.title('Histograma de variáveis geradas pela inversão: Distribuição Exponencial')\nplt.xlabel('Valor de X')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#simulação-de-transformações-de-variáveis-aleatórias",
    "href": "4_continuous_inversion.html#simulação-de-transformações-de-variáveis-aleatórias",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "6.4 Simulação de transformações de variáveis aleatórias",
    "text": "6.4 Simulação de transformações de variáveis aleatórias\nAgora que já sabemos uma maneira de simular uma variável aleatória \\(X\\), descreveremos como gerar valores de uma transformação dessa variável, ou seja, \\(g(X)\\). Para isso, basta aplicar a função de transformação \\(g\\) diretamente aos valores simulados de \\(X\\). Veremos a seguinte alguns exemplos disso em funcionamento.\n\n\n6.4.1 Exemplo 1: Simulando \\(Y \\sim Unif(1, 2)\\)\nPara gerar valores de \\(Y \\sim Unif(1, 2)\\), usamos o fato de que \\(Y\\) é uma simples transformação de \\(U \\sim Unif(0, 1)\\). A relação é: \\[\nY = U + 1.\n\\]\nAssim, podemos usar o seguinte pseudo-algoritmo para gerar \\(Y\\) a partir de \\(U\\):\n\nGere \\(U \\sim Unif(0,1)\\).\nCalcule \\(Y = U + 1\\).\n\n\nRPython\n\n\n\n\nMostrar código\n# Carregar biblioteca ggplot2\nlibrary(ggplot2)\n\n# Gerar 1000 valores U de uma distribuição uniforme (0,1)\nU &lt;- runif(1000, min = 0, max = 1)\n\n# Calcular Y = U + 1 para ter Y ~ Unif(1, 2)\nY &lt;- U + 1\n\n# Criar um dataframe para o ggplot2\ndata &lt;- data.frame(Y = Y)\n\n# Plotar o histograma usando ggplot2\np &lt;- ggplot(data, aes(x = Y)) +\n  geom_histogram(aes(y = ..density..), bins = 30, fill = 'skyblue', color = 'black') +\n  labs(title = 'Histograma de variáveis geradas: Y ~ Unif(1, 2)',\n       x = 'Valor de Y', y = 'Frequência') +\n  theme_minimal() +\n  theme(plot.title = element_text(size = 14),\n        axis.title.x = element_text(size = 12),\n        axis.title.y = element_text(size = 12))\n\n# Exibir o gráfico\nprint(p)\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Gerando 1000 valores U de uma distribuição uniforme (0,1)\nU = np.random.uniform(0, 1, 1000)\n\n# Calculando Y = U + 1 para ter Y ~ Unif(1, 2)\nY = U + 1\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(Y, bins=30, color='skyblue', edgecolor='black', density=True)\nplt.title('Histograma de variáveis geradas: Y ~ Unif(1, 2)')\nplt.xlabel('Valor de Y')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.4.2 Exemplo 2: Simulando \\(Y \\sim Gamma(n, \\lambda)\\)\nPara gerar valores de \\(Y \\sim \\Gamma(n, \\lambda)\\), usamos o fato de que a soma de que \\(Y\\) pode ser representado como \\[Y= \\sum_{i=1}^n X_i,\\] em que cada \\(X_i \\sim Exp(\\lambda)\\), e \\(X_i\\)’s são independentes.\nAssim, podemos gerar \\(Y\\) da seguinte forma:\n\nGere \\(U_1, \\dots, U_n \\sim Unif(0,1)\\) independentemente.\nCalcule \\(X_i = -\\frac{\\log(1 - U_i)}{\\lambda}\\) para \\(i = 1, \\dots, n\\).\nCalcule \\(Y = X_1 + X_2 + \\dots + X_n\\).\n\n\nRPython\n\n\n\n\nMostrar código\n# Carregar biblioteca ggplot2\nlibrary(ggplot2)\n\n# Definir parâmetros\nn &lt;- 5  # número de somas\nlambda &lt;- 2  # parâmetro da distribuição exponencial\n\n# Gerar 1000 valores U para cada uma das n somas\nU &lt;- matrix(runif(1000 * n, min = 0, max = 1), ncol = n)\n\n# Calcular X_i = -log(1 - U_i) / lambda para cada U_i\nX &lt;- -log(1 - U) / lambda\n\n# Somar os valores de X para obter Y ~ Gamma(n, lambda)\nY &lt;- rowSums(X)\n\n# Criar um dataframe para o ggplot2\ndata &lt;- data.frame(Y = Y)\n\n# Plotar o histograma usando ggplot2\np &lt;- ggplot(data, aes(x = Y)) +\n  geom_histogram(aes(y = ..density..), bins = 30, fill = 'lightcoral', color = 'black') +\n  labs(title = paste('Histograma de variáveis geradas: Y ~ Gamma(', n, ', ', lambda, ')'),\n       x = 'Valor de Y', y = 'Frequência') +\n  theme_minimal() +\n  theme(plot.title = element_text(size = 14),\n        axis.title.x = element_text(size = 12),\n        axis.title.y = element_text(size = 12))\n\n# Exibir o gráfico\nprint(p)\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\n# Definindo parâmetros\nn = 5  # número de somas\nlambd = 2  # parâmetro da distribuição exponencial\n\n# Gerando 1000 valores U para cada uma das n somas\nU = np.random.uniform(0, 1, (1000, n))\n\n# Calculando X_i = -log(1 - U_i) / lambda para cada U_i\nX = -np.log(1 - U) / lambd\n\n# Somando os valores de X para obter Y ~ Gamma(n, lambda)\nY = np.sum(X, axis=1)\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(Y, bins=30, color='lightcoral', edgecolor='black', density=True)\nplt.title(f'Histograma de variáveis geradas: Y ~ Gamma({n}, {lambd})')\nplt.xlabel('Valor de Y')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#exercícios",
    "href": "4_continuous_inversion.html#exercícios",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "6.5 Exercícios",
    "text": "6.5 Exercícios\nExercício 1.\nUtilizando o método da inversão, simule \\(U \\sim U(1,3)\\).\nExercício 2.\n\nImplemente uma função para gerar uma amostra de tamanho \\(n\\) da distribuição Exponencial de parâmetro \\(\\lambda\\).\nCompare a distribuição empírica dos valores simulados com a densidade da Exponencial \\(f(x)=\\lambda e^{-\\lambda x}, x&gt;0\\).\n\nExercício 3.\n\nImplemente uma função para gerar uma amostra de tamanho \\(n\\) da distribuição \\(Gama(a,b)\\), para \\(a\\) sendo um valor inteiro.\nCompare a distribuição empírica dos valores simulados com a densidade da Gama \\(f(x)=\\frac{b^a}{\\Gamma(a)}x^{a-1}e^{-bx}, x&gt;0\\).\n\nExercício 4. Seja \\(X\\) uma v.a. com função densidade dada por:\n\\[f(x) = \\frac{1}{8}x,\\quad 0 &lt; x &lt; 4.\\]\n\nEscreva um pseudo-algoritmo para simular um único valor da variável \\(X\\) pelo método da inversão.\nCompare a distribuição empírica dos valores simulados com a densidade de \\(X\\).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "5_discrete_rejection.html",
    "href": "5_discrete_rejection.html",
    "title": "7  Método da Rejeição para Variáveis Discretas",
    "section": "",
    "text": "7.1 Algoritmo\nO método assume que conhecemos uma distribuição \\(q_j\\), fácil de simular, que cubra o suporte da distribuição alvo \\(p_j\\). Essa distribuição é chamada de distribuição proposta. Além disso, ele assume que existe uma constante \\(c\\) tal que \\(\\frac{p_j}{q_j} \\leq c\\) para todo \\(j\\) tal que \\(p_j &gt; 0\\), e que conseguimos calcular \\(c\\).\nO método de aceitação e rejeição segue os seguintes passos:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Discretas</span>"
    ]
  },
  {
    "objectID": "5_discrete_rejection.html#algoritmo",
    "href": "5_discrete_rejection.html#algoritmo",
    "title": "7  Método da Rejeição para Variáveis Discretas",
    "section": "",
    "text": "Gere um valor \\(Y\\) da distribuição proposta \\(q_j\\).\nGere um valor \\(U \\sim \\text{Uniform}(0, 1)\\).\nAceite \\(Y\\) como uma amostra de \\(p_j\\) se \\(U \\leq \\frac{p(Y)}{c \\cdot q(Y)}\\), caso contrário, rejeite \\(Y\\) e repita o processo.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Discretas</span>"
    ]
  },
  {
    "objectID": "5_discrete_rejection.html#exemplo",
    "href": "5_discrete_rejection.html#exemplo",
    "title": "7  Método da Rejeição para Variáveis Discretas",
    "section": "7.2 Exemplo",
    "text": "7.2 Exemplo\nVamos demonstrar a amostragem por rejeição gerando amostras de uma distribuição alvo discreta \\(p_j\\), utilizando uma distribuição uniforme discreta como distribuição proposta.\nSuponha que \\(Y\\) siga uma distribuição uniforme discreta em \\(\\{1, 2, \\dots, 10\\}\\), ou seja, \\(q_j = 1/10\\) para todos os valores \\(j\\). A distribuição alvo \\(p_j\\) tem os seguintes valores:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(j\\)\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n\\(p_j\\)\n0.11\n0.12\n0.09\n0.08\n0.12\n0.10\n0.09\n0.09\n0.10\n0.10\n\n\n\nPara aplicar o método de aceitação e rejeição, precisamos de uma constante \\(c\\) tal que \\(\\frac{p_j}{q_j} \\leq c\\) para todo \\(j\\). Neste caso, temos \\(c = 1.2\\).\n\nRPython\n\n\n\n\nMostrar código\nlibrary(ggplot2)\n\n# Valores de j e probabilidades p_j e q_j\nj_values &lt;- 1:10\np_j &lt;- c(0.11, 0.12, 0.09, 0.08, 0.12, 0.10, 0.09, 0.09, 0.10, 0.10)\nq_j &lt;- rep(1 / 10, length(p_j))  # Distribuição uniforme\n\n# Constante c para ajustar q_j\nc &lt;- max(p_j / q_j)\ncq_j &lt;- c * q_j  # Multiplica a distribuição proposta pela constante\n\n# Criação do data frame para o ggplot2\ndf &lt;- data.frame(j = j_values, p_j = p_j, cq_j = cq_j)\n\n# Plot com ggplot2\nggplot(df, aes(x = j)) +\n  geom_segment(aes(x = j, xend = j, y = 0, yend = cq_j), color = \"black\") +\n  geom_point(aes(y = cq_j), color = \"green\", size = 3) +\n  geom_point(aes(y = p_j), color = \"red\", size = 3) +\n  labs(x = \"\", y = \"\") +\n  ylim(0, 0.2) +\n  theme_minimal() +\n  theme(legend.position = \"top\") +\n  scale_color_manual(values = c(\"p(x)\" = \"red\", \"cq(x)\" = \"green\"), name = \"\") +\n  guides(color = guide_legend(override.aes = list(shape = 16))) +\n  geom_point(aes(y = p_j, color = \"p(x)\"), size = 3) +\n  geom_point(aes(y = cq_j, color = \"cq(x)\"), size = 3) \n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Valores de j e probabilidades p_j e q_j\nj_values = np.arange(1, 11)\np_j = np.array([0.11, 0.12, 0.09, 0.08, 0.12, 0.10, 0.09, 0.09, 0.10, 0.10])\nq_j = np.full_like(p_j, 1 / 10)  # Distribuição uniforme\n\n# Constante c para ajustar q_j\nc = max(p_j / q_j)\ncq_j = c * q_j  # Multiplica a distribuição proposta pela constante\n\n# Plot\nplt.figure(figsize=(8, 5))\nplt.stem(j_values, cq_j, linefmt=\"black\", markerfmt=\"go\", basefmt=\" \", label=\"cq(x)\")\nplt.stem(j_values, p_j, linefmt=\"black\", markerfmt=\"ro\", basefmt=\" \", label=\"p(x)\")\n\n# Configurações do gráfico\nplt.ylim(0, 0.2)\n\n\n(0.0, 0.2)\n\n\nMostrar código\nplt.legend(loc=\"upper right\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.2.1 Teoria do método de rejeição\nTeorema: O método da aceitação e rejeição gera uma v.a. X tal que\n\\[\nP(X = j) = p_j ,\\  j = 0, 1, \\dots\n\\]\nO número de passos que o algoritmo necessita para gerar X tem distribuição geométrica com média c.\nProva:\n\\[\nP(Y = j \\text{ e aceitar}) = P(Y = j)P(\\text{aceitar } | Y = j) = q_j\n\\frac{p_j}{c q_j} = \\frac{p_j}{c}\n\\]\nEntão,\n\\[\nP(\\text{aceitar}) = \\sum_{j=0}^{\\infty} \\frac{p_j}{c} = \\frac{1}{c}\n\\]\nA cada passo a probabilidade de aceitar um valor é \\(\\frac{1}{c}\\), então o número de passos necessários para aceitar um valor tem dist. geométrica com média c.\nAlém disso, temos\n\\[\nP(X = j) = \\sum_{n=1}^{\\infty} P(Y = j \\text{ e aceitar pela 1a vez no passo n}) = \\sum_{n=1}^{\\infty} \\left(1 - \\frac{1}{c}\\right)^{n-1} \\frac{p_j}{c} = p_j\n\\]",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Discretas</span>"
    ]
  },
  {
    "objectID": "5_discrete_rejection.html#exercício",
    "href": "5_discrete_rejection.html#exercício",
    "title": "7  Método da Rejeição para Variáveis Discretas",
    "section": "7.3 Exercício",
    "text": "7.3 Exercício\nExercício 1..\nImplemente o método de aceitação e rejeição para gerar uma amostra da variável aleatória \\(X\\) com a distribuição de probabilidades alvo \\(p_j\\) dada anteriormente:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(j\\)\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n\\(p_j\\)\n0.11\n0.12\n0.09\n0.08\n0.12\n0.10\n0.09\n0.09\n0.10\n0.10\n\n\n\nUse a distribuição uniforme discreta em \\(\\{1, 2, \\dots, 10\\}\\) como a distribuição proposta \\(q_j\\), em que \\(q_j = 1/10\\) para todos os valores de \\(j\\).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Discretas</span>"
    ]
  },
  {
    "objectID": "6_continuous_rejection.html",
    "href": "6_continuous_rejection.html",
    "title": "8  Método da Rejeição para Variáveis Contínuas",
    "section": "",
    "text": "8.1 Algoritmo\nO método assume que conhecemos uma distribuição \\(g(x)\\), fácil de simular, que cubra o suporte da distribuição alvo \\(f(x)\\). Essa distribuição é chamada de distribuição proposta. Além disso ele assume que existe \\(c\\) tal que \\(\\frac{f(x)}{g(x)} \\leq c\\) para todo \\(x\\), e que conseguimos calcular \\(c\\). O método de aceitação e rejeição segue os seguintes passos:\nA figura a seguir ilustra esse processo quando \\(g\\) é uma distribuição uniforme entre 0 e 1.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "6_continuous_rejection.html#algoritmo",
    "href": "6_continuous_rejection.html#algoritmo",
    "title": "8  Método da Rejeição para Variáveis Contínuas",
    "section": "",
    "text": "Gere um valor \\(Y\\) da distribuição proposta \\(g(x)\\).\nGere um valor \\(U \\sim \\text{Uniform}(0, 1)\\).\nAceite \\(Y\\) como uma amostra de \\(f(x)\\) se \\(U \\leq \\frac{f(Y)}{c \\cdot g(Y)}\\), caso contrário, rejeite \\(Y\\) e repita o processo.\n\n\n\nRPython\n\n\n\n\nMostrar código\nlibrary(ggplot2)\n\n# Função densidade alvo f(x)\nf &lt;- function(x) {\n  20 * x * (1 - x)^3\n}\n\n# Função densidade proposta g(x) (distribuição uniforme)\ng &lt;- function(x) {\n  rep(1, length(x))  # g(x) é uniforme no intervalo (0, 1)\n}\n\n# Constante c (máximo de f(x))\nopt_result &lt;- optimize(f = function(x) -f(x), interval = c(0, 1))\nc &lt;- f(opt_result$minimum)\n\n# Gerar valores de x\nx &lt;- seq(0, 1, length.out = 1000)\n\n# Valor de Y para aceitar/rejeitar (escolhido aleatoriamente)\nY &lt;- 0.6\n\n# DataFrame para o gráfico\ndf &lt;- data.frame(x = x, fx = f(x), gx = c * g(x))\n\n# Plotando as funções f(x) e a linha horizontal c*g(x)\nggplot(df, aes(x = x)) +\n  geom_line(aes(y = fx, color = \"f(x)\"), size = 1) +\n  geom_hline(aes(yintercept = c * g(x), color = \"c * g(x)\"), size = 1.5) +\n  \n  # Destacar a área de aceitação e rejeição\n  geom_text(aes(x = Y + 0.025, y = 0.05, label = \"Y\"), color = \"black\", size = 5) +\n  \n  geom_segment(aes(x = Y, xend = Y, y = 0, yend = f(Y)), color = \"green\", size = 1.5) +\n  geom_segment(aes(x = Y, xend = Y, y = f(Y), yend = c * g(Y)), color = \"red\", size = 1.5) +\n  \n  # Mover rótulos de Aceitar/Rejeitar para a esquerda da linha Y\n  geom_text(aes(x = Y + 0.06, y = f(Y) / 2, label = \"Aceitar x\"), color = \"green\", size = 4) +\n  geom_text(aes(x = Y + 0.06, y = f(Y) + (c * g(Y) - f(Y)) / 2, label = \"Rejeitar x\"), color = \"red\", size = 4) +\n  \n  # Limites e rótulos\n  xlim(0, 1) +\n  ylim(0, 2.5) +\n  labs(x = \"x\", y = \"Densidade\", title = \"Amostragem por Rejeição para g uniforme\") +\n  \n  # Legenda\n  scale_color_manual(values = c(\"f(x)\" = \"black\", \"c * g(x)\" = \"blue\"), name = \"Funções\") +\n  \n  theme_minimal() +\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import minimize_scalar\n\n# Função densidade alvo f(x)\ndef f(x):\n    return 20 * x * (1 - x)**3\n\n# Função densidade proposta g(x) (distribuição uniforme)\ndef g(x):\n    return 1  # g(x) é uniforme no intervalo (0, 1)\n\n# Constante c\nresult = minimize_scalar(lambda x: -f(x), bounds=(0, 1), method='bounded')\nc = f(result.x)\n\n# Gerar valores de x\nx = np.linspace(0, 1, 1000)\n\n# Valor de Y para aceitar/rejeitar (escolhido aleatoriamente)\nY = 0.6\nU = 0.8\naccept_threshold = f(Y) / (c * g(Y))\n\n# Plotando as funções f(x) e a linha horizontal c*g(x)\n# Ajustando o código para truncar o eixo y no zero\nplt.plot(x, f(x), label='f(x)', color='black')\nplt.hlines(c * g(x), 0, 1, color='blue', label='c*g(x)', linewidth=2)  # Linha horizontal c*g(x)\n\n# Destacar a área de aceitação e rejeição\nplt.vlines(Y, 0, f(Y), colors='green', label='Aceitar $x$', linewidth=2)\nplt.vlines(Y, f(Y), c * g(Y), colors='red', label='Rejeitar $x$', linewidth=2)\n\n# Adicionar rótulo de Y na posição da linha vertical\nplt.text(Y+0.025, 0.05, 'Y', color='black', fontsize=12, horizontalalignment='center')\n\n# Adicionar rótulos de Aceitar/Rejeitar\nplt.text(Y + 0.01, f(Y) / 2, 'Aceitar x', color='green', fontsize=10, verticalalignment='center')\nplt.text(Y + 0.01, f(Y) + (c * g(Y) - f(Y)) / 2, 'Rejeitar x', color='red', fontsize=10, verticalalignment='center')\n\n# Limites e rótulos\nplt.xlim(0, 1)\n\n\n(0.0, 1.0)\n\n\nMostrar código\nplt.ylim(0, 2.5)  # Truncando o eixo y no zero\n\n\n(0.0, 2.5)\n\n\nMostrar código\nplt.xlabel('x')\nplt.ylabel('Densidade')\n\n# Adicionar a legenda para f(x) e c*g(x)\nplt.legend(['f(x)', 'c*g(x)'])\n\n# Mostrar gráfico\nplt.title('Amostragem por Rejeição para g uniforme')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "6_continuous_rejection.html#exemplo",
    "href": "6_continuous_rejection.html#exemplo",
    "title": "8  Método da Rejeição para Variáveis Contínuas",
    "section": "8.2 Exemplo",
    "text": "8.2 Exemplo\nVamos demonstrar a amostragem por rejeição gerando amostras de uma distribuição alvo \\(f(x)\\), utilizando a distribuição uniforme como distribuição proposta.\nA função densidade alvo que utilizaremos é: \\[\nf(x) = 20x(1 - x)^3 \\quad \\text{para} \\quad 0 &lt; x &lt; 1\n\\] E a distribuição proposta será \\(g(x) = 1 \\quad \\text{para} \\quad 0 &lt; x &lt; 1\\), que é uma distribuição uniforme.\nImplementamos o seguinte algoritmo:\n\nRPython\n\n\n\n\nMostrar código\nlibrary(ggplot2)\n\n# Função densidade alvo f(x)\nf &lt;- function(x) {\n  20 * x * (1 - x)^3\n}\n\n# Amostragem por rejeição\namostragem_rejeicao &lt;- function(f, c, n_amostras) {\n  amostras &lt;- numeric(0)\n  while (length(amostras) &lt; n_amostras) {\n    # Gere Y ~ g(x) (uniforme entre 0 e 1)\n    Y &lt;- runif(1, 0, 1)\n    \n    # Gere U ~ Uniforme(0, 1)\n    U &lt;- runif(1, 0, 1)\n    \n    # Verifica se aceitamos Y\n    if (U &lt;= f(Y) / (c)) {\n      amostras &lt;- c(amostras, Y)\n    }\n  }\n  return(amostras)\n}\n\n# A constante c é o limite superior de f(x)\nc &lt;- 135 / 64\n\n# Gere 1000 amostras usando o método de aceitação e rejeição\nset.seed(123)\namostras &lt;- amostragem_rejeicao(f, c, 1000)\n\n# Criação do data frame para o ggplot2\nx_vals &lt;- seq(0, 1, length.out = 1000)\nf_vals &lt;- f(x_vals)\ndf &lt;- data.frame(x = x_vals, y = f_vals)\n\n# Gráfico com ggplot2\nggplot() +\n  geom_line(data = df, aes(x = x, y = y), color = 'blue', size = 1, linetype = 'solid') +\n  geom_histogram(aes(x = amostras, y = ..density..), bins = 30, fill = 'orange', alpha = 0.5, color = 'black') +\n  ggtitle(\"Amostragem por Rejeição\") +\n  xlab(\"x\") +\n  ylab(\"Densidade\") +\n  theme_minimal() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Função densidade alvo f(x)\ndef f(x):\n    return 20 * x * (1 - x)**3\n\n# Função densidade proposta g(x) (distribuição uniforme)\ndef g(x):\n    return 1  # g(x) é uniforme no intervalo (0, 1)\n\n# Amostragem por rejeição\ndef amostragem_rejeicao(f, g, c, n_amostras):\n    amostras = []\n    while len(amostras) &lt; n_amostras:\n        # Gere Y ~ g(x)\n        Y = np.random.uniform(0, 1)\n        \n        # Gere U ~ Uniforme(0, 1)\n        U = np.random.uniform(0, 1)\n        \n        # Verifica se aceitamos Y\n        if U &lt;= f(Y) / (c * g(Y)):\n            amostras.append(Y)\n     \n    return np.array(amostras)\n \n# A constante c é o limite superior de f(x)/g(x)\nc = 135 / 64  # Pré-calculado\n\n# Gere 1000 amostras usando o método de aceitação e rejeição\namostras = amostragem_rejeicao(f, g, c, 1000)\n\n# Plotando os resultados\nx = np.linspace(0, 1, 1000)\nplt.plot(x, f(x), label='Distribuição Alvo f(x)')\nplt.hist(amostras, bins=30, density=True, alpha=0.5, label='Amostragem por Rejeição')\nplt.legend()\nplt.title(\"Amostragem por Rejeição\")\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "6_continuous_rejection.html#resultados-teóricos",
    "href": "6_continuous_rejection.html#resultados-teóricos",
    "title": "8  Método da Rejeição para Variáveis Contínuas",
    "section": "8.3 Resultados Teóricos",
    "text": "8.3 Resultados Teóricos\n\n8.3.1 Correção do Método de Aceitação e Rejeição\nTeorema:\nA variável aleatória \\(Y\\) gerada pelo método da rejeição tem densidade \\(f(x)\\).\nProva:\nConsidere a função de distribuição acumulada (CDF) de \\(X\\), a variável gerada pelo método:\n\\[\nP(X \\leq x) = P(Y \\leq x \\mid \\text{aceitar } Y)\n\\]\nPodemos escrever essa probabilidade como:\n\\[\nP(X \\leq x) = \\frac{P(Y \\leq x, U \\leq \\frac{f(Y)}{c \\cdot g(Y)})}{P(U \\leq \\frac{f(Y)}{c \\cdot g(Y)})}\n\\]\nUsando a probabilidade condicional, o numerador pode ser expresso como:\n\\[\nP(Y \\leq x, U \\leq \\frac{f(Y)}{c \\cdot g(Y)}) = \\int_{-\\infty}^x \\int_0^{\\frac{f(y)}{c \\cdot g(y)}} g(y) \\, du \\, dy\n\\]\nResolvendo a integral em \\(u\\):\n\\[\nP(Y \\leq x, U \\leq \\frac{f(Y)}{c \\cdot g(Y)}) = \\int_{-\\infty}^x \\frac{f(y)}{c \\cdot g(y)} g(y) \\, dy = \\frac{1}{c} \\int_{-\\infty}^x f(y) \\, dy\n\\]\nDe maneira semelhante, o denominador é dado por:\n\\[\nP\\left(U \\leq \\frac{f(Y)}{c \\cdot g(Y)}\\right) = \\int_{-\\infty}^{\\infty} \\frac{f(y)}{c \\cdot g(y)} g(y) \\, dy = \\frac{1}{c} \\int_{-\\infty}^{\\infty} f(y) \\, dy\n\\]\nComo \\(\\int_{-\\infty}^{\\infty} f(y) \\, dy = 1\\) (pois \\(f(x)\\) é uma função densidade), o denominador resulta em \\(\\frac{1}{c}\\). Substituindo essas expressões na equação original, obtemos:\n\\[\nP(X \\leq x) = \\frac{\\frac{1}{c} \\int_{-\\infty}^x f(y) \\, dy}{\\frac{1}{c}} = \\int_{-\\infty}^x f(y) \\, dy\n\\]\nPortanto, a variável \\(X\\) gerada pelo método de aceitação e rejeição tem função de distribuição acumulada \\(\\int_{-\\infty}^x f(y) \\, dy\\), o que implica que \\(X\\) tem densidade \\(f(x)\\). Assim, o método gera amostras corretamente distribuídas de acordo com \\(f(x)\\), como desejado.\n\n\n8.3.2 Eficiência computacional\nTeorema:\nA variável aleatória gerada pelo método de aceitação e rejeição tem função de densidade \\(f(x)\\). O número de passos que o algoritmo necessita para gerar \\(X\\) tem distribuição geométrica com média \\(c\\), onde \\(c\\) é a constante de normalização que define o limite superior da razão \\(\\frac{f(x)}{g(x)}\\).\nProva:\nSeja \\(Y\\) a variável aleatória gerada pela distribuição proposta \\(g(x)\\), e \\(U \\sim \\text{Unif}(0, 1)\\) uma variável aleatória uniforme. O método de aceitação e rejeição aceita \\(Y\\) como amostra de \\(f(x)\\) se \\(U \\leq \\frac{f(Y)}{c g(Y)}\\), caso contrário, o valor é rejeitado e o processo é repetido.\nA probabilidade de aceitar uma amostra \\(Y\\), dado que \\(Y \\leq x\\), é dada por:\n\\[\nP(Y \\leq x \\text{ e aceitar}) = P\\left(Y \\leq x , U \\leq \\frac{f(Y)}{c g(Y)}\\right)\n\\]\nPodemos reescrever essa probabilidade como uma integral:\n\\[\nP(Y \\leq x \\text{ e aceitar}) = \\int_{-\\infty}^x \\int_{0}^{\\frac{f(y)}{c g(y)}} g(y) \\, du \\, dy\n\\]\nResolvendo a integral em \\(u\\), temos:\n\\[\nP(Y \\leq x \\text{ e aceitar}) = \\int_{-\\infty}^x \\frac{f(y)}{c g(y)} g(y) \\, dy = \\frac{1}{c} \\int_{-\\infty}^x f(y) \\, dy\n\\]\nA probabilidade de aceitar qualquer valor \\(Y\\) é dada por:\n\\[\nP(\\text{aceitar}) = P\\left(U \\leq \\frac{f(Y)}{c g(Y)}\\right) = \\int_{-\\infty}^{\\infty} \\int_{0}^{\\frac{f(y)}{c g(y)}} g(y) \\, du \\, dy\n\\]\nSimplificando:\n\\[\nP(\\text{aceitar}) = \\int_{-\\infty}^{\\infty} \\frac{f(y)}{c g(y)} g(y) \\, dy = \\frac{1}{c} \\int_{-\\infty}^{\\infty} f(y) \\, dy = \\frac{1}{c}\n\\]\nAssim, a cada passo, a probabilidade de aceitar um valor é \\(\\frac{1}{c}\\), o que implica que o número de passos necessários para aceitar uma amostra tem distribuição geométrica com média \\(c\\).\nPor fim, sabemos que a função de distribuição acumulada da variável \\(X\\), dado que ela foi aceita, é:\n\\[\nP(X \\leq x) = P(Y \\leq x \\mid \\text{aceitou}) = \\frac{P(Y \\leq x , \\text{aceitou})}{P(\\text{aceitar})}\n\\]\nSubstituindo as expressões:\n\\[\nP(X \\leq x) = \\frac{\\frac{1}{c} \\int_{-\\infty}^x f(y) \\, dy}{\\frac{1}{c}} = \\int_{-\\infty}^x f(y) \\, dy\n\\]\nPortanto, a variável \\(X\\) gerada pelo método de aceitação e rejeição tem função de densidade \\(f(x)\\), como desejado.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "6_continuous_rejection.html#exercícios",
    "href": "6_continuous_rejection.html#exercícios",
    "title": "8  Método da Rejeição para Variáveis Contínuas",
    "section": "8.4 Exercícios",
    "text": "8.4 Exercícios\nExercício 1. Seja \\(X\\sim Gama(3/2,1)\\) com função densidade dada por \\[f(x)=\\frac{1}{\\Gamma(3/2)}x^{1/2}e^{-x}, \\text{ para } x &gt; 0.\\]\n\nEscreva um pseudo-algoritmo para simular um valor da distribuição de \\(X\\) usando o método da aceitação e rejeição usando como distribuição proposta a distribuição exponencial de parâmetro \\(2/3\\).\n\nObservação: Note que \\(\\mathbb E[X]=3/2\\) e \\(\\mathbb E[Y]=3/2\\), por isso o parâmetro da distribuição exponencial proposta foi tomado como \\(2/3\\).\n\nCrie uma função para gerar um valor de \\(X\\).\nQual foi o número de passos necessários para gerar um valor de \\(X\\)? Compare com o valor real.\nCrie uma função para gerar uma amostra de tamanho \\(n\\) de \\(X\\).\nQual foi o número médio de passos necessários para gerar a amostra de tamanho \\(n\\)?\nCompare a distribuição empírica dos valores simulados com a distribuição real de \\(X\\).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "7_transf.html",
    "href": "7_transf.html",
    "title": "9  Transformação e Misturas",
    "section": "",
    "text": "9.1 Transformação de V.A.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Transformação e Misturas</span>"
    ]
  },
  {
    "objectID": "7_transf.html#transformação-de-v.a.",
    "href": "7_transf.html#transformação-de-v.a.",
    "title": "9  Transformação e Misturas",
    "section": "",
    "text": "Queremos simular valores da variável aleatória \\(X\\)\nSabemos simular valores da variável aleatória \\(Y\\)\nIdeia: Se existe uma função \\(g : \\mathbb{R} \\to \\mathbb{R}\\) tal que \\(X = g(Y)\\), então para simular um valor de \\(X\\) basta fazer:\n\nSimular \\(Y\\)\nFazer \\(X = g(Y)\\)\n\n\n\n\n9.1.1 Exemplo 1: Transformação para Distribuição de Weibull\nSeja \\(X\\) uma variável aleatória com distribuição de Weibull com parâmetro de forma \\(k &gt; 0\\) e parâmetro de escala \\(\\lambda &gt; 0\\) dada por\n\\[\nf_X(x) = \\frac{k}{\\lambda^k} x^{k-1} e^{-(x/\\lambda)^k}, \\quad x &gt; 0.\n\\]\nQueremos simular valores dessa distribuição. Para isso, utilizaremos o seguinte resultado: se \\(Y \\sim \\text{Exp}(1/\\lambda^k)\\), então \\(X = Y^{1/k} \\sim \\text{Weibull}(\\lambda, k)\\).\nDe fato, temos que \\[\nf_Y(y) = \\frac{1}{\\lambda^k} e^{-y/\\lambda^k}, \\quad y &gt; 0.\n\\] Para \\(x &gt; 0\\), \\[\nP(X \\leq x) = P(Y^{1/k} \\leq x) = P(Y \\leq x^k) = F_Y(x^k)\n\\] e \\[\nf_X(x) = \\frac{dF_Y(x^k)}{dx} = kx^{k-1} f_Y(x^k)\n\\]\n\\[\n= kx^{k-1} \\frac{1}{\\lambda^k} e^{-x^k/\\lambda^k}\n\\]\n\\[\n= \\frac{k}{\\lambda^k} x^{k-1} e^{-(x/\\lambda)^k}.\n\\]\nPseudo-Algoritmo para Transformação de Weibull\n\nGere \\(U_1 \\sim \\text{Unif}(0, 1)\\)\nFaça \\(Y = -\\lambda^k \\log U_1\\)\nFaça \\(X = Y^{1/k}\\)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Transformação e Misturas</span>"
    ]
  },
  {
    "objectID": "7_transf.html#misturas",
    "href": "7_transf.html#misturas",
    "title": "9  Transformação e Misturas",
    "section": "9.2 Misturas",
    "text": "9.2 Misturas\n\nQueremos simular valores da variável aleatória \\(X\\)\nSuponha que sabemos simular valores da variável aleatória \\(Y\\) e de \\(X | Y\\) e suponha que:\n\n\\[\nf_X(x) = \\int_{-\\infty}^{\\infty} f_{X|Y}(x|y) f_Y(y) dy \\quad \\text{(caso contínuo)}\n\\] \\[\nf_X(x) = \\sum_y p_{X|Y}(x|y) p_Y(y) \\quad \\text{(caso discreto)}\n\\]\nDizemos que \\(f_X\\) é uma distribuição de mistura. Para simular um valor de \\(X\\), fazemos: 1. Simular \\(y\\) de \\(f_Y\\) 2. Simular \\(X\\) de \\(f_{X|Y=y}\\)\n\n\n9.2.1 Exemplo 2: de Misturas para t-student\nSeja \\(X \\sim t_k\\). Queremos simular um valor de \\(X\\).\nPodemos escrever a densidade de \\(X\\) fazendo \\(X | Y = y \\sim N(0, k/y)\\) e \\(Y \\sim \\chi^2_k\\). Vamos verificar essa afirmação. Temos que\n\\[\nf_{X|Y=y}(x|y) = \\frac{1}{\\sqrt{k/y} \\sqrt{2\\pi}} e^{-\\frac{y}{2k} x^2}\n\\]\ne\n\\[\nf_Y(y) = \\frac{1}{2^{k/2} \\Gamma(k/2)} y^{k/2 - 1} e^{-y/2}.\n\\]\nLogo,\n\\[\nf_X(x) = \\int_{-\\infty}^{\\infty} f_{X|Y}(x|y) f_Y(y) dy\n\\]\n\\[\n= \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{k/y} \\sqrt{2\\pi}} e^{-\\frac{y}{2k} x^2} \\frac{1}{2^{k/2} \\Gamma(k/2)} y^{k/2 - 1} e^{-y/2} dy\n\\]\n\\[\n= \\frac{1}{\\sqrt{k} \\sqrt{2\\pi}} \\frac{1}{2^{k/2} \\Gamma(k/2)} \\int_{-\\infty}^{\\infty} y^{k/2 + 1/2 - 1} e^{-y(x^2/2k + 1/2)} dy\n\\]\n\\[\n= \\frac{1}{\\sqrt{k} \\sqrt{2\\pi}} \\frac{1}{2^{k/2} \\Gamma(k/2)} \\frac{\\Gamma(k/2 + 1/2)}{(x^2/2k + 1/2)^{(k+1)/2}}\n\\]\n\\[\n= \\frac{\\Gamma(k/2 + 1/2)}{\\Gamma(k/2)} \\frac{1}{\\sqrt{k \\pi}} \\frac{1}{(x^2/k + 1)^{(k+1)/2}}.\n\\]\nEntão, \\(X \\sim t_k\\).\nPseudo-Algoritmo para Gerar Dados de uma t-student:\n\nGere \\(y\\) de \\(\\chi^2_k\\)\nGere \\(X\\) da \\(N(0, k/y)\\)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Transformação e Misturas</span>"
    ]
  },
  {
    "objectID": "7_transf.html#exercícios",
    "href": "7_transf.html#exercícios",
    "title": "9  Transformação e Misturas",
    "section": "9.3 Exercícios",
    "text": "9.3 Exercícios\n\nSimular uma amostra de tamanho 1000 de Weibull usando o pseudo-algoritmo do Exemplo 1.\n\nCompare os valores simulados com a densidade da Weibull usando uma amostra gerada pelo Python ou R.\n\nSimular uma amostra de tamanho 1000 de um t-student usando o pseudo-algoritmo do Exemplo 2.\n\nCompare os valores simulados com a densidade da t-Student usando uma amostra gerada pelo Python ou R.\n\nConsidere a seguinte relação entre as distribuições de Poisson e Exponencial: Se \\(N \\sim \\text{Poisson}(\\lambda)\\), e \\(X_i \\sim \\text{Exp}(\\lambda)\\), então a soma dos \\(X_i\\) satisfaz: \\[\nP(N = k) = P\\left(X_1 + \\cdots + X_k \\leq 1 &lt; X_1 + \\cdots + X_{k+1}\\right).\n\\]\n\n\nImplemente um algoritmo para gerar amostras de tamanho 1000 de uma variável \\(N \\sim \\text{Poisson}(\\lambda)\\) utilizando o resultado anterior.\nEscolha um valor de \\(\\lambda = 5\\) e simule 1000 valores de \\(N\\).\nCompare os valores simulados com a densidade da t-Student usando uma amostra gerada pelo Python ou R.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Transformação e Misturas</span>"
    ]
  },
  {
    "objectID": "8_box_muller.html",
    "href": "8_box_muller.html",
    "title": "10  Método de Box-Muller",
    "section": "",
    "text": "10.1 Representação em Coordenadas Polares\nConsidere duas variáveis aleatórias \\(X \\sim N(0, 1)\\) e \\(Y \\sim N(0, 1)\\), independentes entre si. No plano cartesiano, podemos representar o ponto \\((X, Y)\\) e explorar sua distribuição em coordenadas polares \\((R, \\Theta)\\), onde \\(R\\) representa a distância do ponto à origem e \\(\\Theta\\) é o ângulo formado com o eixo horizontal.\nAs relações trigonométricas para \\(\\Theta\\) são dadas por:\n\\[\n\\sin \\Theta = \\frac{\\text{cateto oposto}}{\\text{hipotenusa}}\n\\]\n\\[\n\\cos \\Theta = \\frac{\\text{cateto adjacente}}{\\text{hipotenusa}}\n\\]\nPara \\((X, Y)\\) normalmente distribuído, queremos expressá-lo em coordenadas polares, de modo que:\n\\[\n\\sin \\Theta = \\frac{Y}{R}\n\\]\n\\[\n\\cos \\Theta = \\frac{X}{R}\n\\]\nDessa forma, obtemos:\n\\[\nX = R \\cos \\Theta \\quad \\text{e} \\quad Y = R \\sin \\Theta\n\\]\nAlém disso, temos que:\n\\[\nR^2 = X^2 + Y^2\n\\]",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Método de Box-Muller</span>"
    ]
  },
  {
    "objectID": "8_box_muller.html#representação-em-coordenadas-polares",
    "href": "8_box_muller.html#representação-em-coordenadas-polares",
    "title": "10  Método de Box-Muller",
    "section": "",
    "text": "Representação em Coordenadas Polares",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Método de Box-Muller</span>"
    ]
  },
  {
    "objectID": "8_box_muller.html#transformação-de-variáveis",
    "href": "8_box_muller.html#transformação-de-variáveis",
    "title": "10  Método de Box-Muller",
    "section": "10.2 Transformação de Variáveis",
    "text": "10.2 Transformação de Variáveis\nAs variáveis \\(R\\) e \\(\\Theta\\) podem ser obtidas a partir de uma transformação das variáveis \\((X, Y)\\). A função de densidade conjunta de \\((R, \\Theta)\\) é dada por:\n\\[\nf_{R, \\Theta}(r, \\theta) = f_{X, Y}(h_1(r, \\theta), h_2(r, \\theta)) |J_h(r, \\theta)|\n\\]\nonde \\(J_h(r, \\theta)\\) é o Jacobiano referente às funções \\(h_1\\) e \\(h_2\\), sendo essas funções as transformações inversas que expressam \\(X\\) e \\(Y\\) em termos de \\(R\\) e \\(\\Theta\\). Esse Jacobiano pode ser calculado pelo determinante:\n\\[\nJ_h(r, \\theta) =\n\\begin{vmatrix}\n\\frac{\\partial h_1}{\\partial r} & \\frac{\\partial h_1}{\\partial \\theta} \\\\\n\\frac{\\partial h_2}{\\partial r} & \\frac{\\partial h_2}{\\partial \\theta} \\\\\n\\end{vmatrix}\n\\]\nNeste caso, o Jacobiano é dado por:\n\\[\nJ_h(r, \\theta) =\n\\begin{vmatrix}\n\\cos \\theta & -r \\sin \\theta \\\\\n\\sin \\theta & r \\cos \\theta \\\\\n\\end{vmatrix} = r(\\cos^2 \\theta + \\sin^2 \\theta) = r\n\\]\nCom o Jacobiano, a densidade conjunta é:\n\\[\nf_{R, \\Theta}(r, \\theta) = f_{X, Y}(r \\cos \\theta, r \\sin \\theta) |J_h(r, \\theta)| = \\frac{1}{2\\pi} e^{-\\frac{1}{2}(r^2)} r,\n\\] para \\(0 &lt; r &lt; \\infty, \\, 0 &lt; \\theta &lt; 2\\pi\\).\nAssim, obtemos que:\n\\[\nf_{\\Theta}(\\theta) = \\frac{1}{2\\pi}, \\quad 0 &lt; \\theta &lt; 2\\pi\n\\]\n\\[\nf_R(r) = r e^{-r^2/2}, \\quad 0 &lt; r &lt; \\infty\n\\]\nLogo, \\(\\Theta \\sim \\text{Unif}(0, 2\\pi)\\) e \\(R \\sim \\text{Rayleigh}(1)\\), sendo \\(R\\) e \\(\\Theta\\) independentes.\nAlém disso, sabe-se que se \\(R \\sim \\text{Rayleigh}(1)\\), então \\(R^2 \\sim \\chi^2_2\\) (exercício). Se \\(R^2 \\sim \\chi^2_2\\), então \\(R^2 \\sim \\text{Exp}(1/2)\\) (exercício). Portanto:\n\\[\n\\Theta \\sim \\text{Unif}(0, 2\\pi) \\quad \\text{e} \\quad R^2 \\sim \\text{Exp}(1/2)\n\\]",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Método de Box-Muller</span>"
    ]
  },
  {
    "objectID": "8_box_muller.html#resumindo",
    "href": "8_box_muller.html#resumindo",
    "title": "10  Método de Box-Muller",
    "section": "10.3 Resumindo",
    "text": "10.3 Resumindo\nConsiderando \\(X \\sim N(0, 1)\\) e \\(Y \\sim N(0, 1)\\), variáveis independentes, podemos expressá-las em termos das coordenadas polares \\((R, \\Theta)\\), onde:\n\\[\nX = R \\cos \\Theta \\quad \\text{e} \\quad Y = R \\sin \\Theta\n\\]\nCom essa transformação, obtemos que \\(\\Theta\\) tem distribuição uniforme no intervalo \\((0, 2\\pi)\\) e que \\(R^2\\) segue uma distribuição exponencial com parâmetro \\(1/2\\):\n\\[\n\\Theta \\sim \\text{Unif}(0, 2\\pi) \\quad \\text{e} \\quad R^2 \\sim \\text{Exp}(1/2)\n\\]\nAlém disso, as variáveis \\(R^2\\) e \\(\\Theta\\) são independentes.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Método de Box-Muller</span>"
    ]
  },
  {
    "objectID": "8_box_muller.html#como-gerar-r2-e-theta",
    "href": "8_box_muller.html#como-gerar-r2-e-theta",
    "title": "10  Método de Box-Muller",
    "section": "10.4 Como Gerar \\(R^2\\) e \\(\\Theta\\)",
    "text": "10.4 Como Gerar \\(R^2\\) e \\(\\Theta\\)\nPara obter valores de \\(R^2\\) e \\(\\Theta\\) de acordo com as distribuições acima, podemos seguir estes passos:\n\nPrimeiramente, geramos duas variáveis uniformes independentes \\(U_1 \\sim \\text{Unif}(0, 1)\\) e \\(U_2 \\sim \\text{Unif}(0, 1)\\).\nEm seguida, calculamos \\(R^2 = -2 \\log U_1\\) e \\(\\Theta = 2\\pi U_2\\).\n\nEssa abordagem nos permite obter \\(R^2\\) e \\(\\Theta\\) de acordo com as distribuições desejadas.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Método de Box-Muller</span>"
    ]
  },
  {
    "objectID": "8_box_muller.html#simulação---distribuição-normal",
    "href": "8_box_muller.html#simulação---distribuição-normal",
    "title": "10  Método de Box-Muller",
    "section": "10.5 Simulação - Distribuição Normal",
    "text": "10.5 Simulação - Distribuição Normal\nPara gerar duas variáveis independentes \\(X\\) e \\(Y\\), ambas com distribuição \\(N(0, 1)\\), utilizamos o método de Box-Muller. O procedimento é o seguinte:\n\nPrimeiramente, geramos duas variáveis uniformes independentes \\(U_1 \\sim \\text{Unif}(0, 1)\\) e \\(U_2 \\sim \\text{Unif}(0, 1)\\).\nEm seguida, aplicamos as fórmulas \\(X = \\sqrt{-2 \\log U_1} \\cos(2\\pi U_2)\\) e \\(Y = \\sqrt{-2 \\log U_1} \\sin(2\\pi U_2)\\).\n\nO método de Box-Muller permite que convertemos variáveis uniformes em variáveis com distribuição normal padrão, mantendo a independência entre \\(X\\) e \\(Y\\).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Método de Box-Muller</span>"
    ]
  },
  {
    "objectID": "8_box_muller.html#exercícios",
    "href": "8_box_muller.html#exercícios",
    "title": "10  Método de Box-Muller",
    "section": "10.6 Exercícios",
    "text": "10.6 Exercícios\nExercício 1.\nImplemente o método de Box-Muller para gerar duas variáveis aleatórias independentes com distribuição normal \\(N(0, 1)\\) a partir de variáveis uniformes \\(U_1\\) e \\(U_2\\).\nExercício 2.\nSuponha \\(X \\sim N(0, 1)\\). Encontre a transformação para obter \\(X' \\sim N(\\mu, \\sigma^2)\\) e implemente um algorítmo que gera \\(X' \\sim N(\\mu, \\sigma^2)\\).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Método de Box-Muller</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html",
    "href": "9_monte_carlo.html",
    "title": "11  Método de Monte Carlo",
    "section": "",
    "text": "11.1 Exemplo 1: Estimativa de uma Integral\nQueremos obter uma estimativa para\n\\[\n\\theta = \\int\\limits_{0}^{1}e^{-x} dx\n\\]\nPara isso, basta observar que se \\(U \\sim Unif(0,1)\\), então \\(\\theta = \\mathbb{E}[e^{-U}]\\). De fato, se \\(U \\in Unif(0,1)\\), \\[\n\\theta=\\int\\limits_{0}^{1}e^{-x} dx= \\int\\limits_{0}^{1}e^{-u}f(u) du.\n\\] Assim, o estimador desta integral via MMC pode ser obtido da seguinte forma:\nVamos verificar como o valor de \\(n\\) influencia na aproximação:\nEsse gráfico mostra a evolução da estimativa à medida que o número de variáveis aleatórias \\(n\\) aumenta, comparando com o valor real da integral.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#exemplo-1-estimativa-de-uma-integral",
    "href": "9_monte_carlo.html#exemplo-1-estimativa-de-uma-integral",
    "title": "11  Método de Monte Carlo",
    "section": "",
    "text": "RPython\n\n\n\n\nMostrar código\nn &lt;- 100\nu &lt;- runif(n, min = 0, max = 1)\n\n# Estimativa de theta usando Monte Carlo\ntheta_hat &lt;- mean(exp(-u))\ncat(\"Estimativa de theta_hat:\", theta_hat, \"\\n\")\n\n\nEstimativa de theta_hat: 0.6474115 \n\n\nMostrar código\n# Valor real da integral\nvalor_real &lt;- 1 - exp(-1)\ncat(\"Valor real:\", valor_real, \"\\n\")\n\n\nValor real: 0.6321206 \n\n\n\n\n\n\nMostrar código\nimport numpy as np\n\n# Número de amostras\nn = 100\n\n# Geração de amostras uniformes\nu = np.random.uniform(0, 1, n)\n\n# Estimativa de theta usando Monte Carlo\ntheta_hat = np.mean(np.exp(-u))\nprint(\"Estimativa de theta_hat:\", theta_hat)\n\n\nEstimativa de theta_hat: 0.6786059595115784\n\n\nMostrar código\n# Valor real da integral\nvalor_real = 1 - np.exp(-1)\nprint(\"Valor real:\", valor_real)\n\n\nValor real: 0.6321205588285577\n\n\n\n\n\n\n\nRPython\n\n\n\n\nMostrar código\nlibrary(ggplot2)\n\nset.seed(58)\nN &lt;- 1:2000\ntheta_hat &lt;- numeric(length(N))\nu &lt;- numeric(length(N))  # Pré-alocação do vetor\n\n# Preenchendo o vetor u e calculando theta_hat\nfor (i in seq_along(N)) {\n  u[i] &lt;- runif(1)\n  theta_hat[i] &lt;- mean(exp(-u[1:i]))\n}\n\n# Criando o dataframe para o ggplot\ndf &lt;- data.frame(N = N, theta_hat = theta_hat)\n\n# Plotar o gráfico usando ggplot2\nggplot(df, aes(x = N, y = theta_hat)) +\n  geom_line(color = \"blue\") +\n  geom_hline(yintercept = 1 - exp(-1), color = \"red\", linetype = \"dashed\") +\n  labs(x = \"n\", y = expression(hat(theta)[n]), title = expression(Aproximação~de~theta)) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(58)\nN = np.arange(1, 2001, 1)\ntheta_hat = np.zeros(len(N))\nu = np.array([])\n\nfor i in range(len(N)):\n    u = np.append(u, np.random.uniform(0, 1))\n    theta_hat[i] = np.mean(np.exp(-u))\n\nplt.plot(N, theta_hat)\nplt.axhline(y=1 - np.exp(-1), color='red', linestyle='--')\nplt.xlabel('n')\nplt.ylabel(r'$\\hat{\\theta}_n$')\nplt.title(r'Aproximação de $\\theta$')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#exemplo-2-aproximando-uma-probabilidade",
    "href": "9_monte_carlo.html#exemplo-2-aproximando-uma-probabilidade",
    "title": "11  Método de Monte Carlo",
    "section": "11.2 Exemplo 2: Aproximando uma Probabilidade",
    "text": "11.2 Exemplo 2: Aproximando uma Probabilidade\nSeja \\(X \\sim Gama(2,3)\\). Queremos aproximar o valor de \\(\\mathbb{P}(X \\geq 0.4)\\) usando o método de Monte Carlo. Note que \\[\\theta:= \\mathbb{P}(X \\geq 0.4) = \\int g(x)f(x)dx,\\] em que \\(g(x)=I(x \\geq 0.4)\\) e \\(f(x)\\) é a densidade da Gama(2,3). Assim, podemos aproximar a probabilidade gerada via MC.\nNeste caso, o algoritmo corresponde a gerar \\(X_i \\sim Gama(2,3)\\), defir e definir uma variável indicadora \\(Y_i\\) que vale 1 quando \\(X_i \\geq 0.4\\) e 0 caso contrário. A estimativa de Monte Carlo é dada pela média dos \\(Y_i\\)’s:\n\nRPython\n\n\n\n\nMostrar código\nset.seed(58)\nlibrary(ggplot2)\n\n# Número de amostras\nN &lt;- 50000\n\n# Geração de amostras da distribuição Gamma\nx &lt;- rgamma(N, shape = 2, rate = 3)  # Usando rate = 1/scale\n\n# Cálculo de P(X &gt;= 0.4)\ny &lt;- as.integer(x &gt;= 0.4)\n\n# Estimativa via Monte Carlo\nvalor_aproximado &lt;- mean(y)\ncat(\"Valor aproximado via Monte Carlo:\", valor_aproximado, \"\\n\")\n\n\nValor aproximado via Monte Carlo: 0.66282 \n\n\nMostrar código\n# Valor real usando a função de distribuição acumulada (CDF)\nvalor_real &lt;- 1 - pgamma(0.4, shape = 2, rate = 3)\ncat(\"Valor real (CDF):\", valor_real, \"\\n\")\n\n\nValor real (CDF): 0.6626273 \n\n\n\n\n\n\nMostrar código\nimport numpy as np\nfrom scipy.stats import gamma\n\n# Número de amostras\nN = 50000\n\n# Geração de amostras da distribuição Gamma\nx = gamma.rvs(2, scale=1/3, size=N)\n\n# Cálculo de P(X &gt;= 0.4)\ny = (x &gt;= 0.4).astype(int)\n\n# Estimativa via Monte Carlo\nvalor_aproximado = np.mean(y)\nprint(\"Valor aproximado via Monte Carlo:\", valor_aproximado)\n\n\nValor aproximado via Monte Carlo: 0.66098\n\n\nMostrar código\n# Valor real usando a função de distribuição acumulada (CDF)\nvalor_real = 1 - gamma.cdf(0.4, 2, scale=1/3)\nprint(\"Valor real (CDF):\", valor_real)\n\n\nValor real (CDF): 0.6626272662068446",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#exemplo-3-aproximando-o-valor-de-pi",
    "href": "9_monte_carlo.html#exemplo-3-aproximando-o-valor-de-pi",
    "title": "11  Método de Monte Carlo",
    "section": "11.3 Exemplo 3: Aproximando o valor de \\(\\pi\\)",
    "text": "11.3 Exemplo 3: Aproximando o valor de \\(\\pi\\)\nNeste exemplo, queremos aproximar o valor de \\(\\pi\\) utilizando o método de Monte Carlo. A ideia é gerar pontos aleatórios em um quadrado e contar quantos caem dentro de um círculo inscrito no quadrado. Vamos seguir o raciocínio a partir da geometria básica.\n\n11.3.0.1 Geometria\n\nConsidere um quadrado com lado 2 centrado na origem, ou seja, o quadrado vai de \\((-1, -1)\\) até \\((1, 1)\\).\nDentro deste quadrado, inscreva um círculo de raio 1, também centrado na origem.\nA área do quadrado é \\(4\\) (já que \\(2 \\times 2 = 4\\)) e a área do círculo é \\(\\pi \\cdot r^2 = \\pi \\cdot 1^2 = \\pi\\).\n\nA razão entre a área do círculo e a área do quadrado é dada por:\n\\[\n\\frac{\\text{Área do círculo}}{\\text{Área do quadrado}} = \\frac{\\pi}{4}\n\\]\n\nRPython\n\n\n\n\nMostrar código\nrequire(plotrix)\nrequire(grid)\n\nplot(c(-1, 1), c(-1,1), type = \"n\", asp=1,xlab=\"\",yla=\"\")\nrect( -1, -1, 1, 1,border=\"blue\") \ndraw.circle( 0, 0, 1 ,border=\"red\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle, Circle\n\n# Configura o gráfico\nfig, ax = plt.subplots()\nax.set_aspect('equal')  # Define o aspecto como 1:1 (quadrado)\nax.set_xlim(-1, 1)\n\n\n(-1.0, 1.0)\n\n\nMostrar código\nax.set_ylim(-1, 1)\n\n\n(-1.0, 1.0)\n\n\nMostrar código\nax.set_xlabel('')\nax.set_ylabel('')\n\n# Desenha o retângulo\nrect = Rectangle((-1, -1), 2, 2, edgecolor='blue', facecolor='none')\nax.add_patch(rect)\n\n# Desenha o círculo\ncircle = Circle((0, 0), 1, edgecolor='red', facecolor='none')\nax.add_patch(circle)\n\n# Mostra o gráfico\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nPara estimar \\(\\pi\\) usando Monte Carlo, procedemos da seguinte forma:\n\nGeramos pontos aleatórios \\((x, y)\\) no quadrado \\([-1, 1] \\times [-1, 1]\\).\nVerificamos se cada ponto está dentro do círculo, o que ocorre se \\(x^2 + y^2 \\leq 1\\).\nA fração de pontos que caem dentro do círculo aproxima a razão \\(\\frac{\\pi}{4}\\).\nMultiplicamos essa fração por 4 para obter uma estimativa de \\(\\pi\\).\n\n\n\n11.3.0.2 Matemática do Estimador\nFormalmente, se \\((X,Y) \\sim Unif(-1,1) \\times Unif(-1,1)\\) e \\(g(x,y)=I(\\text{(x,y) está no círculo})\\), temos que \\[\\theta:=\\int g(x,y)f(x,y) dxy =  \\frac{\\text{Área do círculo}}{\\text{Área do quadrado}} = \\frac{\\pi}{4} \\] Assim, se \\((X_i,Y_i)\\) é um ponto gerado uniformemente dentro do quadrado, o estimador de Monte Carlo para \\(\\frac{\\pi}{4}\\) é dado por: \\[\n\\hat{\\theta}_n = \\frac{1}{n} \\sum_{i=1}^n g(x_i,y_i)= \\frac{1}{n} \\sum_{i=1}^n z_i,\n\\] em que \\(z_i = 1\\) se o ponto \\(i\\) está dentro do círculo (i.e., se \\(x_i^2 + y_i^2 \\leq 1\\)) e \\(z_i = 0\\) caso contrário.\nMultiplicando por 4, obtemos a estimativa de \\(\\pi\\):\n\\[\n\\hat{\\pi}_n = 4 \\cdot \\hat{\\theta}_n = 4 \\cdot \\frac{1}{n} \\sum_{i=1}^n z_i\n\\]\nDe acordo com a Lei Forte dos Grandes Números, sabemos que:\n\\[\n\\hat{\\pi}_n \\longrightarrow \\pi \\quad \\text{(quase certamente, quando $n \\to \\infty$)}.\n\\]\nOu seja, à medida que o número de pontos simulados \\(n\\) aumenta, a estimativa \\(\\hat{\\pi}_n\\) convergirá para o valor verdadeiro de \\(\\pi\\).\nImplementação\nOs trechos de código fornecidos em R e Python simulam esse processo, gerando \\(n\\) pontos e calculando a aproximação de \\(\\pi\\) com base nos pontos que caem dentro do círculo. Além disso, são gerados gráficos que mostram como a estimativa de \\(\\pi\\) melhora conforme o número de simulações aumenta, evidenciando a convergência mencionada.\nAgora que todos os detalhes matemáticos do exemplo estão claros, o código para simulação pode ser executado para observar a aproximação prática de \\(\\pi\\).\n\nRPython\n\n\n\n\nMostrar código\nset.seed(459)\nlibrary(ggplot2)\n\nN &lt;- 1:80000\nz &lt;- numeric(length(N))\n\n# Loop para gerar os pontos e verificar se estão dentro do círculo\nfor (i in seq_along(N)) {\n  x &lt;- 2 * runif(1) - 1\n  y &lt;- 2 * runif(1) - 1\n  z[i] &lt;- (x^2 + y^2 &lt;= 1)\n}\n\n# Cálculo da estimativa de pi\ntheta_hat &lt;- cumsum(z) / N\npi_hat &lt;- theta_hat * 4\n\n# Criando o dataframe para o ggplot\ndf &lt;- data.frame(N = N, pi_hat = pi_hat)\n\n# Plotar o gráfico usando ggplot2\nggplot(df, aes(x = N, y = pi_hat)) +\n  geom_line(color = \"blue\") +\n  geom_hline(yintercept = pi, color = \"red\", linetype = \"dashed\") +\n  labs(x = \"n\", y = expression(hat(pi)[n]), title = expression(Aproximacao~de~pi)) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(459)\nN = np.arange(1, 80001, 1)\nz = np.zeros(len(N))\n\nfor i in range(len(N)):\n    x = 2 * np.random.uniform(0, 1) - 1\n    y = 2 * np.random.uniform(0, 1) - 1\n    z[i] = (x**2 + y**2 &lt;= 1)\n\ntheta_hat = np.cumsum(z) / N\npi_hat = theta_hat * 4\n\nplt.plot(N, pi_hat)\nplt.axhline(y=np.pi, color='red', linestyle='--')\nplt.xlabel('n')\nplt.ylabel(r'$\\hat{\\pi}_n$')\nplt.title(r'Aproximação de $\\pi$')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nEsse gráfico mostra como a estimativa de \\(\\pi\\) melhora conforme o número de pontos simulados \\(n\\) aumenta.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#intervalos-de-confiança-para-estimativas-de-monte-carlo",
    "href": "9_monte_carlo.html#intervalos-de-confiança-para-estimativas-de-monte-carlo",
    "title": "11  Método de Monte Carlo",
    "section": "11.4 Intervalos de Confiança para Estimativas de Monte Carlo",
    "text": "11.4 Intervalos de Confiança para Estimativas de Monte Carlo\nO Método de Monte Carlo possibilita quantificar a incerteza em nossas estimativas. Para isso, podemos utilizar intervalos de confiança.\nSuponha que temos uma sequência de amostras \\(X_1, X_2, \\dots, X_n\\) de uma variável aleatória \\(X\\), e calculamos a média amostral \\(\\hat{\\theta}_n = \\frac{1}{n} \\sum_{i=1}^n g(X_i)\\). Pelo Teorema Central do Limite, sabemos que, para \\(n\\) suficientemente grande, a média amostral \\(\\hat{\\theta}_n\\) é aproximadamente normalmente distribuída:\n\\[\n\\hat{\\theta}_n \\sim N\\left( \\theta, \\frac{\\sigma^2}{n} \\right)\n\\]\nonde \\(\\sigma^2 = \\text{Var}[g(X)]\\) é a variância de \\(g(X)\\). Essa aproximação permite a construção de um intervalo de confiança para \\(\\theta\\).\nO intervalo de confiança aproximado para \\(\\theta\\) com nível de confiança \\((1 - \\alpha) \\times 100\\%\\) é dado por:\n\\[\n\\hat{\\theta}_n \\pm z_{\\alpha/2} \\frac{\\hat{\\sigma}}{\\sqrt{n}}\n\\]\nonde \\(z_{\\alpha/2}\\) é o quantil da distribuição normal padrão associado à probabilidade \\(\\alpha/2\\) e \\(\\hat{\\sigma}\\) é a estimativa da variância de \\(g(X)\\), obtida a partir das amostras.\nPseudo-Algoritmo para construir um intervalo de confiança:\n\nGere \\(X_1, \\dots, X_n\\) amostras i.i.d. da v.a. \\(X\\).\nCalcule \\(\\hat{\\theta}_n = \\frac{1}{n} \\sum_{i=1}^n g(X_i)\\).\nEstime a variância de \\(g(X)\\) como: \\[\n\\hat{\\sigma}^2 = \\frac{1}{n} \\sum_{i=1}^n (g(X_i) - \\hat{\\theta}_n)^2\n\\]\nCalcule o intervalo de confiança: \\[\n\\hat{\\theta}_n \\pm z_{\\alpha/2} \\frac{\\hat{\\sigma}}{\\sqrt{n}}\n\\]\n\n\n11.4.1 Exemplo: Intervalo de Confiança para a Estimativa de \\(\\pi\\)\nNeste exemplo, construímos um intervalo de confiança para a estimativa de \\(\\pi\\) usando o método de Monte Carlo, seguindo os passos acima.\n\nRPython\n\n\n\n\nMostrar código\nset.seed(0)\nN &lt;- 10000  # número de amostras\nz &lt;- numeric(N)\n\n# Loop para gerar os pontos e verificar se estão dentro do círculo\nfor (i in 1:N) {\n  x &lt;- 2 * runif(1) - 1\n  y &lt;- 2 * runif(1) - 1\n  z[i] &lt;- (x^2 + y^2 &lt;= 1)\n}\n\n# Estimativa de pi\ntheta_hat &lt;- mean(z)\npi_hat &lt;- theta_hat * 4\ncat(\"Estimativa de pi:\", pi_hat, \"\\n\")\n\n\nEstimativa de pi: 3.1308 \n\n\nMostrar código\n# Cálculo da variância e intervalo de confiança\nsigma_hat &lt;- sqrt(var(z) / N)\nalpha &lt;- 0.05  # Nível de significância\nz_alpha2 &lt;- qnorm(1 - alpha / 2)\n\n# Intervalo de confiança\nIC &lt;- c(theta_hat - z_alpha2 * sigma_hat, theta_hat + z_alpha2 * sigma_hat) * 4\ncat(\"Intervalo de confiança para pi:\", IC, \"\\n\")\n\n\nIntervalo de confiança para pi: 3.098466 3.163134 \n\n\n\n\n\n\nMostrar código\nimport numpy as np\nfrom scipy.stats import norm\n\n# Semente para reprodução\nnp.random.seed(0)\nN = 10000  # número de amostras\nz = np.zeros(N)\n\n# Loop para gerar os pontos e verificar se estão dentro do círculo\nfor i in range(N):\n    x = 2 * np.random.uniform(0, 1) - 1\n    y = 2 * np.random.uniform(0, 1) - 1\n    z[i] = (x**2 + y**2 &lt;= 1)\n\n# Estimativa de pi\ntheta_hat = np.mean(z)\npi_hat = theta_hat * 4\nprint(\"Estimativa de pi:\", pi_hat)\n\n\nEstimativa de pi: 3.1228\n\n\nMostrar código\n# Cálculo da variância e intervalo de confiança\nsigma_hat = np.sqrt(np.var(z) / N)\nalpha = 0.05  # Nível de significância\nz_alpha2 = norm.ppf(1 - alpha / 2)\n\n# Intervalo de confiança\nIC = (theta_hat - z_alpha2 * sigma_hat, theta_hat + z_alpha2 * sigma_hat)\nIC = [i * 4 for i in IC]\n\nprint(\"Intervalo de confiança para pi:\", IC)\n\n\nIntervalo de confiança para pi: [np.float64(3.090360848359833), np.float64(3.1552391516401666)]\n\n\n\n\n\nNeste caso, o intervalo de confiança construído em torno da estimativa \\(\\hat{\\pi}_n\\) oferece uma ideia de quão próxima nossa estimativa está do valor verdadeiro de \\(\\pi\\), com uma certa confiança.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#exemplo-4-problema-das-figurinhas",
    "href": "9_monte_carlo.html#exemplo-4-problema-das-figurinhas",
    "title": "11  Método de Monte Carlo",
    "section": "11.5 Exemplo 4: Problema das Figurinhas",
    "text": "11.5 Exemplo 4: Problema das Figurinhas\nUm colecionador está juntando figurinhas para completar um álbum da Copa. Qual é a probabilidade de que, ao comprar \\(n\\) pacotes, pelo menos um deles contenha duas ou mais figurinhas iguais? Durante o curso de probabilidade, você aprenderá como calcular essa probabilidade. Outra abordagem possível é o uso do método de Monte Carlo. Nesse caso, simulamos a compra de \\(n\\) pacotes, cada um com 5 figurinhas, de um total de 640 figurinhas disponíveis no álbum. Repetimos essa simulação \\(B=1000\\) vezes e contamos quantas vezes ocorreu pelo menos uma repetição de figurinhas em algum dos pacotes. A proporção de simulações com repetições é a estimativa de Monte Carlo da probabilidade que estamos interessados em calcular.\n\nRPython\n\n\n\n\nMostrar código\nnFigurinhas &lt;- 640\nB &lt;- 1000\nnPacotes &lt;- 1:50\naoMenosUmaRepetidaNoMesmoPacote &lt;- matrix(NA, length(nPacotes), B)\nfor(ii in 1:length(nPacotes)) {\n  for(jj in 1:B) {\n    figurinhas &lt;- sample(1:nFigurinhas, nPacotes[ii] * 5, replace = TRUE)\n    figurinhas &lt;- matrix(figurinhas, nPacotes[ii], 5)\n    aoMenosUmaRepetidaNoMesmoPacote[ii,jj] &lt;- sum(apply(figurinhas, 1, function(xx) length(unique(xx)) != length(xx)) &gt; 0)\n  }\n}\n\nprobCoincidencia &lt;- apply(aoMenosUmaRepetidaNoMesmoPacote, 1, mean)\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport random\n\nnFigurinhas = 640\nB = 1000\nnPacotes = np.arange(1, 51)  # Intervalo de 1 a 50 (Python é exclusivo no final)\naoMenosUmaRepetidaNoMesmoPacote = np.empty((len(nPacotes), B))\n\nfor ii in range(len(nPacotes)):\n    for jj in range(B):\n        figurinhas = [random.choices(range(1, nFigurinhas + 1), k=5) for _ in range(nPacotes[ii])]\n        figurinhas = np.array(figurinhas)\n        aoMenosUmaRepetidaNoMesmoPacote[ii, jj] = np.sum([len(set(pacote)) != len(pacote) for pacote in figurinhas])\n\nprobCoincidencia = np.mean(aoMenosUmaRepetidaNoMesmoPacote, axis=1)\n\n\n\n\n\nAgora podemos visualizar os resultados obtidos por meio do gráfico a seguir:\n\nRPython\n\n\n\n\nMostrar código\ndados &lt;- data.frame(probCoincidencia = probCoincidencia, nPacotes = nPacotes)\n\nlibrary(ggplot2)\nggplot(dados, aes(x = nPacotes, y = probCoincidencia)) +\n  geom_point(aes(size = 1.1)) +\n  xlab(\"Número de Pacotes\") +\n  ylab(\"Prob de ao menos 1 repetida no mesmo pacote\") + \n  theme(legend.position = \"none\")+\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Criação do DataFrame\ndados = pd.DataFrame({'nPacotes': nPacotes, 'probCoincidencia': probCoincidencia})\n\n# Criação do gráfico\nplt.figure(figsize=(8, 6))\nplt.scatter(dados['nPacotes'], dados['probCoincidencia'], s=70)  # 's' ajusta o tamanho dos pontos\nplt.xlabel('Número de Pacotes')\nplt.ylabel('Prob de ao menos 1 repetida no mesmo pacote')\nplt.grid(True, which='both', linestyle='--', linewidth=0.7)\nplt.gca().set_facecolor('white')  # Para seguir o tema minimalista\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nSimulação para completar o álbum\nUma segunda pergunta que também podemos responder via simulação é: quantos pacotes necessitamos em média para completar o álbum? A solução estimada pode ser obtida com o código abaixo:\n\nRPython\n\n\n\n\nMostrar código\nnumeroPacotes &lt;- rep(NA, B)\nfor(jj in 1:B) {\n  albumCompleto &lt;- FALSE\n  nPacotes &lt;- 0\n  figurinhas &lt;- NULL\n  while(!albumCompleto) {\n    figurinhas &lt;- c(figurinhas, sample(1:nFigurinhas, 5, replace = TRUE))\n    if(length(unique(figurinhas)) == nFigurinhas) {\n      albumCompleto &lt;- TRUE\n    }\n    nPacotes &lt;- nPacotes + 1\n  }\n  numeroPacotes[jj] &lt;- nPacotes\n}\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport random\n\nnFigurinhas = 640\nB = 1000\nnumeroPacotes = np.empty(B)\n\nfor jj in range(B):\n    albumCompleto = False\n    nPacotes = 0\n    figurinhas = []\n\n    while not albumCompleto:\n        figurinhas.extend(random.choices(range(1, nFigurinhas + 1), k=5))\n        if len(set(figurinhas)) == nFigurinhas:\n            albumCompleto = True\n        nPacotes += 1\n\n    numeroPacotes[jj] = nPacotes\n\n\n\n\n\nO número médio de pacotes necessários para completar o álbum é:\n\nRPython\n\n\n\n\nMostrar código\nmean(numeroPacotes)\n\n\n[1] 901.629\n\n\n\n\n\n\nMostrar código\nmean_numeroPacotes = np.mean(numeroPacotes)\nmean_numeroPacotes\n\n\nnp.float64(897.579)\n\n\n\n\n\nCom essa simulação, também podemos estimar as seguintes probabilidades:\n\nRPython\n\n\n\n\nMostrar código\ncat(\"Probabilidade de precisar de mais de 800 pacotes: \", mean(numeroPacotes &gt; 800) * 100, \"%\", sep = \"\")\n\n\nProbabilidade de precisar de mais de 800 pacotes: 69.3%\n\n\nMostrar código\ncat(\"Probabilidade de precisar de mais de 1000 pacotes: \", mean(numeroPacotes &gt; 1000) * 100, \"%\", sep = \"\")\n\n\nProbabilidade de precisar de mais de 1000 pacotes: 23.2%\n\n\n\n\n\n\nMostrar código\nprob_mais_800 = np.mean(numeroPacotes &gt; 800) * 100\nprob_mais_1000 = np.mean(numeroPacotes &gt; 1000) * 100\n\nprint(f\"Probabilidade de precisar de mais de 800 pacotes: {prob_mais_800}%\")\n\n\nProbabilidade de precisar de mais de 800 pacotes: 69.19999999999999%\n\n\nMostrar código\nprint(f\"Probabilidade de precisar de mais de 1000 pacotes: {prob_mais_1000}%\")\n\n\nProbabilidade de precisar de mais de 1000 pacotes: 22.1%",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#exercícios",
    "href": "9_monte_carlo.html#exercícios",
    "title": "11  Método de Monte Carlo",
    "section": "11.6 Exercícios",
    "text": "11.6 Exercícios\nExercício 1.\nUtilize o método de Monte Carlo para aproximar a integral \\[\nI = \\int_0^{10} \\sin(x^2) \\, dx\n\\]\nForneça um intervalo de confiança para avaliar a precisão da estimativa.\nExercício 1.\nUtilize o método de Monte Carlo para aproximar a integral \\[\nI = \\int_1^{\\infty} \\frac{1}{x^3} \\, dx\n\\]\nForneça um intervalo de confiança para avaliar a precisão da estimativa.\nExercício 2.\nSeja \\(X \\sim \\text{Exp}(\\lambda)\\) com \\(\\lambda = 2\\). Estime a esperança \\(\\mathbb{E}[X^2]\\) utilizando o método de Monte Carlo. Forneça um intervalo de confiança para avaliar a precisão da estimativa. Compare com o valor real dessa quantidade.\nExercício 3.\nConsidere que \\(X\\) tem distribuição Normal(0,1) e \\(Y\\) tem distribuição Gamma(1,1). Estime \\(P(X\\times Y &gt; 3)\\). Forneça um intervalo de confiança para avaliar a precisão da estimativa.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "10_var_red.html",
    "href": "10_var_red.html",
    "title": "12  Técnicas de Redução de Variância",
    "section": "",
    "text": "12.1 Exercícios\nExercício 1.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Técnicas de Redução de Variância</span>"
    ]
  },
  {
    "objectID": "11_import.html",
    "href": "11_import.html",
    "title": "13  Amostragem por Importância",
    "section": "",
    "text": "13.1 Exemplo 1: Estimativa de \\(\\mathbb{P}(Z &gt; 4.5)\\)\nNeste exemplo, vamos estimar a probabilidade \\(\\mathbb{P}(Z &gt; 4.5)\\) onde \\(Z \\sim N(0,1)\\). Este é um evento raro, com probabilidade pequena. O valor exato dessa probabilidade é: \\[\n\\log(\\mathbb{P}(Z &gt; 4.5)) = -12.59242\n\\] Aplicaremos o método de Monte Carlo simulando \\(n = 100.000\\) valores de \\(Z \\sim N(0,1)\\) e calculando a proporção dos valores que são maiores que 4.5.\nO método de Monte Carlo exige uma grande quantidade de amostras para fornecer uma estimativa precisa devido à raridade do evento \\(Z &gt; 4.5\\). A abordagem pode se tornar ineficiente para eventos raros.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Amostragem por Importância</span>"
    ]
  },
  {
    "objectID": "11_import.html#exemplo-1-estimativa-de-mathbbpz-4.5",
    "href": "11_import.html#exemplo-1-estimativa-de-mathbbpz-4.5",
    "title": "13  Amostragem por Importância",
    "section": "",
    "text": "RPython\n\n\n\n\nMostrar código\nset.seed(0)\n# Valor exato de P(Z &gt; 4.5)\nvalor_exato &lt;- log(pnorm(4.5, 0, 1, lower.tail = FALSE))\ncat(\"Valor exato (log(P(Z &gt; 4.5))):\", valor_exato, \"\\n\")\n\n\nValor exato (log(P(Z &gt; 4.5))): -12.59242 \n\n\nMostrar código\n# Simulação Monte Carlo\nn &lt;- 100000\nz &lt;- rnorm(n, 0, 1)\n\n# Estimativa Monte Carlo de P(Z &gt; 4.5)\np_estimada &lt;- mean(1 * (z &gt; 4.5))\ncat(\"Estimativa Monte Carlo de P(Z &gt; 4.5):\", p_estimada, \"\\n\")\n\n\nEstimativa Monte Carlo de P(Z &gt; 4.5): 0 \n\n\nMostrar código\n# Logaritmo da estimativa Monte Carlo\nlog_p_estimada &lt;- log(p_estimada)\ncat(\"Logaritmo da estimativa Monte Carlo:\", log_p_estimada, \"\\n\")\n\n\nLogaritmo da estimativa Monte Carlo: -Inf \n\n\n\n\n\n\nMostrar código\nimport numpy as np\nfrom scipy.stats import norm\n\n# Valor exato de P(Z &gt; 4.5)\nvalor_exato = np.log(norm.sf(4.5))  # sf is the survival function, equivalent to (1 - cdf)\nprint(f\"Valor exato (log(P(Z &gt; 4.5))): {valor_exato}\")\n\n\nValor exato (log(P(Z &gt; 4.5))): -12.592419735713081\n\n\nMostrar código\n# Simulação Monte Carlo\nn = 100000\nz = np.random.normal(0, 1, n)\n\n# Estimativa Monte Carlo de P(Z &gt; 4.5)\np_estimada = np.mean(z &gt; 4.5)\nprint(f\"Estimativa Monte Carlo de P(Z &gt; 4.5): {p_estimada}\")\n\n\nEstimativa Monte Carlo de P(Z &gt; 4.5): 0.0\n\n\nMostrar código\n# Logaritmo da estimativa Monte Carlo\nlog_p_estimada = np.log(p_estimada)\nprint(f\"Logaritmo da estimativa Monte Carlo: {log_p_estimada}\")\n\n\nLogaritmo da estimativa Monte Carlo: -inf",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Amostragem por Importância</span>"
    ]
  },
  {
    "objectID": "11_import.html#amostragem-por-importância",
    "href": "11_import.html#amostragem-por-importância",
    "title": "13  Amostragem por Importância",
    "section": "13.2 Amostragem por Importância",
    "text": "13.2 Amostragem por Importância\nA Amostragem por Importância é uma técnica que nos permite simular valores \\(Y_1, \\dots, Y_n\\) a partir de uma densidade auxiliar \\(g(y)\\).\nA ideia chave é que, se \\(X\\) tem densidade \\(f(x)\\), a esperança \\(\\mathbb{E}[h(X)]\\) pode ser reescrita como:\n\\[\n\\mathbb{E}[h(X)] = \\int h(x) f(x) dx = \\int h(x) \\frac{f(x)}{g(x)} g(x) dx = \\mathbb{E}\\left[ h(Y) \\frac{f(Y)}{g(Y)} \\right],\n\\] em que \\(Y\\) tem densidade \\(g\\). Isso vale desde que \\(g\\) possua suporte tão ou mais amplo que \\(f(x)\\). Assim, podemos estimar \\(\\mathbb{E}[h(X)]\\) usando \\(n\\) valores simulados de \\(Y\\) independentemente pela fórmula:\n\\[\n\\hat\\theta_n = \\frac{1}{n}\\sum_{i=1}^n \\frac{f(y_i)}{g(y_i)} h(y_i)\n\\]\nNote que os pesos \\(w_i = \\frac{f(y_i)}{g(y_i)}\\) ajustam a importância de cada amostra, tornando a simulação mais eficiente.\n\n13.2.1 Revistando o Exemplo 1 via Amostragem por Importância\nPara melhorar a eficiência no Exemplo 1, vamos agora usar Amostragem por Importância. Em vez de simular diretamente de \\(Z \\sim N(0,1)\\), simulamos de uma distribuição exponencial truncada \\(Exp(1)\\) a partir de 4.5. A densidade de importância é: \\[\ng(y) = e^{-(y - 4.5)}, \\quad y &gt; 4.5\n\\]\nO estimador de Monte Carlo ponderado é, portanto, \\[\n\\hat{\\theta}_n = \\frac{1}{n} \\sum_{i=1}^n \\frac{f(y_i)}{g(y_i)}I(y_i&gt;4.5)=\\frac{1}{n} \\sum_{i=1}^n \\frac{f(y_i)}{g(y_i)},\n\\] onde \\(f(y_i)\\) é a densidade da normal \\(N(0,1)\\). Aqui está o código equivalente em Python no formato solicitado:\n\nRPython\n\n\n\n\nMostrar código\nn &lt;- 100\n# Gerar n valores da distribuição exponencial truncada\ny &lt;- rexp(n) + 4.5\n\n# Estimativa por importância\nestimativa_importancia &lt;- mean(dnorm(y) / exp(-(y - 4.5)))\ncat(\"Estimativa por amostragem por importância:\", estimativa_importancia, \"\\n\")\n\n\nEstimativa por amostragem por importância: 3.723979e-06 \n\n\nMostrar código\n# Logaritmo da estimativa por importância\nlog_estimativa_importancia &lt;- log(estimativa_importancia)\ncat(\"Logaritmo da estimativa por amostragem por importância:\", log_estimativa_importancia, \"\\n\")\n\n\nLogaritmo da estimativa por amostragem por importância: -12.50072 \n\n\n\n\n\n\nMostrar código\nimport numpy as np\nfrom scipy.stats import expon, norm\n\nn = 100\n# Gerar n valores da distribuição exponencial truncada\ny = expon.rvs(scale=1, size=n) + 4.5\n\n# Estimativa por importância\nestimativa_importancia = np.mean(norm.pdf(y) / np.exp(-(y - 4.5)))\nprint(f\"Estimativa por amostragem por importância: {estimativa_importancia}\")\n\n\nEstimativa por amostragem por importância: 2.848612343461181e-06\n\n\nMostrar código\n# Logaritmo da estimativa por importância\nlog_estimativa_importancia = np.log(estimativa_importancia)\nprint(f\"Logaritmo da estimativa por amostragem por importância: {log_estimativa_importancia}\")\n\n\nLogaritmo da estimativa por amostragem por importância: -12.768678579287728\n\n\n\n\n\nCom essa técnica, concentramos as simulações na região relevante, melhorando a eficiência da estimativa para eventos raros.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Amostragem por Importância</span>"
    ]
  },
  {
    "objectID": "11_import.html#exemplo-2-estimativa-de-mathbbesqrtx-com-amostragem-por-importância",
    "href": "11_import.html#exemplo-2-estimativa-de-mathbbesqrtx-com-amostragem-por-importância",
    "title": "13  Amostragem por Importância",
    "section": "13.3 Exemplo 2: Estimativa de \\(\\mathbb{E}[\\sqrt{X}]\\) com Amostragem por Importância",
    "text": "13.3 Exemplo 2: Estimativa de \\(\\mathbb{E}[\\sqrt{X}]\\) com Amostragem por Importância\nAgora, vamos estimar \\(\\theta = \\mathbb{E}[\\sqrt{X}]\\) onde \\(X \\sim Exp(1)\\). Sabemos que o valor exato desta integral é \\(\\sqrt{\\pi}/2\\).\n\n13.3.1 Aproximação via Monte Carlo\nVamos simular \\(X \\sim Exp(1)\\) e calcular a média de \\(\\sqrt{X}\\) diretamente: Aqui está o código equivalente em Python no formato solicitado:\n\nRPython\n\n\n\n\nMostrar código\n# Valor exato da integral\nreal &lt;- sqrt(pi) / 2\ncat(\"Valor exato:\", real, \"\\n\")\n\n\nValor exato: 0.8862269 \n\n\nMostrar código\n# Número de amostras\nn &lt;- 10000\n\n# Geração de amostras da distribuição exponencial\nx &lt;- rexp(n, 1)\n\n# Estimativa Monte Carlo para E[sqrt(X)]\nestimativa_mc &lt;- mean(sqrt(x))\ncat(\"Estimativa Monte Carlo de E[sqrt(X)]:\", estimativa_mc, \"\\n\")\n\n\nEstimativa Monte Carlo de E[sqrt(X)]: 0.8842487 \n\n\nMostrar código\n# Variância da estimativa\nvariancia_mc &lt;- var(sqrt(x))\ncat(\"Variância da estimativa:\", variancia_mc, \"\\n\")\n\n\nVariância da estimativa: 0.2075346 \n\n\n\n\n\n\nMostrar código\nimport numpy as np\nfrom scipy.stats import expon\n\n# Valor exato da integral\nreal = np.sqrt(np.pi) / 2\nprint(f\"Valor exato: {real}\")\n\n\nValor exato: 0.8862269254527579\n\n\nMostrar código\n# Número de amostras\nn = 10000\n\n# Geração de amostras da distribuição exponencial\nx = expon.rvs(scale=1, size=n)\n\n# Estimativa Monte Carlo para E[sqrt(X)]\nestimativa_mc = np.mean(np.sqrt(x))\nprint(f\"Estimativa Monte Carlo de E[sqrt(X)]: {estimativa_mc}\")\n\n\nEstimativa Monte Carlo de E[sqrt(X)]: 0.8907422900057224\n\n\nMostrar código\n# Variância da estimativa\nvariancia_mc = np.var(np.sqrt(x), ddof=1)\nprint(f\"Variância da estimativa: {variancia_mc}\")\n\n\nVariância da estimativa: 0.22115247298543445\n\n\n\n\n\n\n\n13.3.2 Aproximação via Amostragem por Importância\nAgora, vamos usar a Amostragem por Importância com duas distribuições diferentes para melhorar a eficiência.\n\nUsando \\(Y = |Z|\\), onde \\(Z \\sim N(0,1)\\):\n\nA densidade de importância combinada é: \\[\ng(y) = dnorm(y) + dnorm(-y)\n\\]\n\n\nMostrar código\n# Gerando amostras de uma distribuição normal absoluta\nz &lt;- abs(rnorm(n))\n\n# Função de densidade combinada g(x)\ng &lt;- function(x) {\n  return(dnorm(x) + dnorm(-x))\n}\n\n# Estimativa por amostragem por importância\nestimativa_importancia &lt;- mean((sqrt(z)) * dexp(z, 1) / g(z))\ncat(\"Estimativa por amostragem por importância:\", estimativa_importancia, \"\\n\")\n\n\nEstimativa por amostragem por importância: 1.038467 \n\n\nMostrar código\n# Variância da estimativa por amostragem por importância\nvariancia_importancia &lt;- var((sqrt(z)) * dexp(z, 1) / g(z))\ncat(\"Variância da estimativa por amostragem por importância:\", variancia_importancia, \"\\n\")\n\n\nVariância da estimativa por amostragem por importância: 367.4869 \n\n\n\nUsando \\(Y = |Z|\\), onde \\(Z \\sim Cauchy(0,1)\\):\n\nA densidade de importância combinada agora é: \\[\ng2(y) = dcauchy(y) + dcauchy(-y)\n\\]\n\nRPython\n\n\n\n\nMostrar código\n# Gerando amostras de uma distribuição Cauchy absoluta\nz &lt;- abs(rcauchy(n))\n\n# Função de densidade combinada g2(x) para a Cauchy\ng2 &lt;- function(x) {\n  return(dcauchy(x) + dcauchy(-x))\n}\n\n# Estimativa por amostragem por importância usando Cauchy\nestimativa_importancia_cauchy &lt;- mean((sqrt(z)) * dexp(z, 1) / g2(z))\ncat(\"Estimativa por amostragem por importância (Cauchy):\", estimativa_importancia_cauchy, \"\\n\")\n\n\nEstimativa por amostragem por importância (Cauchy): 0.885894 \n\n\nMostrar código\n# Variância da estimativa por amostragem por importância usando Cauchy\nvariancia_importancia_cauchy &lt;- var((sqrt(z)) * dexp(z, 1) / g2(z))\ncat(\"Variância da estimativa por amostragem por importância (Cauchy):\", variancia_importancia_cauchy, \"\\n\")\n\n\nVariância da estimativa por amostragem por importância (Cauchy): 0.1985572 \n\n\n\n\n\n\nMostrar código\nimport numpy as np\nfrom scipy.stats import cauchy, expon\n\n# Gerando amostras de uma distribuição Cauchy absoluta\nz = np.abs(cauchy.rvs(size=n))\n\n# Função de densidade combinada g2(x) para a Cauchy\ndef g2(x):\n    return cauchy.pdf(x) + cauchy.pdf(-x)\n\n# Estimativa por amostragem por importância usando Cauchy\nestimativa_importancia_cauchy = np.mean(np.sqrt(z) * expon.pdf(z, scale=1) / g2(z))\nprint(f\"Estimativa por amostragem por importância (Cauchy): {estimativa_importancia_cauchy}\")\n\n\nEstimativa por amostragem por importância (Cauchy): 0.8931960985696105\n\n\nMostrar código\n# Variância da estimativa por amostragem por importância usando Cauchy\nvariancia_importancia_cauchy = np.var(np.sqrt(z) * expon.pdf(z, scale=1) / g2(z), ddof=1)\nprint(f\"Variância da estimativa por amostragem por importância (Cauchy): {variancia_importancia_cauchy}\")\n\n\nVariância da estimativa por amostragem por importância (Cauchy): 0.1971591987785306\n\n\n\n\n\nPodemos visualizar as funções de densidade \\(h(x) f(x)\\) e as funções de importância \\(g(x)\\) e \\(g2(x)\\) para entender melhor a escolha das distribuições de importância .\nGráfico de \\(h(x) f(x)\\) e as funções de importância \\(g(x)\\) e \\(g2(x)\\): Aqui está o código convertido para Python usando a biblioteca matplotlib e seaborn no formato solicitado:\n\nRPython\n\n\n\n\nMostrar código\nlibrary(ggplot2)\n\n# Funções\nh_f &lt;- function(x) sqrt(x) * dexp(x, 1)\ng &lt;- function(x) 0.5 * exp(-0.5 * x)  # Exemplo para g(x)\ng2 &lt;- function(x) 0.8 * exp(-0.3 * x) # Exemplo para g2(x)\n\n# Dados\nx_vals &lt;- seq(0, 3, length.out = 100)\ndata &lt;- data.frame(\n  x = x_vals,\n  h_f = h_f(x_vals),\n  g = g(x_vals),\n  g2 = g2(x_vals)\n)\n\n# Gráfico\nggplot(data, aes(x)) +\n  geom_line(aes(y = h_f, color = \"h(x)f(x)\"), size = 1.2) +\n  geom_line(aes(y = g, color = \"g(x)\"), size = 1.2) +\n  geom_line(aes(y = g2, color = \"g2(x)\"), size = 1.2) +\n  scale_color_manual(values = c(\"h(x)f(x)\" = \"black\", \"g(x)\" = \"red\", \"g2(x)\" = \"blue\")) +\n  labs(y = \"Valor\", color = \"Funções\") +\n  theme_minimal(base_size = 15)\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Funções\ndef h_f(x):\n    return np.sqrt(x) * np.exp(-x)\n\ndef g(x):\n    return 0.5 * np.exp(-0.5 * x)\n\ndef g2(x):\n    return 0.8 * np.exp(-0.3 * x)\n\n# Dados\nx_vals = np.linspace(0, 3, 100)\nh_f_vals = h_f(x_vals)\ng_vals = g(x_vals)\ng2_vals = g2(x_vals)\n\n# Gráfico\nplt.plot(x_vals, h_f_vals, label=\"h(x)f(x)\", color=\"black\", linewidth=1.2)\nplt.plot(x_vals, g_vals, label=\"g(x)\", color=\"red\", linewidth=1.2)\nplt.plot(x_vals, g2_vals, label=\"g2(x)\", color=\"blue\", linewidth=1.2)\n\nplt.xlabel(\"x\")\nplt.ylabel(\"Valor\")\nplt.legend(title=\"Funções\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nGráfico de \\(h(x) f(x) / g(x)\\) e \\(h(x) f(x) / g2(x)\\): Aqui está o código equivalente em Python usando matplotlib no formato solicitado:\n\nRPython\n\n\n\n\nMostrar código\nlibrary(ggplot2)\n\n# Funções\nh_f &lt;- function(x) sqrt(x) * dexp(x, 1)\ng &lt;- function(x) 0.5 * exp(-0.5 * x)  # Exemplo para g(x)\ng2 &lt;- function(x) 0.8 * exp(-0.3 * x) # Exemplo para g2(x)\n\n# Dados\nx_vals &lt;- seq(0, 3, length.out = 100)\ndata &lt;- data.frame(\n  x = x_vals,\n  h_f_over_g = h_f(x_vals) / g(x_vals),\n  h_f_over_g2 = h_f(x_vals) / g2(x_vals)\n)\n\n# Gráfico\nggplot(data, aes(x)) +\n  geom_line(aes(y = h_f_over_g, color = \"h(x)f(x) / g(x)\"), size = 1.2) +\n  geom_line(aes(y = h_f_over_g2, color = \"h(x)f(x) / g2(x)\"), size = 1.2) +\n  scale_color_manual(values = c(\"h(x)f(x) / g(x)\" = \"black\", \"h(x)f(x) / g2(x)\" = \"red\")) +\n  labs(y = \"Valor\", color = \"Funções\") +\n  theme_minimal(base_size = 15)\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Funções\ndef h_f(x):\n    return np.sqrt(x) * np.exp(-x)\n\ndef g(x):\n    return 0.5 * np.exp(-0.5 * x)\n\ndef g2(x):\n    return 0.8 * np.exp(-0.3 * x)\n\n# Dados\nx_vals = np.linspace(0, 3, 100)\nh_f_over_g = h_f(x_vals) / g(x_vals)\nh_f_over_g2 = h_f(x_vals) / g2(x_vals)\n\n# Gráfico\nplt.plot(x_vals, h_f_over_g, label=\"h(x)f(x) / g(x)\", color=\"black\", linewidth=1.2)\nplt.plot(x_vals, h_f_over_g2, label=\"h(x)f(x) / g2(x)\", color=\"red\", linewidth=1.2)\n\nplt.xlabel(\"x\")\nplt.ylabel(\"Valor\")\nplt.legend(title=\"Funções\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nEsses gráficos mostram como as diferentes escolhas de distribuições de importância afetam a função ponderada, ajudando a reduzir a variância do estimador.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Amostragem por Importância</span>"
    ]
  },
  {
    "objectID": "11_import.html#exercícios",
    "href": "11_import.html#exercícios",
    "title": "13  Amostragem por Importância",
    "section": "13.4 Exercícios",
    "text": "13.4 Exercícios\nExercício 1. Usando a Amostragem por Importância, estime a probabilidade de que uma variável aleatória \\(Z \\sim N(0,1)\\) seja maior que 5.0. Compare os resultados obtidos com a amostragem direta usando Monte Carlo simples e discuta a eficiência da Amostragem por Importância em relação ao método direto.\nExercício 2. Estime o valor da integral \\(\\int_0^2 \\sqrt{x} e^{-x} dx\\) utilizando a Amostragem por Importância com duas distribuições de importância diferentes. Justifique a escolha das distribuições e compare a eficiência de cada uma.\nExercício 3. Utilize a Amostragem por Importância para estimar \\(\\mathbb{E}[\\log(1 + X)]\\), onde \\(X \\sim Exp(1)\\). Escolha uma densidade auxiliar apropriada para melhorar a eficiência da estimativa e justifique sua escolha. Compare os resultados com a aproximação via Monte Carlo simples.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Amostragem por Importância</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Ross, Sheldon M. 2006. Simulation, Fourth Edition. USA:\nAcademic Press, Inc.",
    "crumbs": [
      "References"
    ]
  }
]