[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso de Programação Estatística",
    "section": "",
    "text": "Curso de Programação Estatística",
    "crumbs": [
      "Curso de Programação Estatística"
    ]
  },
  {
    "objectID": "index.html#objetivo-geral",
    "href": "index.html#objetivo-geral",
    "title": "Curso de Programação Estatística",
    "section": "Objetivo Geral",
    "text": "Objetivo Geral\nEste curso visa explorar o impacto das representações numéricas nos resultados de algoritmos de análise estatística. O foco será na programação, visualização e preparação de dados, além de discutir tópicos importantes como aleatoriedade, pseudoaleatoriedade, erros de truncamento e arredondamento, entre outros. O curso inclui ainda uma introdução à inferência por simulação estocástica, utilizando métodos como Monte Carlo e integrações numéricas. O material do curso foi amplamente baseado nas discussões apresentadas em Ross (2006).\nEste livro apresenta códigos tanto em R quanto em Python\nAutores: Andressa Cerqueira, Rafael Izbicki, Thiago Rodrigo Ramos\n\n\n\n\nRoss, Sheldon M. 2006. Simulation, Fourth Edition. USA: Academic Press, Inc.",
    "crumbs": [
      "Curso de Programação Estatística"
    ]
  },
  {
    "objectID": "0_R.html",
    "href": "0_R.html",
    "title": "2  Breve Introdução ao R",
    "section": "",
    "text": "2.1 Variáveis Numéricas\nAqui vão alguns exemplos para começarmos a entender como o R funciona. Inicialmente, veremos como podemos usar o R como calculadora.\n2 * 7\n\n[1] 14\n\n0 / 0\n\n[1] NaN\n\n10^1000\n\n[1] Inf\n\nlog(1)\n\n[1] 0\n\nexp(1)\n\n[1] 2.718282\nPara entender o que uma função faz, você pode digitar o símbolo de interrogação seguido do nome da função, por exemplo:\n?exp\nO help contém as seguintes informações:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#variáveis-numéricas",
    "href": "0_R.html#variáveis-numéricas",
    "title": "2  Breve Introdução ao R",
    "section": "",
    "text": "Description: Resumo geral sobre o uso da função.\nUsage: Mostra como a função deve ser utilizada e quais argumentos podem ser especificados.\nArguments: Explica o que é cada um dos argumentos.\nDetails: Explica alguns detalhes sobre o uso e aplicação da função.\nValue: Mostra o que sai no output após usar a função (os resultados).\nNote: Notas sobre a função.\nAuthors: Lista os autores da função.\nReferences: Referências para os métodos usados.\nSee also: Outras funções relacionadas que podem ser consultadas.\nExamples: Exemplos do uso da função.\n\n\n2.1.1 Armazenando resultados em variáveis\nPodemos também armazenar resultados de contas em variáveis. Por exemplo:\n\nx = 2 + 3\nx\n\n[1] 5\n\ny = 2 * x\ny\n\n[1] 10\n\nprint(y)\n\n[1] 10\n\n\nNúmeros grandes são impressos usando notação científica:\n\ny = 2 * 10^10\nprint(y)\n\n[1] 2e+10\n\n\nPara listar quais variáveis estão declaradas no ambiente, podemos usar:\n\nls()\n\n[1] \"x\" \"y\"\n\n\nPara remover uma variável:\n\nrm(x)\nls()\n\n[1] \"y\"\n\n\nPara remover todas as variáveis existentes:\n\nrm(list = ls())  # Essa função apaga todas as variáveis existentes\ngc()  # Essa função libera a memória utilizada\n\n          used (Mb) gc trigger (Mb) max used (Mb)\nNcells  624758 33.4    1280571 68.4  1280571 68.4\nVcells 1175313  9.0    8388608 64.0  1923922 14.7",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#variáveis-lógicas",
    "href": "0_R.html#variáveis-lógicas",
    "title": "2  Breve Introdução ao R",
    "section": "2.2 Variáveis Lógicas",
    "text": "2.2 Variáveis Lógicas\nAlguns operadores lógicos definidos no R são mostrados na tabela abaixo:\n\n\n\n#\nOperador\nDescrição\n\n\n\n\n1\nx &lt; y\nx menor que y?\n\n\n2\nx &lt;= y\nx menor ou igual a y?\n\n\n3\nx &gt; y\nx maior que y?\n\n\n4\nx &gt;= y\nx maior ou igual a y?\n\n\n5\nx == y\nx igual a y?\n\n\n6\nx != y\nx diferente de y?\n\n\n7\n!x\nNegativa de x\n\n\n8\nx | y\nx ou y são verdadeiros?\n\n\n9\nx & y\nx e y são verdadeiros?\n\n\n10\nxor(x, y)\nApenas um dos dois é verdadeiro?\n\n\n\n\n2.2.1 Exemplos de uso de operadores lógicos\n\n1 == 3\n\n[1] FALSE\n\n1 == 1\n\n[1] TRUE\n\n1 &lt;= 3\n\n[1] TRUE\n\nx = 1 &gt; 3\nprint(x)\n\n[1] FALSE\n\nx = 1; y = 3\nx &lt; y\n\n[1] TRUE\n\n(x == 1) & (y == 3)\n\n[1] TRUE\n\n(x == 1) & (y != 3)\n\n[1] FALSE\n\n!TRUE\n\n[1] FALSE\n\nx = TRUE; y = FALSE\nx | y\n\n[1] TRUE\n\n\nO número um tem o valor verdadeiro, e o número zero tem o valor falso:\n\nx = 1; y = 0\nx | y\n\n[1] TRUE\n\n\nNote que ao fazermos contas com variáveis lógicas, elas são transformadas em zero e um:\n\n(TRUE | FALSE) + 2\n\n[1] 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#caracteresstrings",
    "href": "0_R.html#caracteresstrings",
    "title": "2  Breve Introdução ao R",
    "section": "2.3 Caracteres/Strings",
    "text": "2.3 Caracteres/Strings\nPara declarar cadeias de caracteres, usamos aspas no R:\n\nx = \"Rafael\"\ny = \"Izbicki\"\n\nVárias operações podem ser feitas com esses objetos. Um exemplo é a função paste:\n\npaste(x, y)\n\n[1] \"Rafael Izbicki\"\n\npaste(x, y, sep = \"+\")\n\n[1] \"Rafael+Izbicki\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#vetores-e-sequências",
    "href": "0_R.html#vetores-e-sequências",
    "title": "2  Breve Introdução ao R",
    "section": "2.4 Vetores e Sequências",
    "text": "2.4 Vetores e Sequências\nUsualmente declaramos vetores usando o operador c (concatenação):\n\nx = c(2, 5, 7, 1)\nx\n\n[1] 2 5 7 1\n\n\nPara acessar seus componentes, fazemos:\n\nx[2]\n\n[1] 5\n\n# [1] 5\n\nx = x[c(2, 3)]\nx[2:3]\n\n[1]  7 NA\n\nx[-c(2, 3)]\n\n[1] 5\n\n\nAs operações x[c(2, 3)] e x[-c(2, 3)] são chamadas de subsetting; subsetting é a seleção de um subconjunto de um objeto. Veremos mais à frente outras maneiras de fazermos isso.\nPodemos mudar alguns dos valores deste vetor usando:\n\nx[2:3] = 0\nx\n\n[1] 5 0 0\n\n\nOperações aritméticas podem ser facilmente feitas para cada elemento de um vetor. Alguns exemplos:\n\nx = x - 1\nx\n\n[1]  4 -1 -1\n\nx = 2 * x\nx\n\n[1]  8 -2 -2\n\n\nUma função útil para criar vetores é a seq:\n\nx = seq(from = 1, to = 100, by = 2)\nx\n\n [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49\n[26] 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99\n\ny = seq(from = 1, to = 100, length = 5)\ny\n\n[1]   1.00  25.75  50.50  75.25 100.00\n\n\nPodemos também usar operadores lógicos em vetores:\n\nx &gt; 5\n\n [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[49]  TRUE  TRUE\n\n\nNote que x &gt; 5 é um vetor lógico.\nPodemos usar as operações lógicas em vetores lógicos:\n\nx = c(TRUE, TRUE, FALSE, FALSE)\ny = c(TRUE, FALSE, TRUE, FALSE)\n\nx | y\n\n[1]  TRUE  TRUE  TRUE FALSE\n\nx & y\n\n[1]  TRUE FALSE FALSE FALSE\n\n\nOperadores lógicos também podem ser usados para fazer subsetting:\n\nx[x &gt; 5] = 0\nx\n\n[1] 1 1 0 0\n\nx[!(x &lt;= 0)] = -1\nx\n\n[1] -1 -1  0  0\n\n\nPodemos ter vetores de caracteres:\n\nx = c(\"a\", \"c\", \"fgh\")\nx[-c(2, 3)]\n\n[1] \"a\"\n\npaste(x, \"add\")\n\n[1] \"a add\"   \"c add\"   \"fgh add\"\n\npaste(x, \"add\", collapse = \"+\")\n\n[1] \"a add+c add+fgh add\"\n\n\nAlgumas funções adicionais úteis:\n\nrep(2, 5)\n\n[1] 2 2 2 2 2\n\nrep(c(1, 2), 5)\n\n [1] 1 2 1 2 1 2 1 2 1 2\n\nrep(c(1, 2), each = 5)\n\n [1] 1 1 1 1 1 2 2 2 2 2\n\nsort(c(5, 10, 0, 20))\n\n[1]  0  5 10 20\n\norder(c(5, 10, 0, 20))\n\n[1] 3 1 2 4",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#funções",
    "href": "0_R.html#funções",
    "title": "2  Breve Introdução ao R",
    "section": "2.5 Funções",
    "text": "2.5 Funções\nPara declarar funções em R, fazemos:\nminhaFuncao &lt;- function(argumento1, argumento2) {\n  # corpo da função\n}\nPor exemplo:\n\npotencia &lt;- function(x, y) {\n  return(x^y)\n}\npotencia(2, 3)\n\n[1] 8\n\n# [1] 8\n\nNote que x e y podem ser vetores:\n\npotencia(x = c(1, 2, 3), y = c(0, 1, 2))\n\n[1] 1 2 9\n\n\nVocê pode inverter a ordem dos argumentos, desde que eles sejam nomeados:\n\npotencia(y = c(0, 1, 2), x = c(1, 2, 3))\n\n[1] 1 2 9\n\n\n\n2.5.1 Argumentos com valores default\nOs argumentos podem ter valores default. Por exemplo:\n\npotencia &lt;- function(x, y = rep(1, length(x))) {\n  return(x^y)\n}\n\nNeste caso, se o argumento y não for fornecido, ele será um vetor de uns do tamanho de x:\n\npotencia(2)\n\n[1] 2\n\npotencia(2, 3)\n\n[1] 8",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#laços",
    "href": "0_R.html#laços",
    "title": "2  Breve Introdução ao R",
    "section": "2.6 Laços",
    "text": "2.6 Laços\nPara calcular o fatorial de um número n, podemos usar um laço while:\n\nn &lt;- 4\ni &lt;- 1\nnFatorial &lt;- 1\nwhile(i &lt;= n) {\n  nFatorial &lt;- nFatorial * i\n  i &lt;- i + 1\n}\nnFatorial\n\n[1] 24\n\n\nOu podemos usar um laço for:\n\nn &lt;- 4\nnFatorial &lt;- 1\nfor(i in 1:n) {\n  nFatorial &lt;- nFatorial * i\n}\nnFatorial\n\n[1] 24\n\n\nLembre-se de que laços podem ser lentos no R, especialmente se o tamanho do objeto não for previamente declarado. Vamos comparar o tempo de execução de diferentes abordagens usando a função system.time. Para isso, vamos calcular a soma acumulada de um vetor.\n\nx &lt;- 1:100000\n\n\nLaço sem declaração de tamanho:\n\n\naux &lt;- function(x) {\n  somaAcumulada &lt;- NULL\n  somaAcumulada[1] &lt;- x[1]\n  for(i in 2:length(x)) {\n    somaAcumulada[i] &lt;- somaAcumulada[i - 1] + x[i]\n  }\n}\nsystem.time(aux(x))[1]\n\nuser.self \n     0.03 \n\n\n\nLaço com declaração de tamanho:\n\n\naux &lt;- function(x) {\n  somaAcumulada &lt;- rep(NA, length(x))\n  somaAcumulada[1] &lt;- x[1]\n  for(i in 2:length(x)) {\n    somaAcumulada[i] &lt;- somaAcumulada[i - 1] + x[i]\n  }\n}\nsystem.time(aux(x))[1]\n\nuser.self \n    0.013 \n\n\n\nFunção nativa do R:\n\n\naux &lt;- function(x) {\n  cumsum(x)\n}\nsystem.time(aux(x))[1]\n\nuser.self \n    0.002 \n\n\nNote que, em geral, funções nativas do R são muito mais rápidas.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#ifelse",
    "href": "0_R.html#ifelse",
    "title": "2  Breve Introdução ao R",
    "section": "2.7 If/Else",
    "text": "2.7 If/Else\nO R permite o uso de condicionais if e else para controlar o fluxo de execução. A sintaxe básica é:\nif (condição1) {\n  # código se a condição1 for verdadeira\n} else if (condição2) {\n  # código se a condição1 for falsa e condição2 verdadeira\n} else {\n  # código se todas as condições forem falsas\n}\nExemplo:\n\ntestaX &lt;- function(x) {\n  if (!is.numeric(x)) {\n    print(\"x não é um número\")\n  } else if (x &gt; 0) {\n    print(\"x é positivo\")\n  } else if (x &lt; 0) {\n    print(\"x é negativo\")\n  } else {\n    print(\"x é nulo\")\n  }\n}\ntestaX(5)\n\n[1] \"x é positivo\"\n\ntestaX(-5)\n\n[1] \"x é negativo\"\n\ntestaX(\"5\")\n\n[1] \"x não é um número\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#listas",
    "href": "0_R.html#listas",
    "title": "2  Breve Introdução ao R",
    "section": "2.8 Listas",
    "text": "2.8 Listas\nListas são como vetores, mas podem conter componentes de diferentes tipos (inclusive outras listas).\n\nminhaLista &lt;- list(\"um\", TRUE, 3, c(\"q\", \"u\", \"a\", \"t\", \"r\", \"o\"), \"cinco\")\nminhaLista[[3]]\n\n[1] 3\n\n\nVocê também pode atribuir nomes aos elementos de uma lista:\n\nminhaLista &lt;- list(primeiro = \"um\", segundo = TRUE, terceiro = 3, \n                   quarto = c(\"q\", \"u\", \"a\", \"t\", \"r\", \"o\"), quinto = \"cinco\")\nminhaLista$quinto\n\n[1] \"cinco\"\n\n\nListas são frequentemente usadas para retornar várias saídas de uma função. Por exemplo, ao ajustar um modelo de regressão linear, os resultados são armazenados em uma lista:\n\nx &lt;- rnorm(100)\ny &lt;- 1 + 2*x + rnorm(length(x), 0.1)\najuste &lt;- lm(y ~ x)\ntypeof(ajuste)\n\n[1] \"list\"\n\n\nOs componentes da lista podem ser acessados com:\n\nnames(ajuste)\n\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n\n\nPara ver os coeficientes ajustados:\n\najuste$coefficients\n\n(Intercept)           x \n   1.165347    1.973333 \n\n\nPara adicionar a reta estimada ao gráfico:\n\nplot(x, y, pch = 18, bty = \"l\")\nabline(ajuste, col = 2, lwd = 3)\n\n\n\n\n\n\n\n\nVocê também pode inicializar uma lista vazia:\n\nminhaLista &lt;- list()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#estatística-descritiva",
    "href": "0_R.html#estatística-descritiva",
    "title": "2  Breve Introdução ao R",
    "section": "2.9 Estatística Descritiva",
    "text": "2.9 Estatística Descritiva\nO R é uma ferramenta poderosa para realizar análises descritivas. Vamos explorar alguns recursos para calcular estatísticas de variáveis quantitativas e qualitativas.\n\n2.9.1 Variáveis quantitativas\n\nx &lt;- c(30, 1, 20, 5, 20, 60)\ny &lt;- c(12, 0, 2, 15, 22, 20)\n\nmean(x)\n\n[1] 22.66667\n\nvar(x)\n\n[1] 448.6667\n\nmin(x)\n\n[1] 1\n\nwhich.min(x)\n\n[1] 2\n\nmax(x)\n\n[1] 60\n\nwhich.max(x)\n\n[1] 6\n\nsort(x)\n\n[1]  1  5 20 20 30 60\n\norder(x)\n\n[1] 2 4 3 5 1 6\n\nmedian(x)\n\n[1] 20\n\ncor(x, y)\n\n[1] 0.5229211\n\nwhich(x &gt; 10)\n\n[1] 1 3 5 6\n\nmean(y[x &gt; 10])\n\n[1] 14\n\n\n\n\n2.9.2 Variáveis qualitativas\n\nx &lt;- c(\"S\", \"R\", \"P\", \"P\", \"Q\", \"P\")\ny &lt;- c(\"a\", \"a\", \"b\", \"a\", \"c\", \"d\")\n\nx[y %in% c(\"a\", \"c\")]\n\n[1] \"S\" \"R\" \"P\" \"Q\"\n\ntable(x)\n\nx\nP Q R S \n3 1 1 1 \n\ntable(x, y)\n\n   y\nx   a b c d\n  P 1 1 0 1\n  Q 0 0 1 0\n  R 1 0 0 0\n  S 1 0 0 0\n\n\n\n\n2.9.3 Subconjuntos\nPodemos utilizar subsetting para trabalhar com subconjuntos de interesse. Por exemplo, suponha que dados é um banco de dados com informações de alunos e queremos selecionar os alunos com idade menor que 20, altura maior que 1,70 e que estejam no primeiro ou segundo ano.\n\ndados[dados$idade &lt; 20 & dados$altura &gt; 1.70 & dados$ano %in% c(\"Primeiro\", \"Segundo\"), ]\n\n\n\n2.9.4 Funções Apply\nAs funções da família apply (como apply, lapply, sapply) são úteis para aplicar uma função a um conjunto de dados. Vamos criar um banco de dados artificial para exemplificar:\n\ndados &lt;- data.frame(altura = rnorm(100, 1.7, 0.2), salario = rnorm(100, 3000, 500))\ndados$peso &lt;- dados$altura * 35 + rnorm(100, 0, 10)\n\n\n2.9.4.1 apply\nPara calcular a média de cada coluna de dados, usamos:\n\napply(dados, 2, mean)\n\n     altura     salario        peso \n   1.738918 3073.921371   62.459130 \n\n\nAqui, o argumento 2 indica que a operação deve ser aplicada a cada coluna. Para calcular a soma de cada linha:\n\napply(dados, 1, sum)\n\n  [1] 3246.676 3628.465 3517.538 2730.965 3281.798 3350.541 3951.776 3071.716\n  [9] 3971.812 3611.463 2634.407 3376.986 3526.900 2515.773 2807.691 2238.245\n [17] 3181.374 2837.894 3359.573 2977.241 3684.720 3277.090 2807.646 3672.926\n [25] 3047.492 2695.518 3484.330 2816.785 2572.859 3134.357 3037.246 3109.791\n [33] 3335.029 2884.293 2576.703 2564.804 3455.849 2839.450 2737.404 2702.751\n [41] 2287.652 2771.716 3101.319 3558.644 2850.695 3182.979 3590.174 3247.518\n [49] 3467.367 2772.015 2927.957 3851.464 2411.517 3475.468 2879.081 3165.622\n [57] 3426.778 3118.478 3647.271 3595.763 3363.636 3338.047 3460.779 3418.686\n [65] 2924.029 3579.994 2817.831 3187.194 3215.183 2665.735 2873.924 3412.148\n [73] 3607.878 2579.537 3492.175 3764.679 3065.132 3029.033 3677.048 3278.871\n [81] 3432.071 2510.969 3118.784 3618.525 2775.794 3677.819 3371.820 2646.483\n [89] 2936.040 2996.043 2462.381 2730.974 2964.618 3443.123 2821.312 2817.808\n [97] 3546.819 3633.386 2771.521 3198.760\n\n\n\n\n2.9.4.2 Funções anônimas\nUsando funções anônimas, podemos calcular várias estatísticas descritivas ao mesmo tempo:\n\nestatisticas &lt;- apply(dados, 2, function(x) {\n  listaResultados &lt;- list()\n  listaResultados$media &lt;- mean(x)\n  listaResultados$mediaAparada &lt;- mean(x, trim = 0.1)\n  listaResultados$mediana &lt;- median(x)\n  listaResultados$maximo &lt;- max(x)\n  return(listaResultados)\n})\n\nestatisticas$altura\n\n$media\n[1] 1.738918\n\n$mediaAparada\n[1] 1.740517\n\n$mediana\n[1] 1.730565\n\n$maximo\n[1] 2.152833",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#o-operador-pipe",
    "href": "0_R.html#o-operador-pipe",
    "title": "2  Breve Introdução ao R",
    "section": "2.10 O operador %>% (pipe)",
    "text": "2.10 O operador %&gt;% (pipe)\n\nO operador pipe foi uma das grandes revoluções recentes do R, tornando o código mais legível. Esse operador está definido no pacote magrittr, e vários outros pacotes, como o dplyr, fazem uso dele (veja a próxima seção).\nA ideia é simples: o operador %&gt;% usa o resultado do lado esquerdo como o primeiro argumento da função do lado direito. Um exemplo:\n\nlibrary(magrittr)\nx &lt;- c(1, 2, 3, 4)\nx %&gt;% sum() %&gt;% sqrt()\n\n[1] 3.162278\n\n\nIsso é equivalente a:\n\nsqrt(sum(x))\n\n[1] 3.162278\n\n\nMas a leitura com pipe é mais clara. No RStudio, você pode inserir o pipe com o atalho ctrl + shift + m.\nO pipe envia o valor à esquerda apenas para o primeiro argumento da função à direita. Para utilizar o valor da esquerda em outro argumento, utilize o \".\":\n\ny &lt;- rnorm(10)\ny %&gt;% plot(x = 1:length(y), y = ., pch = 18)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#o-pacote-dplyr",
    "href": "0_R.html#o-pacote-dplyr",
    "title": "2  Breve Introdução ao R",
    "section": "2.11 O pacote dplyr",
    "text": "2.11 O pacote dplyr\nO pacote dplyr é muito útil para manipulação eficiente de data frames. Vamos demonstrar alguns exemplos usando o conjunto de dados hflights.\n\nlibrary(dplyr)\nlibrary(hflights)\ndata(hflights)\n\nPrimeiro, converta os dados para o formato tbl_df, uma variação mais amigável do data.frame:\n\nflights &lt;- tbl_df(hflights)\n\n\n2.11.1 Filter\nA função filter retorna todas as linhas que satisfazem uma condição. Por exemplo, para mostrar todos os voos do dia 1º de janeiro:\n\nflights %&gt;% filter(Month == 1, DayofMonth == 1)\n\n# A tibble: 552 × 21\n    Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum\n   &lt;int&gt; &lt;int&gt;      &lt;int&gt;     &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;chr&gt;             &lt;int&gt;\n 1  2011     1          1         6    1400    1500 AA                  428\n 2  2011     1          1         6     728     840 AA                  460\n 3  2011     1          1         6    1631    1736 AA                 1121\n 4  2011     1          1         6    1756    2112 AA                 1294\n 5  2011     1          1         6    1012    1347 AA                 1700\n 6  2011     1          1         6    1211    1325 AA                 1820\n 7  2011     1          1         6     557     906 AA                 1994\n 8  2011     1          1         6    1824    2106 AS                  731\n 9  2011     1          1         6     654    1124 B6                  620\n10  2011     1          1         6    1639    2110 B6                  622\n# ℹ 542 more rows\n# ℹ 13 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;,\n#   ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;,\n#   TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;,\n#   Diverted &lt;int&gt;\n\n\nPara condições alternativas, podemos usar o operador | (ou) ou %in%:\n\nflights %&gt;% filter(UniqueCarrier %in% c(\"AA\", \"UA\"))\n\n# A tibble: 5,316 × 21\n    Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum\n   &lt;int&gt; &lt;int&gt;      &lt;int&gt;     &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;chr&gt;             &lt;int&gt;\n 1  2011     1          1         6    1400    1500 AA                  428\n 2  2011     1          2         7    1401    1501 AA                  428\n 3  2011     1          3         1    1352    1502 AA                  428\n 4  2011     1          4         2    1403    1513 AA                  428\n 5  2011     1          5         3    1405    1507 AA                  428\n 6  2011     1          6         4    1359    1503 AA                  428\n 7  2011     1          7         5    1359    1509 AA                  428\n 8  2011     1          8         6    1355    1454 AA                  428\n 9  2011     1          9         7    1443    1554 AA                  428\n10  2011     1         10         1    1443    1553 AA                  428\n# ℹ 5,306 more rows\n# ℹ 13 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;,\n#   ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;,\n#   TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;,\n#   Diverted &lt;int&gt;\n\n\n\n\n2.11.2 Select\nA função select seleciona colunas específicas de um data frame. Para selecionar as colunas DepTime, ArrTime, e FlightNum:\n\nflights %&gt;% select(DepTime, ArrTime, FlightNum)\n\n# A tibble: 227,496 × 3\n   DepTime ArrTime FlightNum\n     &lt;int&gt;   &lt;int&gt;     &lt;int&gt;\n 1    1400    1500       428\n 2    1401    1501       428\n 3    1352    1502       428\n 4    1403    1513       428\n 5    1405    1507       428\n 6    1359    1503       428\n 7    1359    1509       428\n 8    1355    1454       428\n 9    1443    1554       428\n10    1443    1553       428\n# ℹ 227,486 more rows\n\n\nPara selecionar todas as colunas que contêm “Taxi” ou “Delay”:\n\nflights %&gt;% select(contains(\"Taxi\"), contains(\"Delay\"))\n\n# A tibble: 227,496 × 4\n   TaxiIn TaxiOut ArrDelay DepDelay\n    &lt;int&gt;   &lt;int&gt;    &lt;int&gt;    &lt;int&gt;\n 1      7      13      -10        0\n 2      6       9       -9        1\n 3      5      17       -8       -8\n 4      9      22        3        3\n 5      9       9       -3        5\n 6      6      13       -7       -1\n 7     12      15       -1       -1\n 8      7      12      -16       -5\n 9      8      22       44       43\n10      6      19       43       43\n# ℹ 227,486 more rows\n\n\n\n\n2.11.3 Arrange\nA função arrange ordena o data frame de acordo com algum critério. Para ordenar pelo atraso de partida (DepDelay):\n\nflights %&gt;% arrange(DepDelay)\n\n# A tibble: 227,496 × 21\n    Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum\n   &lt;int&gt; &lt;int&gt;      &lt;int&gt;     &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;chr&gt;             &lt;int&gt;\n 1  2011    12         24         6    1112    1314 OO                 5440\n 2  2011     2         14         1    1917    2027 MQ                 3328\n 3  2011     4         10         7    2101    2206 XE                 2669\n 4  2011     8          3         3    1741    1810 XE                 2603\n 5  2011     1         18         2    1542    1936 CO                 1688\n 6  2011    10          4         2    1438    1813 EV                 5412\n 7  2011     1         26         3    2248    2343 XE                 2450\n 8  2011     3          8         2     953    1156 CO                 1882\n 9  2011     3         18         5    2103    2156 XE                 2261\n10  2011     4          3         7    1048    1307 MQ                 3796\n# ℹ 227,486 more rows\n# ℹ 13 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;,\n#   ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;,\n#   TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;,\n#   Diverted &lt;int&gt;\n\n\nPara ordem decrescente:\n\nflights %&gt;% arrange(desc(DepDelay))\n\n# A tibble: 227,496 × 21\n    Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum\n   &lt;int&gt; &lt;int&gt;      &lt;int&gt;     &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;chr&gt;             &lt;int&gt;\n 1  2011     8          1         1     156     452 CO                    1\n 2  2011    12         12         1     650     808 AA                 1740\n 3  2011    11          8         2     721     948 MQ                 3786\n 4  2011     6         21         2    2334     124 UA                  855\n 5  2011     6          9         4    2029    2243 MQ                 3859\n 6  2011     5         20         5     858    1027 MQ                 3328\n 7  2011     1         20         4     635     807 CO                   59\n 8  2011     6         22         3     908    1040 CO                  595\n 9  2011    10         25         2    2310     149 DL                 1215\n10  2011    12         13         2     706     824 MQ                 3328\n# ℹ 227,486 more rows\n# ℹ 13 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;,\n#   ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;,\n#   TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;,\n#   Diverted &lt;int&gt;\n\n\n\n\n2.11.4 Mutate\nA função mutate cria novas variáveis. Para criar a variável Speed (velocidade) e adicioná-la ao banco:\n\nflights &lt;- flights %&gt;% mutate(Speed = Distance / AirTime * 60)\n\n\n\n2.11.5 Summarise e Group_by\nA função summarise calcula estatísticas resumo. Para calcular o atraso médio de chegada por destino:\n\nflights %&gt;% group_by(Dest) %&gt;% summarise(avg_delay = mean(ArrDelay, na.rm = TRUE))\n\n# A tibble: 116 × 2\n   Dest  avg_delay\n   &lt;chr&gt;     &lt;dbl&gt;\n 1 ABQ        7.23\n 2 AEX        5.84\n 3 AGS        4   \n 4 AMA        6.84\n 5 ANC       26.1 \n 6 ASE        6.79\n 7 ATL        8.23\n 8 AUS        7.45\n 9 AVL        9.97\n10 BFL      -13.2 \n# ℹ 106 more rows\n\n\nA função summarise_each aplica uma função a várias colunas ao mesmo tempo. Para calcular a média de Cancelled e Diverted por companhia aérea:\n\nflights %&gt;% group_by(UniqueCarrier) %&gt;% summarise_each(funs(mean), Cancelled, Diverted)\n\n# A tibble: 15 × 3\n   UniqueCarrier Cancelled Diverted\n   &lt;chr&gt;             &lt;dbl&gt;    &lt;dbl&gt;\n 1 AA              0.0185   0.00185\n 2 AS              0        0.00274\n 3 B6              0.0259   0.00576\n 4 CO              0.00678  0.00263\n 5 DL              0.0159   0.00303\n 6 EV              0.0345   0.00318\n 7 F9              0.00716  0      \n 8 FL              0.00982  0.00327\n 9 MQ              0.0290   0.00194\n10 OO              0.0139   0.00349\n11 UA              0.0164   0.00241\n12 US              0.0113   0.00147\n13 WN              0.0155   0.00229\n14 XE              0.0155   0.00345\n15 YV              0.0127   0      \n\n\nTambém podemos aplicar várias funções a uma mesma coluna:\n\nflights %&gt;% group_by(UniqueCarrier) %&gt;% summarise_each(funs(mean, var), Cancelled, Diverted)\n\n# A tibble: 15 × 5\n   UniqueCarrier Cancelled_mean Diverted_mean Cancelled_var Diverted_var\n   &lt;chr&gt;                  &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 AA                   0.0185        0.00185       0.0182       0.00185\n 2 AS                   0             0.00274       0            0.00274\n 3 B6                   0.0259        0.00576       0.0253       0.00573\n 4 CO                   0.00678       0.00263       0.00674      0.00262\n 5 DL                   0.0159        0.00303       0.0157       0.00302\n 6 EV                   0.0345        0.00318       0.0333       0.00317\n 7 F9                   0.00716       0             0.00712      0      \n 8 FL                   0.00982       0.00327       0.00973      0.00326\n 9 MQ                   0.0290        0.00194       0.0282       0.00193\n10 OO                   0.0139        0.00349       0.0138       0.00347\n11 UA                   0.0164        0.00241       0.0161       0.00241\n12 US                   0.0113        0.00147       0.0111       0.00147\n13 WN                   0.0155        0.00229       0.0153       0.00229\n14 XE                   0.0155        0.00345       0.0153       0.00344\n15 YV                   0.0127        0             0.0127       0      \n\n\nAlém disso, podemos usar o operador \".\" para aplicar funções com múltiplos argumentos:\n\nflights %&gt;% group_by(UniqueCarrier) %&gt;% summarise_each(funs(min(., na.rm = TRUE), max(., na.rm = TRUE)), matches(\"Delay\"))\n\n# A tibble: 15 × 5\n   UniqueCarrier ArrDelay_min DepDelay_min ArrDelay_max DepDelay_max\n   &lt;chr&gt;                &lt;int&gt;        &lt;int&gt;        &lt;int&gt;        &lt;int&gt;\n 1 AA                     -39          -15          978          970\n 2 AS                     -43          -15          183          172\n 3 B6                     -44          -14          335          310\n 4 CO                     -55          -18          957          981\n 5 DL                     -32          -17          701          730\n 6 EV                     -40          -18          469          479\n 7 F9                     -24          -15          277          275\n 8 FL                     -30          -14          500          507\n 9 MQ                     -38          -23          918          931\n10 OO                     -57          -33          380          360\n11 UA                     -47          -11          861          869\n12 US                     -42          -17          433          425\n13 WN                     -44          -10          499          548\n14 XE                     -70          -19          634          628\n15 YV                     -32          -11           72           54\n\n\nPor fim, podemos realizar agrupamentos múltiplos:\n\nflights %&gt;% group_by(UniqueCarrier, DayOfWeek) %&gt;% summarise_each(funs(min(., na.rm = TRUE), max(., na.rm = TRUE)), matches(\"Delay\"))\n\n# A tibble: 105 × 6\n# Groups:   UniqueCarrier [15]\n   UniqueCarrier DayOfWeek ArrDelay_min DepDelay_min ArrDelay_max DepDelay_max\n   &lt;chr&gt;             &lt;int&gt;        &lt;int&gt;        &lt;int&gt;        &lt;int&gt;        &lt;int&gt;\n 1 AA                    1          -30          -14          978          970\n 2 AA                    2          -30          -12          265          286\n 3 AA                    3          -33          -15          179          168\n 4 AA                    4          -38          -15          663          653\n 5 AA                    5          -28          -13          255          234\n 6 AA                    6          -39          -13          685          677\n 7 AA                    7          -34          -15          507          525\n 8 AS                    1          -30          -12          183          172\n 9 AS                    2          -34          -12           92           68\n10 AS                    3          -29          -12          123          138\n# ℹ 95 more rows\n\n\nAqui está a seção sobre o pacote ggplot2 e tidyr atualizada, mantendo a clareza e estrutura para fins didáticos:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#o-pacote-ggplot2",
    "href": "0_R.html#o-pacote-ggplot2",
    "title": "2  Breve Introdução ao R",
    "section": "2.12 O pacote ggplot2",
    "text": "2.12 O pacote ggplot2\nNota: Esta seção foi adaptada de curso-r.com.\nO ggplot2 é um pacote do R voltado para a criação de gráficos estatísticos. Ele é baseado na Gramática dos Gráficos (Grammar of Graphics) de Leland Wilkinson. Segundo essa gramática, um gráfico estatístico é um mapeamento dos dados por meio de atributos estéticos (cores, formas, tamanho) de formas geométricas (pontos, linhas, barras).\n\nlibrary(ggplot2)\n\n\n2.12.1 Construindo gráficos\nVamos discutir os aspectos básicos para a construção de gráficos com o ggplot2, utilizando o conjunto de dados mtcars. Para visualizar as primeiras linhas:\n\nhead(mtcars)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n\n\n2.12.2 As camadas de um gráfico\nOs gráficos no ggplot2 são construídos camada por camada. A primeira camada é criada com a função ggplot. Um exemplo de gráfico simples:\n\nggplot(data = mtcars) +\n  geom_point(aes(x = disp, y = mpg))\n\n\n\n\n\n\n\n\nA função aes define o mapeamento entre as variáveis e os aspectos visuais. Neste caso, estamos criando um gráfico de dispersão (com geom_point) entre disp (cilindradas) e mpg (milhas por galão).\n\n\n2.12.3 Aesthetics\nPodemos mapear variáveis a diferentes aspectos estéticos, como cor e tamanho. Por exemplo, para mapear a variável am (transmissão) para a cor dos pontos:\n\nggplot(data = mtcars) +\n  geom_point(aes(x = disp, y = mpg, colour = as.factor(am)))\n\n\n\n\n\n\n\n\n\n\n2.12.4 Geoms\nOs geoms definem as formas geométricas usadas para a visualização dos dados. Além de geom_point, podemos usar:\n\ngeom_line para linhas\ngeom_boxplot para boxplots\ngeom_histogram para histogramas\n\nExemplo de um boxplot:\n\nggplot(mtcars) +\n  geom_boxplot(aes(x = as.factor(cyl), y = mpg))\n\n\n\n\n\n\n\n\n\n\n2.12.5 Personalizando os gráficos\n\n2.12.5.1 Cores\nPara mudar as cores do gráfico, podemos usar o argumento colour ou fill:\n\nggplot(mtcars) +\n  geom_boxplot(aes(x = as.factor(cyl), y = mpg, fill = as.factor(cyl)))\n\n\n\n\n\n\n\n\n\n\n2.12.5.2 Eixos\nPara alterar os rótulos dos eixos:\n\nggplot(mtcars) +\n  geom_histogram(aes(x = mpg)) +\n  xlab(\"Milhas por galão\") +\n  ylab(\"Frequência\")\n\n\n\n\n\n\n\n\n\n\n2.12.5.3 Legendas\nPodemos personalizar ou remover legendas facilmente:\n\nggplot(mtcars) +\n  geom_bar(aes(x = as.factor(cyl), fill = as.factor(cyl))) +\n  labs(fill = \"Cilindros\") +\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\n2.12.6 Facets\nO facet_grid permite dividir o gráfico em subgráficos com base em uma variável:\n\nggplot(mtcars) +\n  geom_point(aes(x = mpg, y = disp, colour = as.factor(cyl))) +\n  facet_grid(am ~ .)\n\n\n\n\n\n\n\n\n\n\n2.12.7 Temas\nPodemos mudar o tema de um gráfico com a função theme_set:\n\ntheme_set(theme_light(base_size = 10))\nggplot(mtcars) +\n  geom_point(aes(x = mpg, y = disp, colour = as.factor(cyl))) +\n  facet_grid(. ~ am)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#o-pacote-tidyr",
    "href": "0_R.html#o-pacote-tidyr",
    "title": "2  Breve Introdução ao R",
    "section": "2.13 O pacote tidyr",
    "text": "2.13 O pacote tidyr\nO pacote tidyr facilita a transformação e organização de dados no R. Para converter os dados de formato “wide” (largo) para “long” (longo), podemos utilizar a função pivot_longer, que substitui a antiga função gather. Considere os dados a seguir:\n\ndados.originais &lt;- data.frame(\n  paciente = c(\"João\", \"Marcos\", \"Antonio\"),\n  pressao.antes = c(67, 80, 64),\n  pressao.durante = c(54, 70, 60),\n  pressao.depois = c(56, 90, 50)\n)\ndados.originais\n\n  paciente pressao.antes pressao.durante pressao.depois\n1     João            67              54             56\n2   Marcos            80              70             90\n3  Antonio            64              60             50\n\n\nPara reorganizar esses dados em um formato “long”, usando pivot_longer:\n\nlibrary(tidyr)\ndados.novo.formato &lt;- dados.originais %&gt;%\n  pivot_longer(cols = pressao.antes:pressao.depois,\n               names_to = \"instante\",\n               values_to = \"pressao.arterial\")\ndados.novo.formato\n\n# A tibble: 9 × 3\n  paciente instante        pressao.arterial\n  &lt;chr&gt;    &lt;chr&gt;                      &lt;dbl&gt;\n1 João     pressao.antes                 67\n2 João     pressao.durante               54\n3 João     pressao.depois                56\n4 Marcos   pressao.antes                 80\n5 Marcos   pressao.durante               70\n6 Marcos   pressao.depois                90\n7 Antonio  pressao.antes                 64\n8 Antonio  pressao.durante               60\n9 Antonio  pressao.depois                50\n\n\nA função pivot_wider é usada para converter dados de formato “long” (longo) para “wide” (largo), espalhando uma variável por várias colunas. Vamos começar com um conjunto de dados em formato “long” e então reorganizá-los para o formato “wide”.\nConsidere o conjunto de dados dados.novo.formato que organizamos anteriormente:\n\ndados.novo.formato &lt;- data.frame(\n  paciente = c(\"João\", \"Marcos\", \"Antonio\", \"João\", \"Marcos\", \"Antonio\", \"João\", \"Marcos\", \"Antonio\"),\n  instante = c(\"pressao.antes\", \"pressao.antes\", \"pressao.antes\", \"pressao.durante\", \"pressao.durante\", \"pressao.durante\", \"pressao.depois\", \"pressao.depois\", \"pressao.depois\"),\n  pressao.arterial = c(67, 80, 64, 54, 70, 60, 56, 90, 50)\n)\ndados.novo.formato\n\n  paciente        instante pressao.arterial\n1     João   pressao.antes               67\n2   Marcos   pressao.antes               80\n3  Antonio   pressao.antes               64\n4     João pressao.durante               54\n5   Marcos pressao.durante               70\n6  Antonio pressao.durante               60\n7     João  pressao.depois               56\n8   Marcos  pressao.depois               90\n9  Antonio  pressao.depois               50\n\n\nAgora, vamos usar pivot_wider para transformar esses dados de volta ao formato “wide”:\n\ndados.wide &lt;- dados.novo.formato %&gt;%\n  pivot_wider(names_from = instante, values_from = pressao.arterial)\ndados.wide\n\n# A tibble: 3 × 4\n  paciente pressao.antes pressao.durante pressao.depois\n  &lt;chr&gt;            &lt;dbl&gt;           &lt;dbl&gt;          &lt;dbl&gt;\n1 João                67              54             56\n2 Marcos              80              70             90\n3 Antonio             64              60             50\n\n\nTemos os seguintes argumentos: - names_from especifica a coluna cujos valores serão usados para criar novos nomes de colunas (neste caso, a variável instante). - values_from especifica a coluna cujos valores serão preenchidos nas novas colunas criadas (neste caso, a variável pressao.arterial).\nAqui está um exemplo de como o pacote tidyr pode ser usado para manipular os dados antes de visualizá-los com gráficos no ggplot2.\n\n2.13.1 Exemplo: Manipulação e Visualização com pivot_longer e ggplot2\nO pacote tidyr é particularmente últil dentro do ggplot2. Vamos continuar com o exemplo dos dados de pressão arterial. Suponha que você queira visualizar as variações da pressão arterial dos pacientes em diferentes instantes.\nPrimeiro, vamos reorganizar os dados usando pivot_longer para colocar os dados no formato “long”, que é mais adequado para gráficos com o ggplot2:\n\nlibrary(tidyr)\nlibrary(ggplot2)\n\n# Dados originais no formato \"wide\"\ndados.originais &lt;- data.frame(\n  paciente = c(\"João\", \"Marcos\", \"Antonio\"),\n  pressao.antes = c(67, 80, 64),\n  pressao.durante = c(54, 70, 60),\n  pressao.depois = c(56, 90, 50)\n)\ndados.originais\n\n  paciente pressao.antes pressao.durante pressao.depois\n1     João            67              54             56\n2   Marcos            80              70             90\n3  Antonio            64              60             50\n\n\nPara usá-los no ggplot, vamos os reorganizar no formato “long”:\n\ndados.long &lt;- dados.originais %&gt;%\n  pivot_longer(cols = pressao.antes:pressao.depois,\n               names_to = \"instante\",\n               values_to = \"pressao.arterial\")\ndados.long\n\n# A tibble: 9 × 3\n  paciente instante        pressao.arterial\n  &lt;chr&gt;    &lt;chr&gt;                      &lt;dbl&gt;\n1 João     pressao.antes                 67\n2 João     pressao.durante               54\n3 João     pressao.depois                56\n4 Marcos   pressao.antes                 80\n5 Marcos   pressao.durante               70\n6 Marcos   pressao.depois                90\n7 Antonio  pressao.antes                 64\n8 Antonio  pressao.durante               60\n9 Antonio  pressao.depois                50\n\n\nAgora, vamos criar um gráfico de linhas que mostra as mudanças na pressão arterial ao longo do tempo para cada paciente:\n\nggplot(dados.long, aes(x = instante, y = pressao.arterial, group = paciente, color = paciente)) +\n  geom_line(size = 1) +\n  geom_point(size = 3) +\n  labs(title = \"Variação da Pressão Arterial dos Pacientes\",\n       x = \"Instante\",\n       y = \"Pressão Arterial\") +\n  theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#leitura-de-arquivos-com-readr",
    "href": "0_R.html#leitura-de-arquivos-com-readr",
    "title": "2  Breve Introdução ao R",
    "section": "2.14 Leitura de Arquivos com readr",
    "text": "2.14 Leitura de Arquivos com readr\nO readr é um pacote eficiente para leitura de arquivos de dados no R. Vamos explorar como utilizar o readr para ler e manipular arquivos CSV. Um arquivo CSV (Comma-Separated Values) é um formato comum para armazenar dados tabulares.\nPara começar, carregue o pacote readr:\n\nlibrary(readr)\n\n\n2.14.1 Exemplo: Leitura de um CSV com Dados Públicos\nVamos usar um banco de dados público disponível na internet. Um exemplo muito comum é o conjunto de dados de passageiros do Titanic, disponível em formato CSV. Para carregar diretamente da internet:\n\nurl &lt;- \"https://raw.githubusercontent.com/datasciencedojo/datasets/master/titanic.csv\"\ndados_titanic &lt;- read_csv(url)\n\nAqui, estamos carregando os dados diretamente de um link. Após a leitura, podemos visualizar os primeiros registros:\n\nhead(dados_titanic)\n\n# A tibble: 6 × 12\n  PassengerId Survived Pclass Name    Sex     Age SibSp Parch Ticket  Fare Cabin\n        &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;\n1           1        0      3 Braund… male     22     1     0 A/5 2…  7.25 &lt;NA&gt; \n2           2        1      1 Cuming… fema…    38     1     0 PC 17… 71.3  C85  \n3           3        1      3 Heikki… fema…    26     0     0 STON/…  7.92 &lt;NA&gt; \n4           4        1      1 Futrel… fema…    35     1     0 113803 53.1  C123 \n5           5        0      3 Allen,… male     35     0     0 373450  8.05 &lt;NA&gt; \n6           6        0      3 Moran,… male     NA     0     0 330877  8.46 &lt;NA&gt; \n# ℹ 1 more variable: Embarked &lt;chr&gt;\n\n\n\n\n2.14.2 Manipulando os Dados Lidos\nO read_csv detecta automaticamente os tipos de dados de cada coluna. No exemplo dos dados do Titanic, podemos realizar algumas análises rápidas, como visualizar a distribuição de sobreviventes:\n\ntable(dados_titanic$Survived)\n\n\n  0   1 \n549 342 \n\n\n\n\n2.14.3 Salvando o Conjunto de Dados\nSe você quiser salvar o conjunto de dados em seu computador após manipulações, basta usar o write_csv:\n\nwrite_csv(dados_titanic, \"titanic_local.csv\")\n\nAqui está o conjunto de exercícios no formato solicitado:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "0_R.html#exercícios",
    "href": "0_R.html#exercícios",
    "title": "2  Breve Introdução ao R",
    "section": "2.15 Exercícios",
    "text": "2.15 Exercícios\nExercício 1.\nExecute as seguintes operações no R e interprete os resultados: - \\(5 + 9\\) - \\(\\frac{0}{0}\\) - \\(10^{5}\\)\nUtilize a função log para calcular o logaritmo natural de 10 e depois o logaritmo na base 10 de 1000.\nDescubra a função que calcula a raiz quadrada de um número utilizando o símbolo de interrogação (?), e aplique-a ao número 144.\nExercício 2.\nArmazene o resultado de \\(15 \\times 7\\) em uma variável chamada resultado. Use resultado para calcular o valor de \\(2 \\times resultado\\).\nListe todas as variáveis no ambiente do R usando a função ls(). Exclua a variável resultado e verifique novamente as variáveis presentes.\nExercício 3.\nCrie um vetor v contendo os números 4, 8, 15, 16, 23, 42. Use subsetting para selecionar: - O segundo e o quarto elemento. - Todos os elementos exceto o terceiro. - Os elementos que são maiores que 10.\nMultiplique cada elemento do vetor v por 2 e armazene o resultado em um novo vetor v2.\nExercício 4.\nVerifique se 8 é maior que 5 e se 8 é igual a 10.\nCrie dois vetores lógicos a = c(TRUE, FALSE, TRUE) e b = c(FALSE, TRUE, FALSE). Aplique os operadores &, | e xor() nesses vetores.\nExercício 5.\nEscreva uma função soma_quadrados que receba dois números como argumentos e retorne a soma de seus quadrados. Teste sua função com os números 3 e 4.\nModifique a função soma_quadrados para que o segundo argumento tenha um valor padrão de 2. Teste a função chamando-a com apenas um argumento.\nExercício 6.\nEscreva um laço for que calcule a soma dos números de 1 a 100.\nCrie um laço while que multiplique os números de 1 a 6 e retorne o resultado.\nExercício 7.\nCrie duas variáveis com o seu primeiro e último nome. Use a função paste() para juntar as duas variáveis em uma frase que diga “Meu nome completo é [nome completo]”.\nAltere o separador na função paste() para um traço - e junte novamente as variáveis.\nExercício 8.\nCarregue o pacote dplyr e use o dataset mtcars. Selecione apenas as colunas mpg, cyl, e hp.\nFiltre as observações onde mpg é maior que 20 e hp é menor que 150.\nOrdene o dataset filtrado pela coluna mpg em ordem decrescente.\nExercício 9.\nUsando o dataset mtcars, crie um gráfico de dispersão (geom_point) que mostre a relação entre hp (horsepower) e mpg (milhas por galão).\nNo gráfico anterior, mapeie a variável cyl para a cor dos pontos.\nExercício 10. Utilize a base pública de dados de voos da nycflights13 para responder às perguntas abaixo.\n\nCarregue o pacote nycflights13 e explore o dataset flights. Visualize as primeiras 6 linhas da base.\nFiltre todos os voos que decolaram no mês de junho e aterrissaram com atraso maior que 1 hora.\nAgrupe os dados por companhia aérea (carrier) e calcule o atraso médio de chegada (arr_delay) para cada companhia.\nCrie um gráfico de barras que mostre o atraso médio de chegada por companhia aérea.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Breve Introdução ao R</span>"
    ]
  },
  {
    "objectID": "1_intro.html",
    "href": "1_intro.html",
    "title": "3  Geração de Números Aleatórios e Aplicação em Estatística",
    "section": "",
    "text": "3.1 Objetivo da Aula\nNesta aula, vamos introduzir o conceito de números pseudoaleatórios e como eles podem ser usados para resolver problemas estatísticos por meio de simulação. Vamos abordar a importância da aleatoriedade em estatísticas e em algoritmos de Monte Carlo.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Estatística</span>"
    ]
  },
  {
    "objectID": "1_intro.html#conteúdo-teórico",
    "href": "1_intro.html#conteúdo-teórico",
    "title": "3  Geração de Números Aleatórios e Aplicação em Estatística",
    "section": "3.2 Conteúdo Teórico",
    "text": "3.2 Conteúdo Teórico\nA geração de números aleatórios é essencial em várias áreas da estatística e da ciência de dados. Esses números são utilizados em simulações estocásticas, amostragem e para resolver problemas que envolvem incerteza. Contudo, em computadores, os números “aleatórios” gerados são na verdade pseudoaleatórios, pois seguem uma sequência previsível, gerada por um algoritmo determinístico.\nOs números pseudoaleatórios são amplamente usados em algoritmos de Monte Carlo, que dependem da simulação repetida de processos aleatórios para estimar soluções para problemas matemáticos e estatísticos.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Estatística</span>"
    ]
  },
  {
    "objectID": "1_intro.html#exemplo-de-problema",
    "href": "1_intro.html#exemplo-de-problema",
    "title": "3  Geração de Números Aleatórios e Aplicação em Estatística",
    "section": "3.3 Exemplo de Problema",
    "text": "3.3 Exemplo de Problema\nVamos resolver o problema de estimar o valor de π (Pi) usando um método de Monte Carlo. A ideia é simular a área de um quarto de círculo inscrito em um quadrado. Gerando pontos aleatórios dentro do quadrado, podemos calcular a proporção desses pontos que também caem dentro do círculo e usar essa proporção para estimar o valor de Pi.\nComo fazer isso?\n\nRPython\n\n\n\n\nMostrar código\n# Definindo o número de pontos a serem gerados\nn_pontos &lt;- 1000\n\n# Gerando pontos aleatórios (x, y) no intervalo [0, 1]\nx &lt;- runif(n_pontos, 0, 1)\ny &lt;- runif(n_pontos, 0, 1)\n\n# Calculando a distância de cada ponto à origem\ndistancia &lt;- sqrt(x^2 + y^2)\n\n# Contando quantos pontos estão dentro do quarto de círculo (distância &lt;= 1)\ndentro_circulo &lt;- distancia &lt;= 1\npi_estimado &lt;- 4 * sum(dentro_circulo) / n_pontos\n\n# Exibindo o valor estimado de Pi\ncat(\"Valor estimado de π:\", pi_estimado, \"\\n\")\n\n\nValor estimado de π: 3.176 \n\n\nMostrar código\n# Visualizando a distribuição dos pontos\nlibrary(ggplot2)\n\ndados &lt;- data.frame(x = x, y = y, dentro_circulo = dentro_circulo)\n\nggplot(dados, aes(x = x, y = y, color = dentro_circulo)) +\n  geom_point(size = 1) +\n  scale_color_manual(values = c(\"red\", \"blue\")) +\n  ggtitle(paste0(\"Estimativa de π usando Monte Carlo\\nValor estimado: \", round(pi_estimado, 5))) +\n  theme_minimal() +\n  coord_equal() +\n  labs(x = \"x\", y = \"y\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo o número de pontos a serem gerados\nn_pontos = 1000\n\n# Gerando pontos aleatórios (x, y) no intervalo [0, 1]\nx = np.random.uniform(0, 1, n_pontos)\ny = np.random.uniform(0, 1, n_pontos)\n\n# Calculando a distância de cada ponto à origem\ndistancia = np.sqrt(x**2 + y**2)\n\n# Contando quantos pontos estão dentro do quarto de círculo (distância &lt;= 1)\ndentro_circulo = distancia &lt;= 1\npi_estimado = 4 * np.sum(dentro_circulo) / n_pontos\n\n# Exibindo o valor estimado de Pi\nprint(f\"Valor estimado de π: {pi_estimado}\")\n\n\nValor estimado de π: 3.168\n\n\nMostrar código\n# Visualizando a distribuição dos pontos\nplt.figure(figsize=(6,6))\nplt.scatter(x, y, c=dentro_circulo, cmap='coolwarm', s=1)\nplt.title(f'Estimativa de π usando Monte Carlo\\nValor estimado: {pi_estimado}')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Estatística</span>"
    ]
  },
  {
    "objectID": "1_intro.html#exemplo-simulação-de-um-jogo-de-dados-com-dado-viciado",
    "href": "1_intro.html#exemplo-simulação-de-um-jogo-de-dados-com-dado-viciado",
    "title": "3  Geração de Números Aleatórios e Aplicação em Estatística",
    "section": "3.4 Exemplo: Simulação de um Jogo de Dados com Dado “Viciado”",
    "text": "3.4 Exemplo: Simulação de um Jogo de Dados com Dado “Viciado”\nImagine que estamos jogando um jogo em que o dado é “viciado” e não segue uma distribuição uniforme, ou seja, alguns números têm uma chance maior de serem sorteados. Por exemplo, o número 6 pode ter uma probabilidade maior, e os outros números, menores.\nIsso nos permite mostrar como alterar a probabilidade de ocorrência de eventos em uma distribuição discreta.\n\nRPython\n\n\n\n\nMostrar código\n# Definindo as faces do dado e as probabilidades\nfaces &lt;- 1:6\nprobabilidades &lt;- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.25)  # Probabilidades associadas às faces do dado\n\n# Verificando que a soma das probabilidades é 1\ncat(\"Soma das probabilidades:\", sum(probabilidades), \"\\n\")\n\n\nSoma das probabilidades: 1 \n\n\nMostrar código\n# Simulando 10000 lançamentos de um dado viciado\nn_lancamentos &lt;- 10000\nset.seed(123)  # Definindo seed para reprodutibilidade\nresultados &lt;- sample(faces, size = n_lancamentos, replace = TRUE, prob = probabilidades)\n\n# Contando as frequências de cada face\nfrequencias &lt;- table(resultados) / n_lancamentos\n\n# Exibindo os resultados da simulação\ncat(\"Frequências de cada face após\", n_lancamentos, \"lançamentos:\\n\")\n\n\nFrequências de cada face após 10000 lançamentos:\n\n\nMostrar código\nfor (face in faces) {\n  cat(\"Face\", face, \":\", frequencias[as.character(face)], \"vezes\\n\")\n}\n\n\nFace 1 : 0.0473 vezes\nFace 2 : 0.0975 vezes\nFace 3 : 0.1504 vezes\nFace 4 : 0.1991 vezes\nFace 5 : 0.2582 vezes\nFace 6 : 0.2475 vezes\n\n\nMostrar código\n# Visualizando os resultados em um gráfico de barras\nlibrary(ggplot2)\n\ndados &lt;- data.frame(faces = as.factor(faces), frequencias = as.numeric(frequencias))\n\nggplot(dados, aes(x = faces, y = frequencias)) +\n  geom_bar(stat = \"identity\", fill = \"lightcoral\", color = \"black\") +\n  ggtitle(paste0(\"Simulação de Lançamentos de um Dado Viciado\\n\", n_lancamentos, \" lançamentos\")) +\n  xlab(\"Face do Dado\") +\n  ylab(\"Frequência de Ocorrência\") +\n  theme_minimal() +\n  geom_text(aes(label = round(frequencias, 4)), vjust = -0.5) +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo as faces do dado e as probabilidades\nfaces = [1, 2, 3, 4, 5, 6]\nprobabilidades = [0.05, 0.1, 0.15, 0.2, 0.25, 0.25]  # Probabilidades associadas às faces do dado\n\n# Verificando que a soma das probabilidades é 1\nprint(f\"Soma das probabilidades: {sum(probabilidades)}\")\n\n\nSoma das probabilidades: 1.0\n\n\nMostrar código\n# Simulando 10000 lançamentos de um dado viciado\nn_lancamentos = 10000\nresultados = np.random.choice(faces, size=n_lancamentos, p=probabilidades)\n\n# Contando as frequências de cada face\nfrequencias = [np.sum(resultados == face) / n_lancamentos for face in faces]\n\n# Exibindo os resultados da simulação\nprint(f\"Frequências de cada face após {n_lancamentos} lançamentos:\")\n\n\nFrequências de cada face após 10000 lançamentos:\n\n\nMostrar código\nfor face, freq in zip(faces, frequencias):\n    print(f\"Face {face}: {freq} vezes\")\n\n\nFace 1: 0.0513 vezes\nFace 2: 0.1019 vezes\nFace 3: 0.1507 vezes\nFace 4: 0.203 vezes\nFace 5: 0.2504 vezes\nFace 6: 0.2427 vezes\n\n\nMostrar código\n# Visualizando os resultados em um gráfico de barras\nplt.figure(figsize=(8,6))\nplt.bar(faces, frequencias, color='lightcoral', edgecolor='black')\nplt.title(f'Simulação de Lançamentos de um Dado Viciado\\n{n_lancamentos} lançamentos')\nplt.xlabel('Face do Dado')\nplt.ylabel('Frequência de Ocorrência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Estatística</span>"
    ]
  },
  {
    "objectID": "1_intro.html#pergunta-precisamos-da-função-np.random.choiceset.seed",
    "href": "1_intro.html#pergunta-precisamos-da-função-np.random.choiceset.seed",
    "title": "3  Geração de Números Aleatórios e Aplicação em Estatística",
    "section": "3.5 Pergunta: precisamos da função np.random.choice/set.seed?",
    "text": "3.5 Pergunta: precisamos da função np.random.choice/set.seed?\n\nRPython\n\n\n\n\nMostrar código\n# Definindo as faces do dado e as probabilidades associadas (não uniformes)\nfaces &lt;- 1:6\nprobabilidades &lt;- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.25)  # Probabilidades associadas às faces do dado\n\n# Função para gerar uma amostra baseada em intervalos de probabilidades\ngerar_amostra_por_intervalos &lt;- function(probabilidades, faces) {\n  u &lt;- runif(1)  # Gerando um número aleatório uniforme\n  limite_inferior &lt;- 0  # Limite inferior do intervalo\n  \n  # Percorrendo as probabilidades e verificando em qual intervalo o número cai\n  for (i in seq_along(probabilidades)) {\n    limite_superior &lt;- limite_inferior + probabilidades[i]  # Definindo o limite superior do intervalo\n    if (limite_inferior &lt;= u && u &lt; limite_superior) {\n      return(faces[i])  # Retorna a face correspondente ao intervalo\n    }\n    limite_inferior &lt;- limite_superior  # Atualiza o limite inferior para o próximo intervalo\n  }\n}\n\n# Simulando lançamentos do dado viciado utilizando a verificação dos intervalos\nn_lancamentos &lt;- 10000\nset.seed(123)  # Definindo seed para reprodutibilidade\nresultados &lt;- replicate(n_lancamentos, gerar_amostra_por_intervalos(probabilidades, faces))\n\n# Contando as frequências de cada face\nfrequencias &lt;- sapply(faces, function(face) sum(resultados == face) / n_lancamentos)\n\n# Exibindo os resultados da simulação\ncat(\"Frequências de cada face após\", n_lancamentos, \"lançamentos:\\n\")\n\n\nFrequências de cada face após 10000 lançamentos:\n\n\nMostrar código\nfor (i in seq_along(faces)) {\n  cat(\"Face\", faces[i], \":\", frequencias[i], \"vezes\\n\")\n}\n\n\nFace 1 : 0.0521 vezes\nFace 2 : 0.0964 vezes\nFace 3 : 0.1527 vezes\nFace 4 : 0.2045 vezes\nFace 5 : 0.2508 vezes\nFace 6 : 0.2435 vezes\n\n\nMostrar código\n# Visualizando os resultados em gráficos\n\nlibrary(ggplot2)\n\n# Gráfico das probabilidades ajustadas\ndados_probabilidades &lt;- data.frame(faces = as.factor(faces), probabilidades = probabilidades)\nggplot(dados_probabilidades, aes(x = faces, y = probabilidades)) +\n  geom_bar(stat = \"identity\", fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Probabilidades Ajustadas para o Dado Viciado\") +\n  xlab(\"Face do Dado\") +\n  ylab(\"Probabilidade\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n\n\n\n\n\n\nMostrar código\n# Gráfico das frequências obtidas\ndados_frequencias &lt;- data.frame(faces = as.factor(faces), frequencias = frequencias)\nggplot(dados_frequencias, aes(x = faces, y = frequencias)) +\n  geom_bar(stat = \"identity\", fill = \"lightcoral\", color = \"black\") +\n  ggtitle(paste0(\"Simulação de Lançamentos de um Dado Viciado\\n\", n_lancamentos, \" lançamentos\")) +\n  xlab(\"Face do Dado\") +\n  ylab(\"Frequência de Ocorrência\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo as faces do dado e as probabilidades associadas (não uniformes)\nfaces = [1, 2, 3, 4, 5, 6]\nprobabilidades = [0.05, 0.1, 0.15, 0.2, 0.25, 0.25]  # Probabilidades associadas às faces do dado\n\n# Gerando um número aleatório e verificando em qual intervalo ele cai\ndef gerar_amostra_por_intervalos(probabilidades, faces):\n    u = np.random.uniform(0, 1)  # Gerando um número aleatório uniforme\n    limite_inferior = 0  # Limite inferior do intervalo\n    \n    # Percorrendo as probabilidades e verificando em qual intervalo o número cai\n    for i, p in enumerate(probabilidades):\n        limite_superior = limite_inferior + p  # Definindo o limite superior do intervalo\n        if limite_inferior &lt;= u &lt; limite_superior:\n            return faces[i]  # Retorna a face correspondente ao intervalo\n        limite_inferior = limite_superior  # Atualiza o limite inferior para o próximo intervalo\n\n# Simulando lançamentos do dado viciado utilizando a verificação dos intervalos\nn_lancamentos = 10000\nresultados = [gerar_amostra_por_intervalos(probabilidades, faces) for _ in range(n_lancamentos)]\n\n# Contando as frequências de cada face\nfrequencias = [np.sum(np.array(resultados) == face) / n_lancamentos for face in faces]\n\n# Exibindo os resultados da simulação\nprint(f\"Frequências de cada face após {n_lancamentos} lançamentos:\")\n\n\nFrequências de cada face após 10000 lançamentos:\n\n\nMostrar código\nfor face, freq in zip(faces, frequencias):\n    print(f\"Face {face}: {freq} vezes\")\n\n\nFace 1: 0.0515 vezes\nFace 2: 0.1019 vezes\nFace 3: 0.1488 vezes\nFace 4: 0.2056 vezes\nFace 5: 0.2474 vezes\nFace 6: 0.2448 vezes\n\n\nMostrar código\n# Gráfico das probabilidades ajustadas\nplt.figure(figsize=(8,6))\nplt.bar(faces, probabilidades, color='skyblue', edgecolor='black')\nplt.title('Probabilidades Ajustadas para o Dado Viciado')\nplt.xlabel('Face do Dado')\nplt.ylabel('Probabilidade')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nMostrar código\n# Gráfico das frequências obtidas\nplt.figure(figsize=(8,6))\nplt.bar(faces, frequencias, color='lightcoral', edgecolor='black')\nplt.title(f'Simulação de Lançamentos de um Dado Viciado\\n{n_lancamentos} lançamentos')\nplt.xlabel('Face do Dado')\nplt.ylabel('Frequência de Ocorrência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nOu seja, se conseguimos simular uma distribuição uniforme, conseguimos simular uma distribuição discreta. Isso vale de forma mais geral?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Estatística</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html",
    "href": "2_pseudorandom.html",
    "title": "4  Números Pseudoaleatórios",
    "section": "",
    "text": "4.1 O que é um número pseudoaleatório?\nUm número pseudoaleatório é gerado a partir de uma fórmula matemática que, a partir de uma semente (um valor inicial), gera uma sequência de números que tem as propriedades desejadas de uma sequência aleatória. Essa sequência parece aleatória, mas se a mesma semente for usada, a sequência será a mesma.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html#geração-de-números-pseudoaleatórios-com-o-gerador-linear-congruente-lcg",
    "href": "2_pseudorandom.html#geração-de-números-pseudoaleatórios-com-o-gerador-linear-congruente-lcg",
    "title": "4  Números Pseudoaleatórios",
    "section": "4.2 Geração de Números Pseudoaleatórios com o Gerador Linear Congruente (LCG)",
    "text": "4.2 Geração de Números Pseudoaleatórios com o Gerador Linear Congruente (LCG)\nLink para o wikipedia\nO Gerador Linear Congruente (LCG) é um dos métodos mais antigos e simples para gerar números pseudoaleatórios. Ele segue a fórmula:\n\\[\nX_{n+1} = (a \\cdot X_n + c) \\mod m\n\\]\nOnde: - \\(X_n\\) é o número atual (ou a semente inicial), - \\(a\\) é o multiplicador, - \\(c\\) é o incremento, - \\(m\\) é o módulo, ou seja, o intervalo dos números gerados.\nA sequência gerada pelo LCG depende diretamente dos parâmetros \\(a\\), \\(c\\), \\(m\\) e da semente inicial \\(X_0\\). Um conjunto mal escolhido de parâmetros pode resultar em uma sequência com um período curto, o que compromete a aleatoriedade da sequência.\n\n4.2.1 O que é a Função Módulo?\nA função módulo (também conhecida como operação de resto) retorna o resto da divisão de um número por outro. Em termos matemáticos, para dois números inteiros \\(a\\) e \\(b\\), a operação módulo é representada como:\n\\[\nr = a \\mod b\n\\]\nOnde: - \\(a\\) é o dividendo, - \\(b\\) é o divisor, - \\(r\\) é o resto da divisão de \\(a\\) por \\(b\\).\nPor exemplo, se temos \\(a = 17\\) e \\(b = 5\\), a divisão de 17 por 5 dá 3 com um resto de 2, então:\n\\[\n17 \\mod 5 = 2\n\\]\nNo contexto do Gerador Linear Congruente (LCG), a função módulo é usada para garantir que os números gerados fiquem dentro de um intervalo específico, geralmente entre 0 e \\(m-1\\), onde \\(m\\) é o módulo definido no algoritmo.\n\nRPython\n\n\n\n\nMostrar código\n# Exemplo de uso da função módulo em R\n\n# Definindo os valores\na &lt;- 17\nb &lt;- 3\n\n# Calculando o módulo de a por b\nresto &lt;- a %% b\n\n# Exibindo o resultado\ncat(\"O resultado de\", a, \"%%\", b, \"é:\", resto, \"\\n\")\n\n\nO resultado de 17 %% 3 é: 2 \n\n\n\n\n\n\nMostrar código\n# Exemplo de uso da função módulo em Python\n\n# Definindo os valores\na = 17\nb = 3\n\n# Calculando o módulo de a por b\nresto = a % b\n\n# Exibindo o resultado\nprint(f\"O resultado de {a} % {b} é: {resto}\")\n\n\nO resultado de 17 % 3 é: 2",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html#por-que-o-gerador-linear-congruente-funciona",
    "href": "2_pseudorandom.html#por-que-o-gerador-linear-congruente-funciona",
    "title": "4  Números Pseudoaleatórios",
    "section": "4.3 Por que o Gerador Linear Congruente Funciona?",
    "text": "4.3 Por que o Gerador Linear Congruente Funciona?\nO Gerador Linear Congruente (LCG) é um dos métodos mais simples e eficientes para gerar números pseudoaleatórios. Sua eficácia se baseia em um bom equilíbrio entre a escolha dos parâmetros (multiplicador \\(a\\), incremento \\(c\\), módulo \\(m\\) e semente inicial \\(X_0\\)) e as propriedades matemáticas que garantem uma sequência suficientemente “aleatória”. Para que o LCG funcione bem, os parâmetros precisam ser cuidadosamente selecionados para garantir que a sequência gerada tenha um período longo, seja bem distribuída e evite padrões repetitivos.\n\n4.3.1 A Fórmula do LCG\nA fórmula básica do LCG é:\n\\[\nX_{n+1} = (a \\cdot X_n + c) \\mod m\n\\]\nOnde: - \\(X_n\\) é o número gerado na \\(n\\)-ésima iteração, - \\(a\\) é o multiplicador, - \\(c\\) é o incremento, - \\(m\\) é o módulo, - \\(X_0\\) é a semente inicial.\nO número gerado em cada iteração é o resto da divisão de \\((a \\cdot X_n + c)\\) por \\(m\\). Essa operação garante que os números fiquem dentro do intervalo \\([0, m-1]\\). A normalização posterior geralmente transforma esses números em valores no intervalo \\([0, 1)\\).\n\n\n4.3.2 O Papel de \\(m\\)\nO valor de \\(m\\), conhecido como módulo, define o intervalo no qual os números gerados estarão contidos. Em muitos casos, \\(m\\) é escolhido como uma potência de 2 (por exemplo, \\(m = 2^{32}\\) ou \\(m = 2^{64}\\)) porque cálculos modulares com potências de 2 são mais rápidos em hardware.\nA escolha de \\(m\\) também influencia o período máximo da sequência. Se todos os parâmetros forem escolhidos corretamente, o LCG pode gerar uma sequência com o período máximo, que é \\(m\\). Isso significa que a sequência não repetirá nenhum número até que \\(m\\) números tenham sido gerados.\n\n\n4.3.3 O Papel de \\(a\\), \\(c\\) e a Condição de Coprimos\nPara garantir que o gerador tenha o período máximo (ou seja, \\(m\\) números diferentes antes de repetir a sequência), a escolha dos parâmetros \\(a\\) (multiplicador), \\(c\\) (incremento) e \\(m\\) (módulo) deve satisfazer as seguintes condições baseadas em teorias de números:\n\nO incremento \\(c\\) deve ser coprimo com \\(m\\):\n\nDois números são coprimos se o maior divisor comum deles for 1, ou seja, \\(\\text{gcd}(c, m) = 1\\). Isso garante que, ao somar \\(c\\), todos os possíveis valores de \\(X_n\\) possam ser atingidos antes de repetir a sequência.\nSe \\(c\\) não for coprimo com \\(m\\), a sequência gerada pode pular certos valores, resultando em um período mais curto do que o esperado.\n\nO valor de \\(a - 1\\) deve ser divisível por todos os fatores primos de \\(m\\):\n\nSe \\(m\\) é uma potência de 2 (por exemplo, \\(m = 2^k\\)), a escolha de \\(a\\) deve ser tal que \\((a - 1)\\) seja divisível por 2 para garantir que o período seja maximizado.\n\nSe \\(m\\) for divisível por 4, então \\((a - 1)\\) também deve ser divisível por 4:\n\nIsso é necessário para garantir que todos os resíduos modulares possíveis possam ser gerados, especialmente quando \\(m\\) é uma potência de 2.\n\n\n\n\n4.3.4 Exemplo de uma Escolha Correta de Parâmetros\nUm exemplo clássico de um bom conjunto de parâmetros é:\n\n\\(m = 2^{32}\\) (módulo com 32 bits),\n\\(a = 1664525\\) (multiplicador),\n\\(c = 1013904223\\) (incremento),\n\\(X_0 = 42\\) (semente inicial, que pode ser qualquer valor).\n\nEsses parâmetros foram escolhidos para garantir que o LCG tenha um longo período e uma boa distribuição dos números gerados. O módulo \\(m = 2^{32}\\) é uma potência de 2, o que torna as operações modulares mais rápidas, e os valores de \\(a\\) e \\(c\\) satisfazem as condições matemáticas para maximizar o período.\n\nRPython\n\n\n\n\nMostrar código\n# Importando o pacote necessário\nlibrary(gmp)\n\n# Parâmetros do exemplo\nm &lt;- 2^32\na &lt;- 1664525\nc &lt;- 1013904223\n\n# Verificando as condições\n# 1. O incremento c deve ser coprimo com m\ncoprimo_c_m &lt;- gcd(c, m) == 1\n\n# 2. a - 1 deve ser divisível por todos os fatores primos de m\na_menos_1 &lt;- a - 1\n\nprint(a_menos_1)\n\n\n[1] 1664524\n\n\nMostrar código\n# Verificando se a - 1 é divisível por 2 (único fator primo de m = 2^32)\ndivisivel_por_2 &lt;- (a_menos_1 %% 2 == 0)\n\n# 3. Se m for divisível por 4, a - 1 também deve ser divisível por 4\ndivisivel_por_4 &lt;- (a_menos_1 %% 4 == 0)\n\nlist(coprimo_c_m, divisivel_por_2, divisivel_por_4)\n\n\n[[1]]\n[1] TRUE\n\n[[2]]\n[1] TRUE\n\n[[3]]\n[1] TRUE\n\n\n\n\n\n\nMostrar código\nimport math\n\n# Parâmetros do exemplo\nm = 2**32\na = 1664525\nc = 1013904223\n\n# Verificando as condições\n# 1. O incremento c deve ser coprimo com m\ncoprimo_c_m = math.gcd(c, m) == 1\n\n# 2. a - 1 deve ser divisível por todos os fatores primos de m\na_menos_1 = a - 1\n\nprint(a_menos_1)\n\n\n1664524\n\n\nMostrar código\n# Verificando se a - 1 é divisível por 2 (único fator primo de m = 2^32)\ndivisivel_por_2 = (a_menos_1 % 2 == 0)\n\n# 3. Se m for divisível por 4, a - 1 também deve ser divisível por 4\ndivisivel_por_4 = (a_menos_1 % 4 == 0)\n\ncoprimo_c_m, divisivel_por_2, divisivel_por_4\n\n\n(True, True, True)\n\n\n\n\n\n\n\n4.3.5 Por que o LCG Funciona Bem?\nO LCG funciona porque: - As operações modulares garantem que os números gerados estejam dentro de um intervalo fixo e possam cobrir todo o espaço de possíveis valores de maneira ordenada. - A escolha adequada dos parâmetros garante que a sequência tenha um longo período (o maior possível dado \\(m\\)), evita padrões repetitivos e assegura que a sequência seja pseudoaleatória o suficiente para muitas aplicações, como simulações e métodos de Monte Carlo.\nNo entanto, o LCG pode não ser adequado para todas as aplicações, especialmente em criptografia, onde a previsibilidade é um problema. Para a maioria dos usos científicos e de simulação, ele ainda é uma escolha eficiente e simples.\n\n\n4.3.6 Efeito dos Parâmetros no Gerador Linear Congruente (LCG)\nOs parâmetros no Gerador Linear Congruente (LCG) têm um impacto significativo sobre a qualidade e as propriedades da sequência de números pseudoaleatórios gerados. Os parâmetros principais são:\n\nMultiplicador \\(a\\):\n\nEsse parâmetro é essencial para garantir que a sequência de números gerados tenha um bom período (o número de valores distintos antes de a sequência começar a se repetir). Se o valor de \\(a\\) não for bem escolhido, o período da sequência pode ser curto e a qualidade dos números gerados diminui.\nBons valores de \\(a\\) são cruciais para evitar padrões repetitivos ou ciclos curtos.\n\nIncremento \\(c\\):\n\nO incremento \\(c\\) adiciona um valor fixo à sequência e é um dos fatores que pode garantir que todos os valores no intervalo \\([0, m)\\) sejam atingidos em algum momento, desde que os outros parâmetros também sejam bem escolhidos.\nQuando \\(c = 0\\), o gerador é chamado de multiplicativo. Nessa forma, o LCG pode ter um comportamento menos uniforme.\n\nMódulo \\(m\\):\n\nO módulo define o intervalo dos números gerados. Comumente, \\(m\\) é escolhido como uma potência de 2 (por exemplo, \\(m = 2^{32}\\)) para facilitar os cálculos modulares em hardware e software.\nO valor de \\(m\\) também determina o período máximo da sequência de números. Com um módulo de \\(m\\), o período máximo teórico que o LCG pode ter é \\(m\\), mas isso depende da escolha correta dos parâmetros \\(a\\) e \\(c\\).\n\nSemente \\(X_0\\):\n\nA semente é o valor inicial de \\(X_0\\) usado pelo LCG para iniciar a sequência. Mudar a semente resultará em uma sequência diferente, mas com o mesmo período e comportamento determinado pelos outros parâmetros.\nA semente garante que o algoritmo possa ser reproduzido. Se dois programas utilizarem a mesma semente com os mesmos parâmetros, ambos produzirão a mesma sequência de números.\n\n\n\n\n4.3.7 Impacto dos Parâmetros:\n\nPeríodo da Sequência:\n\nO período é a quantidade de números gerados antes que a sequência comece a se repetir. Para obter o período máximo, os parâmetros \\(a\\), \\(c\\), \\(m\\) e a semente \\(X_0\\) precisam ser cuidadosamente escolhidos.\nSe os parâmetros não forem bons, o gerador pode produzir uma sequência com um ciclo muito curto ou, pior, um conjunto pequeno de valores.\n\nDistribuição dos Números:\n\nEmbora o LCG gere números no intervalo \\([0, 1)\\), o quão bem distribuídos esses números estão nesse intervalo depende dos parâmetros.\nParâmetros mal escolhidos podem causar uma distribuição não uniforme, onde certos intervalos terão mais números gerados que outros, levando a um comportamento indesejável.\n\nPadrões Repetitivos:\n\nSe os parâmetros forem mal escolhidos, podem surgir padrões repetitivos que comprometem a aleatoriedade dos números. Esses padrões tornam o LCG inadequado para algumas aplicações, como criptografia ou simulações que exigem alta qualidade de aleatoriedade.\n\n\nPor essas razões, a escolha dos parâmetros \\(a\\), \\(c\\), \\(m\\) e da semente \\(X_0\\) é crítica para garantir que o LCG produza números pseudoaleatórios de alta qualidade e com um período longo.\n\nRPython\n\n\n\n\nMostrar código\n# Carregando o pacote ggplot2\nlibrary(ggplot2)\n\n# Classe para o Gerador Congruente Linear\nLinearCongruentialGenerator &lt;- setRefClass(\n  \"LinearCongruentialGenerator\",\n  fields = list(a = \"numeric\", c = \"numeric\", m = \"numeric\", semente = \"numeric\"),\n  methods = list(\n    initialize = function(semente, a = 1103515245, c = 12345, m = 2^32) {\n      .self$a &lt;- a\n      .self$c &lt;- c\n      .self$m &lt;- m\n      .self$semente &lt;- semente\n    },\n    gerar = function() {\n      # Atualizando a semente\n      .self$semente &lt;- (.self$a * .self$semente + .self$c) %% .self$m\n      return(.self$semente / .self$m)  # Normalizando para [0, 1)\n    }\n  )\n)\n\n# Inicializando o gerador com uma semente\nlcg &lt;- LinearCongruentialGenerator$new(semente = 5)\n\n# Gerando 1000 números pseudoaleatórios\nnumeros_gerados &lt;- sapply(1:100000, function(x) lcg$gerar())\n\n# Convertendo para um data.frame\ndados &lt;- data.frame(numeros_gerados = numeros_gerados)\n\n# Plotando o histograma dos números gerados\nggplot(dados, aes(x = numeros_gerados)) +\n  geom_histogram(bins = 20, fill = 'skyblue', color = 'black') +\n  ggtitle('Histograma dos Números Pseudoaleatórios Gerados pelo LCG') +\n  xlab('Valor') +\n  ylab('Frequência') +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport matplotlib.pyplot as plt\n\nclass LinearCongruentialGenerator:\n    def __init__(self, semente, a=1103515245, c=12345, m=2**32):\n        self.a = a\n        self.c = c\n        self.m = m\n        self.semente = semente\n\n    def gerar(self):\n        # Atualizando a semente\n        self.semente = (self.a * self.semente + self.c) % self.m\n        return self.semente / self.m  # Normalizando para [0, 1)\n\n# Inicializando o gerador com uma semente\nlcg = LinearCongruentialGenerator(semente=5)\n\n# Gerando 1000 números pseudoaleatórios\nnumeros_gerados = [lcg.gerar() for _ in range(100000)]\n\n# Plotando o histograma dos números gerados\nplt.figure(figsize=(10, 6))\nplt.hist(numeros_gerados, bins=20, color='skyblue', edgecolor='black')\nplt.title('Histograma dos Números Pseudoaleatórios Gerados pelo LCG')\nplt.xlabel('Valor')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html#gerando-números-uniformes-com-uma-moeda",
    "href": "2_pseudorandom.html#gerando-números-uniformes-com-uma-moeda",
    "title": "4  Números Pseudoaleatórios",
    "section": "4.4 Gerando números uniformes com uma moeda",
    "text": "4.4 Gerando números uniformes com uma moeda\n\nRPython\n\n\n\n\nMostrar código\n# Carregando pacotes necessários\nlibrary(ggplot2)\n\n# Função para simular o lançamento de uma moeda justa\nlancar_moeda &lt;- function() {\n  # Lançar moeda justa: 0 para coroa (K) e 1 para cara (C)\n  sample(c(0, 1), 1)\n}\n\n# Função para gerar um número uniformemente distribuído usando uma moeda\ngerar_numero_uniforme &lt;- function(n_bits = 32) {\n  numero &lt;- 0\n  for (i in 1:n_bits) {\n    bit &lt;- lancar_moeda()\n    # Atualizando o número, multiplicando pela base 2\n    numero &lt;- numero + bit * (2^-(i))\n  }\n  return(numero)\n}\n\n# Gerando 10000 números uniformemente distribuídos\nnumeros_uniformes &lt;- sapply(1:10000, function(x) gerar_numero_uniforme())\n \n# Convertendo para um data.frame\ndados &lt;- data.frame(numeros_uniformes = numeros_uniformes)\n\n# Plotando o histograma dos números gerados\nggplot(dados, aes(x = numeros_uniformes)) +\n  geom_histogram(bins = 20, fill = 'skyblue', color = 'black') +\n  ggtitle('Histograma de Números Uniformes Gerados Usando uma Moeda Justa') +\n  xlab('Valor') +\n  ylab('Frequência') +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport random\nimport matplotlib.pyplot as plt\n\n# Função para simular o lançamento de uma moeda justa\ndef lancar_moeda():\n    # Lançar moeda justa: 0 para coroa (K) e 1 para cara (C)\n    return random.choice([0, 1])\n\n# Função para gerar um número uniformemente distribuído usando uma moeda\ndef gerar_numero_uniforme(n_bits=32):\n    numero = 0\n    for i in range(n_bits):\n        bit = lancar_moeda()\n        # Atualizando o número, multiplicando pela base 2\n        numero += bit * (2 ** -(i + 1))  # Cada bit tem um peso de 2^-(posição)\n    return numero\n\n# Gerando 1000 números uniformemente distribuídos\nnumeros_uniformes = [gerar_numero_uniforme() for _ in range(10000)]\n\n# Plotando o histograma dos números gerados\nplt.figure(figsize=(10, 6))\nplt.hist(numeros_uniformes, bins=20, color='skyblue', edgecolor='black')\nplt.title('Histograma de Números Uniformes Gerados Usando uma Moeda Justa')\nplt.xlabel('Valor')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html",
    "href": "3_discrete_inversion.html",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "",
    "text": "5.1 Geração de Variáveis Aleatórias Discretas Genéricas\nDado um conjunto de probabilidades \\(p(x_i)\\), onde \\(x_i\\) são os valores possíveis da variável aleatória discreta, e \\(p(x_i)\\) são suas respectivas probabilidades, a CDF \\(F(x)\\) é calculada como:\n\\[\nF(x_i) = \\sum_{j=1}^{i} p(x_j)\n\\]\nO algoritmo para gerar uma variável aleatória discreta genérica é:",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-discretas-genéricas",
    "href": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-discretas-genéricas",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "",
    "text": "Gerar um número aleatório \\(u \\in [0, 1)\\).\nEncontrar o menor valor \\(x_i\\) tal que \\(F(x_i) \\geq u\\).\nRetornar \\(x_i\\).\n\n\nRPython\n\n\n\n\nMostrar código\n# Exemplo de valores e probabilidades de uma variável aleatória discreta\nvalores &lt;- c(0, 1, 2, 3, 4, 5, 6)\nprobabilidades &lt;- c(0, 0.1, 0.2, 0.3, 0.25, 0.15, 0) \n\n# Calculando a CDF\ncdf &lt;- cumsum(probabilidades)\n\n# Gerando um número aleatório uniforme\nu &lt;- runif(1)\n\n# Encontrando o valor correspondente na CDF\nvalor_gerado &lt;- NA\nfor (i in seq_along(valores)) {\n  if (u &lt; cdf[i]) {\n    valor_gerado &lt;- valores[i]\n    break\n  }\n}\n\n# Ajustando o gráfico para corrigir a visualização da CDF e garantir que os valores estejam corretamente posicionados\nlibrary(ggplot2)\n\n# Criando um dataframe para os valores e CDF\ndf &lt;- data.frame(valores = valores, cdf = cdf)\n\n# Gráfico da CDF com número aleatório e valor gerado\nggplot(df, aes(x = valores, y = cdf)) +\n  geom_step(direction = \"hv\", color = \"blue\", size = 1.5) +\n  geom_hline(yintercept = u, color = \"red\", linetype = \"dashed\") +\n  geom_vline(xintercept = valor_gerado, color = \"green\", linetype = \"dashed\") +\n  labs(title = \"Técnica da Inversão para Geração de Variável Aleatória Discreta\",\n       x = \"Valores da Variável Aleatória\", \n       y = \"CDF\") +\n  annotate(\"text\", x = max(valores), y = u, label = sprintf(\"u = %.2f\", u), hjust = -0.1, vjust = -1) +\n  annotate(\"text\", x = valor_gerado, y = max(cdf), label = paste(\"Valor gerado =\", valor_gerado), hjust = -0.1, vjust = -0.5) +\n  theme_minimal() +\n  theme(panel.grid = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n \n# Exemplo de valores e probabilidades de uma variável aleatória discreta\nvalores = [0, 1, 2, 3, 4, 5, 6]\nprobabilidades = [0, 0.1, 0.2, 0.3, 0.25, 0.15, 0]\n\n# Calculando a CDF\ncdf = np.cumsum(probabilidades)\n\n# Gerando um número aleatório uniforme\nu = np.random.uniform(0, 1)\n\n# Encontre o valor correspondente na CDF\nvalor_gerado = None\nfor i, valor in enumerate(valores):\n    if u &lt; cdf[i]:\n        valor_gerado = valor\n        break\n# Ajustando o gráfico para corrigir a visualização da CDF e garantir que os valores estejam corretamente posicionados\nplt.figure(figsize=(10, 6))\n\n# Ajustando o eixo x para que a CDF comece e termine corretamente\nplt.step(valores, cdf, label='CDF', color='blue', linewidth=2, where='post')\nplt.axhline(y=u, color='red', linestyle='--', label=f'Número aleatório u = {u:.2f}')\nplt.axvline(x=valor_gerado, color='green', linestyle='--', label=f'Valor gerado = {valor_gerado}')\nplt.title('Técnica da Inversão para Geração de Variável Aleatória Discreta')\nplt.xlabel('Valores da Variável Aleatória')\nplt.ylabel('CDF')\nplt.legend()\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#inversa-da-cdf",
    "href": "3_discrete_inversion.html#inversa-da-cdf",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "5.2 Inversa da CDF",
    "text": "5.2 Inversa da CDF\nA inversa da CDF (função de distribuição acumulada), também conhecida como a função quantil ou função percentil, é uma função utilizada para gerar variáveis aleatórias a partir de uma distribuição específica.\nDefinição: Seja \\(F(x)\\) a função de distribuição acumulada (CDF) de uma variável aleatória \\(X\\). A inversa da CDF, denotada por \\(F^{-1}(p)\\), é definida como:\n\\[\nF^{-1}(p) = \\inf \\{ x \\in \\mathbb{R} : F(x) \\geq p \\}, \\quad \\text{para } p \\in [0, 1]\n\\]\nEm palavras: - A inversa da CDF \\(F^{-1}(p)\\) mapeia um número \\(p\\), que representa uma probabilidade acumulada, de volta ao valor \\(x\\) correspondente da variável aleatória \\(X\\), tal que a probabilidade acumulada até \\(x\\) é igual a \\(p\\). - Isso significa que, se \\(p = F(x)\\), então \\(F^{-1}(p) = x\\).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-com-distribuição-geométrica",
    "href": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-com-distribuição-geométrica",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "5.3 Geração de Variáveis Aleatórias com Distribuição Geométrica",
    "text": "5.3 Geração de Variáveis Aleatórias com Distribuição Geométrica\nA distribuição geométrica modela o número de tentativas até o primeiro sucesso em uma sequência de experimentos de Bernoulli. Se a probabilidade de sucesso em cada tentativa é \\(p\\), a PMF é dada por:\n\n5.3.1 Derivação da Inversa da CDF para a Distribuição Geométrica\nA fórmula da inversa da CDF para a distribuição geométrica foi obtida a partir da definição da função de distribuição acumulada (CDF) da distribuição geométrica e da aplicação da técnica da inversão.\n\n5.3.1.1 CDF da Distribuição Geométrica\nA função de distribuição acumulada (CDF) da distribuição geométrica com parâmetro \\(p\\) (a probabilidade de sucesso) para o número de falhas \\(k-1\\) antes do primeiro sucesso é dada por:\n\\[\nF(k) = 1 - (1 - p)^k\n\\]\nEssa equação expressa a probabilidade acumulada de obter o primeiro sucesso em até \\(k\\) tentativas.\n\n\n5.3.1.2 Inversa da CDF\nQueremos encontrar a inversa da CDF, ou seja, a fórmula que, dado um valor \\(u\\) entre 0 e 1, nos permita calcular o valor \\(k\\) tal que \\(F(k) = u\\).\nSabemos que:\n\\[\nu = F(k) = 1 - (1 - p)^k\n\\]\nNosso objetivo é resolver essa equação para \\(k\\). Vamos fazer isso passo a passo.\n\n\n5.3.1.3 Isolando o termo com \\(k\\)\nComeçamos isolando o termo \\((1 - p)^k\\):\n\\[\nu = 1 - (1 - p)^k\n\\]\nSubtraindo 1 de ambos os lados:\n\\[\nu - 1 = - (1 - p)^k\n\\]\nMultiplicando ambos os lados por \\(-1\\):\n\\[\n1 - u = (1 - p)^k\n\\]\n\n\n5.3.1.4 Aplicando o Logaritmo\nAgora aplicamos o logaritmo natural (log base \\(e\\)) em ambos os lados para resolver \\(k\\):\n\\[\n\\log(1 - u) = \\log((1 - p)^k)\n\\]\nUsando a propriedade dos logaritmos que permite trazer o expoente \\(k\\) para frente:\n\\[\n\\log(1 - u) = k \\cdot \\log(1 - p)\n\\]\n\n\n5.3.1.5 Isolando \\(k\\)\nAgora, isolamos \\(k\\):\n\\[\nk = \\frac{\\log(1 - u)}{\\log(1 - p)}\n\\]\nComo \\(k\\) precisa ser um número inteiro (já que a distribuição geométrica conta o número de tentativas), usamos a função de arredondamento “para cima” (\\(\\lceil \\cdot \\rceil\\)), conhecida como a função teto:\n\\[\nk = \\lceil \\frac{\\log(1 - u)}{\\log(1 - p)} \\rceil\n\\]\n\n\n\n5.3.2 Conclusão\nPortanto, a fórmula da inversa da CDF da distribuição geométrica é:\n\\[\nk = \\lceil \\frac{\\log(1 - u)}{\\log(1 - p)} \\rceil\n\\]\nEsta fórmula nos permite gerar variáveis aleatórias com distribuição geométrica a partir de um número aleatório uniforme \\(u \\in [0, 1)\\).\n\nRPython\n\n\n\n\nMostrar código\n# Função para gerar a inversa da CDF para a distribuição geométrica\ninversa_cdf_geometrica &lt;- function(p, u) {\n  # Usando a fórmula inversa da CDF geométrica: F⁻¹(u) = ceil(log(1 - u) / log(1 - p))\n  k &lt;- ceiling(log(1 - u) / log(1 - p))\n  return(as.integer(k))\n}\n\n# Parâmetro p da distribuição geométrica\np &lt;- 0.5\n\n# Gerando 1000 números uniformemente distribuídos\nuniformes &lt;- runif(1000)\n\n# Gerando a variável aleatória geométrica correspondente para cada número uniforme\ngeometricas &lt;- sapply(uniformes, inversa_cdf_geometrica, p = p)\n\n# Plotando um histograma das variáveis geométricas geradas\nlibrary(ggplot2)\n\ndf &lt;- data.frame(geometricas = geometricas)\nggplot(df, aes(x = geometricas)) +\n  geom_histogram(bins = max(geometricas) + 1, color = \"black\", fill = \"skyblue\", boundary = 0, closed = \"left\") +\n  labs(title = \"Histograma de Variáveis Aleatórias Geométricas Usando a Inversa da CDF\",\n       x = \"Valor da Variável Aleatória Geométrica\", \n       y = \"Frequência\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n\n\nMostrar código\n# Função para calcular a CDF da distribuição geométrica\ncdf_geometrica &lt;- function(k, p) {\n  return(1 - (1 - p)^k)\n}\n\n# Gerando valores de k para plotar a CDF\nk_values &lt;- 1:20\ncdf_values &lt;- sapply(k_values, cdf_geometrica, p = p)\n\n# Plotando a CDF da distribuição geométrica\ndf_cdf &lt;- data.frame(k_values = k_values, cdf_values = cdf_values)\nggplot(df_cdf, aes(x = k_values, y = cdf_values)) +\n  geom_step(direction = \"hv\", color = \"blue\", size = 1.5) +\n  labs(title = \"CDF da Distribuição Geométrica (p = 0.5)\",\n       x = \"k (Número de tentativas até o primeiro sucesso)\", \n       y = \"F(k)\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Função para gerar a inversa da CDF para a distribuição geométrica\ndef inversa_cdf_geometrica(p, u):\n    # Usando a fórmula inversa da CDF geométrica: F⁻¹(u) = ceil(log(1 - u) / log(1 - p))\n    k = np.ceil(np.log(1 - u) / np.log(1 - p))\n    return int(k)\n\n# Parâmetro p da distribuição geométrica\np = 0.5\n\n# Gerando 100 números uniformemente distribuídos\nuniformes = np.random.uniform(0, 1, 1000)\n\n# Gerando a variável aleatória geométrica correspondente para cada número uniforme\ngeometricas = [inversa_cdf_geometrica(p, u) for u in uniformes]\n\n# Plotando um histograma das variáveis geométricas geradas\nplt.figure(figsize=(10, 6))\nplt.hist(geometricas, bins=range(1, max(geometricas) + 1), color='skyblue', edgecolor='black', align='left')\nplt.title('Histograma de Variáveis Aleatórias Geométricas Usando a Inversa da CDF')\nplt.xlabel('Valor da Variável Aleatória Geométrica')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nMostrar código\n# Calculando a CDF para a distribuição geométrica\ndef cdf_geometrica(k, p):\n    return 1 - (1 - p)**k\n\n# Gerando valores de k para plotar a CDF\nk_values = np.arange(1, 21)\ncdf_values = [cdf_geometrica(k, p) for k in k_values]\n\n# Plotando a CDF da distribuição geométrica\nplt.figure(figsize=(10, 6))\nplt.step(k_values, cdf_values, where='post', color='blue', label='CDF Geométrica', linewidth=2)\nplt.title('CDF da Distribuição Geométrica (p = 0.3)')\nplt.xlabel('k (Número de tentativas até o primeiro sucesso)')\nplt.ylabel('F(k)')\nplt.grid(True)\nplt.legend()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-com-distribuição-poisson",
    "href": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-com-distribuição-poisson",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "5.4 Geração de Variáveis Aleatórias com Distribuição Poisson",
    "text": "5.4 Geração de Variáveis Aleatórias com Distribuição Poisson\nA distribuição de Poisson é usada para modelar o número de eventos que ocorrem em um intervalo de tempo ou espaço fixo, onde os eventos ocorrem com uma taxa constante \\(\\lambda\\) e de forma independente.\nA função de probabilidade de massa (PMF) da distribuição de Poisson é dada por:\n\\[\nP(X = k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}, \\quad k = 0, 1, 2, \\ldots\n\\]\n\n5.4.1 Derivação da Inversa da CDF para a Distribuição Poisson Usando a Fórmula Recursiva\nA distribuição de Poisson tem uma fórmula recursiva que pode ser usada para calcular as probabilidades de forma mais eficiente. Em vez de recalcular a probabilidade \\(P(X = k)\\) a cada vez, podemos usar a seguinte relação recursiva:\n\\[\nP(X = k+1) = \\frac{\\lambda}{k+1} \\cdot P(X = k)\n\\]\nOnde \\(P(X = 0) = e^{-\\lambda}\\).\nEssa relação recursiva permite gerar variáveis aleatórias de Poisson sem precisar calcular fatoriais repetidamente, o que é mais eficiente para grandes valores de \\(\\lambda\\) ou grandes números de eventos \\(k\\).\n\n\n5.4.2 Técnica da Inversão Usando a Fórmula Recursiva\nPara gerar uma variável aleatória de Poisson usando a técnica da inversão e a fórmula recursiva, o processo é o seguinte:\n\nGerar um número aleatório uniforme \\(u \\in [0, 1)\\).\nCalcular a CDF acumulada para valores de \\(k\\), somando as probabilidades da PMF (usando a relação recursiva) até que a CDF acumulada seja maior ou igual a \\(u\\).\nO menor valor \\(k\\) tal que \\(F(k) \\geq u\\) será o número de eventos gerado pela distribuição Poisson.\n\n\n\n5.4.3 Explicação:\n\nFórmula Recursiva: A relação recursiva \\(P(X = k+1) = \\frac{\\lambda}{k+1} \\cdot P(X = k)\\) permite calcular as probabilidades de forma eficiente, atualizando a probabilidade de \\(P(X = k+1)\\) a partir de \\(P(X = k)\\).\nEficiência: Esta técnica evita o cálculo repetido de fatoriais, tornando-a mais eficiente, especialmente quando se está gerando variáveis para grandes valores de \\(\\lambda\\) ou quando se deseja calcular probabilidades para muitos eventos \\(k\\).\n\nEste método é amplamente utilizado por ser mais rápido e computacionalmente eficiente para a geração de variáveis aleatórias de Poisson.\n\nRPython\n\n\n\n\nMostrar código\n# Função para gerar a inversa da CDF para a distribuição Poisson usando a técnica de inversão e a fórmula recursiva\ninversa_cdf_poisson_recursiva &lt;- function(lam, u) {\n  k &lt;- 0\n  p &lt;- exp(-lam)  # P(X=0)\n  F &lt;- p  # Iniciamos com a probabilidade P(X=0)\n  \n  # Continuamos somando até que F &gt;= u\n  while (u &gt; F) {\n    k &lt;- k + 1\n    p &lt;- p * lam / k  # Atualiza a probabilidade recursivamente para o próximo valor\n    F &lt;- F + p\n  }\n  \n  return(k)\n}\n\n# Parâmetro lambda da distribuição Poisson\nlam &lt;- 3\n\n# Gerando 1000 números uniformemente distribuídos\nuniformes &lt;- runif(1000)\n\n# Gerando a variável aleatória Poisson correspondente para cada número uniforme\npoisson_vars &lt;- sapply(uniformes, inversa_cdf_poisson_recursiva, lam = lam)\n\n# Plotando o histograma das variáveis Poisson geradas\nlibrary(ggplot2)\n\ndf &lt;- data.frame(poisson_vars = poisson_vars)\nggplot(df, aes(x = poisson_vars)) +\n  geom_histogram(bins = max(poisson_vars) + 1, color = \"black\", fill = \"skyblue\", boundary = 0, closed = \"left\") +\n  labs(title = \"Histograma de Variáveis Aleatórias Poisson Usando a Fórmula Recursiva (λ = 3)\",\n       x = \"Valor da Variável Aleatória Poisson\", \n       y = \"Frequência\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n\n\nMostrar código\n# Função para calcular a CDF da distribuição Poisson\ncdf_poisson &lt;- function(k, lam) {\n  cdf &lt;- 0\n  p &lt;- exp(-lam)  # P(X=0)\n  for (i in 0:k) {\n    cdf &lt;- cdf + p  # Adiciona a probabilidade à CDF\n    if (i &lt; k) {\n      p &lt;- p * lam / (i + 1)  # Atualiza a probabilidade recursivamente\n    }\n  }\n  return(cdf)\n}\n\n# Gerando valores de k para a CDF\nk_values &lt;- 0:14\ncdf_values &lt;- sapply(k_values, cdf_poisson, lam = lam)\n\n# Plotando a CDF da distribuição Poisson\ndf_cdf &lt;- data.frame(k_values = k_values, cdf_values = cdf_values)\nggplot(df_cdf, aes(x = k_values, y = cdf_values)) +\n  geom_step(direction = \"hv\", color = \"blue\", size = 1.5) +\n  labs(title = \"CDF da Distribuição Poisson Usando a Fórmula Recursiva (λ = 3)\",\n       x = \"k (Número de eventos)\", \n       y = \"F(k)\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\n\n# Função para gerar a inversa da CDF para a distribuição Poisson usando a técnica de inversão e a fórmula recursiva\ndef inversa_cdf_poisson_recursiva(lam, u):\n    k = 0\n    p = math.exp(-lam)  # P(X=0)\n    F = p  # Iniciamos com a probabilidade P(X=0)\n    \n    # Continuamos somando até que F &gt;= u\n    while u &gt; F:\n        k += 1\n        p = p * lam / k  # Atualiza a probabilidade recursivamente para o próximo valor\n        F += p\n    \n    return k\n\n# Parâmetro lambda da distribuição Poisson\nlam = 3\n\n# Gerando 1000 números uniformemente distribuídos\nuniformes = np.random.uniform(0, 1, 1000)\n\n# Gerando a variável aleatória Poisson correspondente para cada número uniforme\npoisson_vars = [inversa_cdf_poisson_recursiva(lam, u) for u in uniformes]\n\n# Plotando o histograma das variáveis Poisson geradas\nplt.figure(figsize=(10, 6))\nplt.hist(poisson_vars, bins=range(0, max(poisson_vars) + 1), color='skyblue', edgecolor='black', align='left')\nplt.title('Histograma de Variáveis Aleatórias Poisson Usando a Fórmula Recursiva (λ = 3)')\nplt.xlabel('Valor da Variável Aleatória Poisson')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nMostrar código\n# Calculando a CDF da distribuição Poisson\ndef cdf_poisson(k, lam):\n    cdf = 0\n    p = math.exp(-lam)  # P(X=0)\n    for i in range(k+1):\n        cdf += p  # Adiciona a probabilidade à CDF\n        if i &lt; k:  # Atualiza a probabilidade recursivamente\n            p = p * lam / (i + 1)\n    return cdf\n\n# Gerando valores de k para a CDF\nk_values = np.arange(0, 15)\ncdf_values = [cdf_poisson(k, lam) for k in k_values]\n\n# Plotando a CDF da distribuição Poisson\nplt.figure(figsize=(10, 6))\nplt.step(k_values, cdf_values, where='post', color='blue', label='CDF Poisson', linewidth=2)\nplt.title('CDF da Distribuição Poisson Usando a Fórmula Recursiva (λ = 3)')\nplt.xlabel('k (Número de eventos)')\nplt.ylabel('F(k)')\nplt.grid(True)\nplt.legend()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#exercícios",
    "href": "3_discrete_inversion.html#exercícios",
    "title": "5  Técnica da Inversão para Variáveis Discretas",
    "section": "5.5 Exercícios",
    "text": "5.5 Exercícios\nExercício 1. Seja \\(X\\) uma v.a. tal que \\(\\mathbb P(X=1)=0.3,\\mathbb P(X=3)=0.1\\) e \\(\\mathbb P(X=4)=0.6\\).\n\nEscreva um pseudo-algoritmo para gerar um valor de \\(X\\).\nImplemente uma função para gerar \\(n\\) valores de \\(X\\).\nCompare a distribuição das frequências obtidas na amostra simulada com as probabilidades reais.\n\nExercício 2. Considere \\(X\\) uma v.a. tal que\n\\[\n\\mathbb{P}(X=i) = \\alpha \\mathbb{P}(X_1=i) + (1-\\alpha) \\mathbb{P}(X_2=i), \\quad i=0,1,\\dots\n\\]\nonde \\(0 \\leq \\alpha \\leq 1\\) e \\(X_1, X_2\\) são v.a. discretas.\nA distribuição de \\(X\\) é chamada de distribuição de mistura. Podemos escrever\n\\[\nX = \\begin{cases}\nX_1, & \\text{com probabilidade } \\alpha \\\\\nX_2, & \\text{com probabilidade } 1-\\alpha\n\\end{cases}\n\\]\nPseudo-Algoritmo:\n\nSeja \\(U\\sim Unif(0,1)\\)\nSe \\(U \\leq \\alpha\\), gere um valor da distribuição de \\(X_1\\). Senão, gere um valor da distribuição de \\(X_2\\)\n\nCom base no pseudo-algorimo implemente um algoritmo para gerar uma amostra de tamanho \\(n\\) da distribuição mistura de uma Poisson e de uma Geométrica com base nas funções implementadas nos Exercícios (2) e (3).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html",
    "href": "4_continuous_inversion.html",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "",
    "text": "6.1 Função Inversa\nSabemos que \\(F: \\mathbb{R} \\to [0,1]\\) é estritamente crescente quando \\(X\\) é continua, e, portanto, podemos definir sua função inversa \\(F^{-1}: [0,1] \\to \\mathbb{R}\\). A seguinte figura ilustra \\(F\\) e sua inversa.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#função-inversa",
    "href": "4_continuous_inversion.html#função-inversa",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "",
    "text": "RPython\n\n\n\n\nMostrar código\n# Carregando as bibliotecas necessárias\nlibrary(ggplot2)\n\n# Definindo a função de distribuição acumulada F(x) - função logística\nF &lt;- function(x) {\n  return(1 / (1 + exp(-x)))\n}\n\n# Definindo a inversa da função de distribuição acumulada F_inv(u)\nF_inv &lt;- function(u) {\n  return(-log((1 / u) - 1))\n}\n\n# Gerando valores de x e u\nx &lt;- seq(-4, 10, length.out = 400)\nu &lt;- seq(0.01, 0.99, length.out = 400)\n\n# Definindo o valor de U para plotar as linhas\nu_value &lt;- 0.7\nx_value &lt;- F_inv(u_value)\n\n# Criando o gráfico\nggplot(data = data.frame(x = x, F_x = F(x))) +\n  geom_line(aes(x = x, y = F_x), color = \"black\") +\n  geom_hline(yintercept = u_value, linetype = \"dotted\", color = \"red\") +\n  geom_vline(xintercept = x_value, linetype = \"dotted\", color = \"red\") +\n  annotate(\"text\", x = x_value - 0.4, y = -0, label = expression(F^{-1}(u)), color = \"red\", size = 5) +\n  annotate(\"text\", x = -5.5, y = u_value - 0.02, label = \"u\", color = \"red\", size = 5) +\n  labs(title = \"Representação da Função de Distribuição Acumulada e sua Inversa\",\n       x = \"x\", y = \"F(x)\") +\n  ylim(0, 1.2) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n \n# Definindo a função de distribuição acumulada F(x)\ndef F(x):\n    return 1 / (1 + np.exp(-x))  # Função logística como exemplo de F(x)\n\n# Definindo a inversa da função de distribuição acumulada F_inv(u)\ndef F_inv(u):\n    return -np.log((1 / u) - 1)\n\n# Gerando valores de x e u para plotar\nx = np.linspace(-4, 10, 400)\nu = np.linspace(0.01, 0.99, 400)  # U entre 0 e 1 (evitando extremos para evitar erros na inversa)\n\n# Plotando a função de distribuição acumulada F(x) com truncamento do eixo y no zero\nplt.figure(figsize=(8, 6))\nplt.plot(x, F(x), color=\"black\")\n\n# Adicionando linhas pontilhadas para representar U e F_inv(U)\nu_value = 0.7  # Exemplo de valor de U\nx_value = F_inv(u_value)\n\nplt.hlines(u_value, min(x), x_value, linestyles='dotted', colors='red')\nplt.vlines(x_value, 0, u_value, linestyles='dotted', colors='red')\n\n# Etiquetas\nplt.text(x_value-0.4 , -0.05, r\"$F^{-1}(u)$\", fontsize=12, color='red')\nplt.text(-5.5, u_value - 0.02, r\"$u$\", fontsize=14, color='red')\n\n# Rótulos e estilo do gráfico\nplt.title(r'Representação da Função de Distribuição Acumulada e sua Inversa', fontsize=14)\nplt.xlabel(r'$x$', fontsize=12)\nplt.ylabel(r'$F(x)$', fontsize=12)\nplt.ylim(0, 1.2)\n\n\n(0.0, 1.2)\n\n\nMostrar código\nplt.xlim(-4, 10)\n\n\n(-4.0, 10.0)\n\n\nMostrar código\nplt.grid(True)\n\n# Exibir o gráfico\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#método-da-inversão",
    "href": "4_continuous_inversion.html#método-da-inversão",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "6.2 Método da Inversão",
    "text": "6.2 Método da Inversão\nUma maneira de gerar valores de uma variável aleatória contínua \\(X\\), é o método da inversão, que é originado da seguinte proposição:\nProposição: Seja \\(U \\sim \\text{Unif}(0,1)\\). Para qualquer variável aleatória contínua com função de distribuição acumulada \\(F\\), a variável: \\[\nX = F^{-1}(U)\n\\] tem distribuição \\(F\\).\nProva: \\[\n\\mathbb{P}(X \\leq x) = \\mathbb{P}(F^{-1}(U) \\leq x) = \\mathbb{P}(F(F^{-1}(U)) \\leq F(x)) = \\mathbb{P}(U \\leq F(x)) = F(x).\n\\]\nAssim, o método da inversão consiste em:\n\nGerar \\(U \\sim \\text{Unif}(0,1)\\).\nCalcular \\(X = F^{-1}(U)\\).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#exemplo-1",
    "href": "4_continuous_inversion.html#exemplo-1",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "6.3 Exemplo 1",
    "text": "6.3 Exemplo 1\nSeja \\(X\\) uma v.a. com: \\[\nF(x) = x^n, \\quad \\text{para } 0 &lt; x &lt; 1.\n\\]\nA função inversa é: \\[\nu = F(x) = x^n \\implies x = u^{1/n}.\n\\]\nPortanto, o pseudo-algoritmo para gerar \\(X\\) a partir do método da inversão é:\n\nGere \\(U \\sim \\text{Unif}(0,1)\\).\nCalcule \\(X = U^{1/n}\\).\n\n\n\n\nRPython\n\n\n\n\nMostrar código\n# Carregar a biblioteca ggplot2\nlibrary(ggplot2)\n\n# Definir o parâmetro n da distribuição F(x) = x^n\nn &lt;- 3\n\n# Gerar 1000 valores U de uma distribuição uniforme (0,1)\nU &lt;- runif(1000, min = 0, max = 1)\n\n# Calcular X = U^(1/n)\nX &lt;- U^(1/n)\n\n# Criar um dataframe para o ggplot2\ndata &lt;- data.frame(X = X)\n\n# Plotar o histograma usando ggplot2\np &lt;- ggplot(data, aes(x = X)) +\n  geom_histogram(aes(y = ..density..), bins = 30, fill = 'skyblue', color = 'black') +\n  labs(title = 'Histograma de variáveis geradas pela inversão: F(x) = x^n, n = 3',\n       x = 'Valor de X', y = 'Frequência') +\n  theme_minimal() +\n  theme(plot.title = element_text(size = 14),\n        axis.title.x = element_text(size = 12),\n        axis.title.y = element_text(size = 12))\n\n# Exibir o gráfico\nprint(p)\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parâmetro n da distribuição F(x) = x^n\nn = 3\n\n# Gerando 1000 valores U de uma distribuição uniforme (0,1)\nU = np.random.uniform(0, 1, 1000)\n\n# Calculando X = U^(1/n)\nX = U**(1/n)\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(X, bins=30, color='skyblue', edgecolor='black', density=True)\nplt.title('Histograma de variáveis geradas pela inversão: F(x) = x^n, n = 3')\nplt.xlabel('Valor de X')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.3.1 Exemplo 2\nSeja \\(X \\sim \\text{Exp}(\\lambda)\\), com: \\[\nF(x) = 1 - e^{-\\lambda x}, \\quad \\text{para } x &gt; 0.\n\\]\nA função inversa é: \\[\nu = F(x) = 1 - e^{-\\lambda x} \\implies x = -\\frac{\\log(1 - u)}{\\lambda}.\n\\]\nUm pseudo-algoritmo para gerar \\(X\\) é, portanto,:\n\nGere \\(U \\sim \\text{Unif}(0,1)\\).\nCalcule \\(X = -\\frac{\\log(1 - U)}{\\lambda}\\).\n\n\nRPython\n\n\n\n\nMostrar código\n# Carregar a biblioteca ggplot2\nlibrary(ggplot2)\n\n# Definir o parâmetro lambda da distribuição exponencial\nlambda &lt;- 2\n\n# Gerar 1000 valores U de uma distribuição uniforme (0,1)\nU &lt;- runif(1000, min = 0, max = 1)\n\n# Calcular X usando a inversa da CDF da distribuição exponencial\nX &lt;- -log(1 - U) / lambda\n\n# Criar um dataframe para o ggplot2\ndata &lt;- data.frame(X = X)\n\n# Plotar o histograma usando ggplot2\np &lt;- ggplot(data, aes(x = X)) +\n  geom_histogram(aes(y = ..density..), bins = 30, fill = 'lightcoral', color = 'black') +\n  labs(title = 'Histograma de variáveis geradas pela inversão: Distribuição Exponencial',\n       x = 'Valor de X', y = 'Frequência') +\n  theme_minimal() +\n  theme(plot.title = element_text(size = 14),\n        axis.title.x = element_text(size = 12),\n        axis.title.y = element_text(size = 12))\n\n# Exibir o gráfico\nprint(p)\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parâmetro lambda da distribuição exponencial\nlambd = 2\n\n# Gerando 1000 valores U de uma distribuição uniforme (0,1)\nU = np.random.uniform(0, 1, 1000)\n\n# Calculando X usando a inversa da CDF da exponencial\nX = -np.log(1 - U) / lambd\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(X, bins=30, color='lightcoral', edgecolor='black', density=True)\nplt.title('Histograma de variáveis geradas pela inversão: Distribuição Exponencial')\nplt.xlabel('Valor de X')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#simulação-de-transformações-de-variáveis-aleatórias",
    "href": "4_continuous_inversion.html#simulação-de-transformações-de-variáveis-aleatórias",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "6.4 Simulação de transformações de variáveis aleatórias",
    "text": "6.4 Simulação de transformações de variáveis aleatórias\nAgora que já sabemos uma maneira de simular uma variável aleatória \\(X\\), descreveremos como gerar valores de uma transformação dessa variável, ou seja, \\(g(X)\\). Para isso, basta aplicar a função de transformação \\(g\\) diretamente aos valores simulados de \\(X\\). Veremos a seguinte alguns exemplos disso em funcionamento.\n\n\n6.4.1 Exemplo 1: Simulando \\(Y \\sim Unif(1, 2)\\)\nPara gerar valores de \\(Y \\sim Unif(1, 2)\\), usamos o fato de que \\(Y\\) é uma simples transformação de \\(U \\sim Unif(0, 1)\\). A relação é: \\[\nY = U + 1.\n\\]\nAssim, podemos usar o seguinte pseudo-algoritmo para gerar \\(Y\\) a partir de \\(U\\):\n\nGere \\(U \\sim Unif(0,1)\\).\nCalcule \\(Y = U + 1\\).\n\n\nRPython\n\n\n\n\nMostrar código\n# Carregar biblioteca ggplot2\nlibrary(ggplot2)\n\n# Gerar 1000 valores U de uma distribuição uniforme (0,1)\nU &lt;- runif(1000, min = 0, max = 1)\n\n# Calcular Y = U + 1 para ter Y ~ Unif(1, 2)\nY &lt;- U + 1\n\n# Criar um dataframe para o ggplot2\ndata &lt;- data.frame(Y = Y)\n\n# Plotar o histograma usando ggplot2\np &lt;- ggplot(data, aes(x = Y)) +\n  geom_histogram(aes(y = ..density..), bins = 30, fill = 'skyblue', color = 'black') +\n  labs(title = 'Histograma de variáveis geradas: Y ~ Unif(1, 2)',\n       x = 'Valor de Y', y = 'Frequência') +\n  theme_minimal() +\n  theme(plot.title = element_text(size = 14),\n        axis.title.x = element_text(size = 12),\n        axis.title.y = element_text(size = 12))\n\n# Exibir o gráfico\nprint(p)\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Gerando 1000 valores U de uma distribuição uniforme (0,1)\nU = np.random.uniform(0, 1, 1000)\n\n# Calculando Y = U + 1 para ter Y ~ Unif(1, 2)\nY = U + 1\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(Y, bins=30, color='skyblue', edgecolor='black', density=True)\nplt.title('Histograma de variáveis geradas: Y ~ Unif(1, 2)')\nplt.xlabel('Valor de Y')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.4.2 Exemplo 2: Simulando \\(Y \\sim Gamma(n, \\lambda)\\)\nPara gerar valores de \\(Y \\sim \\Gamma(n, \\lambda)\\), usamos o fato de que a soma de que \\(Y\\) pode ser representado como \\[Y= \\sum_{i=1}^n X_i,\\] em que cada \\(X_i \\sim Exp(\\lambda)\\), e \\(X_i\\)’s são independentes.\nAssim, podemos gerar \\(Y\\) da seguinte forma:\n\nGere \\(U_1, \\dots, U_n \\sim Unif(0,1)\\) independentemente.\nCalcule \\(X_i = -\\frac{\\log(1 - U_i)}{\\lambda}\\) para \\(i = 1, \\dots, n\\).\nCalcule \\(Y = X_1 + X_2 + \\dots + X_n\\).\n\n\nRPython\n\n\n\n\nMostrar código\n# Carregar biblioteca ggplot2\nlibrary(ggplot2)\n\n# Definir parâmetros\nn &lt;- 5  # número de somas\nlambda &lt;- 2  # parâmetro da distribuição exponencial\n\n# Gerar 1000 valores U para cada uma das n somas\nU &lt;- matrix(runif(1000 * n, min = 0, max = 1), ncol = n)\n\n# Calcular X_i = -log(1 - U_i) / lambda para cada U_i\nX &lt;- -log(1 - U) / lambda\n\n# Somar os valores de X para obter Y ~ Gamma(n, lambda)\nY &lt;- rowSums(X)\n\n# Criar um dataframe para o ggplot2\ndata &lt;- data.frame(Y = Y)\n\n# Plotar o histograma usando ggplot2\np &lt;- ggplot(data, aes(x = Y)) +\n  geom_histogram(aes(y = ..density..), bins = 30, fill = 'lightcoral', color = 'black') +\n  labs(title = paste('Histograma de variáveis geradas: Y ~ Gamma(', n, ', ', lambda, ')'),\n       x = 'Valor de Y', y = 'Frequência') +\n  theme_minimal() +\n  theme(plot.title = element_text(size = 14),\n        axis.title.x = element_text(size = 12),\n        axis.title.y = element_text(size = 12))\n\n# Exibir o gráfico\nprint(p)\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\n# Definindo parâmetros\nn = 5  # número de somas\nlambd = 2  # parâmetro da distribuição exponencial\n\n# Gerando 1000 valores U para cada uma das n somas\nU = np.random.uniform(0, 1, (1000, n))\n\n# Calculando X_i = -log(1 - U_i) / lambda para cada U_i\nX = -np.log(1 - U) / lambd\n\n# Somando os valores de X para obter Y ~ Gamma(n, lambda)\nY = np.sum(X, axis=1)\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(Y, bins=30, color='lightcoral', edgecolor='black', density=True)\nplt.title(f'Histograma de variáveis geradas: Y ~ Gamma({n}, {lambd})')\nplt.xlabel('Valor de Y')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#exercícios",
    "href": "4_continuous_inversion.html#exercícios",
    "title": "6  Técnica da Inversão para Variáveis Contínuas",
    "section": "6.5 Exercícios",
    "text": "6.5 Exercícios\nExercício 1.\nUtilizando o método da inversão, simule \\(U \\sim U(1,3)\\).\nExercício 2.\n\nImplemente uma função para gerar uma amostra de tamanho \\(n\\) da distribuição Exponencial de parâmetro \\(\\lambda\\).\nCompare a distribuição empírica dos valores simulados com a densidade da Exponencial \\(f(x)=\\lambda e^{-\\lambda x}, x&gt;0\\).\n\nExercício 3.\n\nImplemente uma função para gerar uma amostra de tamanho \\(n\\) da distribuição \\(Gama(a,b)\\), para \\(a\\) sendo um valor inteiro.\nCompare a distribuição empírica dos valores simulados com a densidade da Gama \\(f(x)=\\frac{b^a}{\\Gamma(a)}x^{a-1}e^{-bx}, x&gt;0\\).\n\nExercício 4. Seja \\(X\\) uma v.a. com função densidade dada por:\n\\[f(x) = \\frac{1}{8}x,\\quad 0 &lt; x &lt; 4.\\]\n\nEscreva um pseudo-algoritmo para simular um único valor da variável \\(X\\) pelo método da inversão.\nCompare a distribuição empírica dos valores simulados com a densidade de \\(X\\).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Técnica da Inversão para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "5_discrete_rejection.html",
    "href": "5_discrete_rejection.html",
    "title": "7  Método da Rejeição para Variáveis Discretas",
    "section": "",
    "text": "Fill in",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Método da Rejeição para Variáveis  Discretas</span>"
    ]
  },
  {
    "objectID": "6_continuous_rejection.html",
    "href": "6_continuous_rejection.html",
    "title": "8  Método da Rejeição para Variáveis Contínuas",
    "section": "",
    "text": "8.1 Algoritmo\nO método assume que conhecemos uma distribuição \\(g(x)\\), fácil de simular, que cubra o suporte da distribuição alvo \\(f(x)\\). Essa distribuição é chamada de distribuição proposta. Além disso ele assume que existe \\(c\\) tal que \\(\\frac{f(x)}{g(x)} \\leq c\\) para todo \\(x\\), e que conseguimos calcular \\(c\\). O método de aceitação e rejeição segue os seguintes passos:\nA figura a seguir ilustra esse processo quando \\(g\\) é uma distribuição uniforme entre 0 e 1.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "6_continuous_rejection.html#algoritmo",
    "href": "6_continuous_rejection.html#algoritmo",
    "title": "8  Método da Rejeição para Variáveis Contínuas",
    "section": "",
    "text": "Gere um valor \\(Y\\) da distribuição proposta \\(g(x)\\).\nGere um valor \\(U \\sim \\text{Uniform}(0, 1)\\).\nAceite \\(Y\\) como uma amostra de \\(f(x)\\) se \\(U \\leq \\frac{f(Y)}{c \\cdot g(Y)}\\), caso contrário, rejeite \\(Y\\) e repita o processo.\n\n\n\nRPython\n\n\n\n\nMostrar código\nlibrary(ggplot2)\n\n# Função densidade alvo f(x)\nf &lt;- function(x) {\n  20 * x * (1 - x)^3\n}\n\n# Função densidade proposta g(x) (distribuição uniforme)\ng &lt;- function(x) {\n  rep(1, length(x))  # g(x) é uniforme no intervalo (0, 1)\n}\n\n# Constante c (máximo de f(x))\nopt_result &lt;- optimize(f = function(x) -f(x), interval = c(0, 1))\nc &lt;- f(opt_result$minimum)\n\n# Gerar valores de x\nx &lt;- seq(0, 1, length.out = 1000)\n\n# Valor de Y para aceitar/rejeitar (escolhido aleatoriamente)\nY &lt;- 0.6\n\n# DataFrame para o gráfico\ndf &lt;- data.frame(x = x, fx = f(x), gx = c * g(x))\n\n# Plotando as funções f(x) e a linha horizontal c*g(x)\nggplot(df, aes(x = x)) +\n  geom_line(aes(y = fx, color = \"f(x)\"), size = 1) +\n  geom_hline(aes(yintercept = c * g(x), color = \"c * g(x)\"), size = 1.5) +\n  \n  # Destacar a área de aceitação e rejeição\n  geom_text(aes(x = Y + 0.025, y = 0.05, label = \"Y\"), color = \"black\", size = 5) +\n  \n  geom_segment(aes(x = Y, xend = Y, y = 0, yend = f(Y)), color = \"green\", size = 1.5) +\n  geom_segment(aes(x = Y, xend = Y, y = f(Y), yend = c * g(Y)), color = \"red\", size = 1.5) +\n  \n  # Mover rótulos de Aceitar/Rejeitar para a esquerda da linha Y\n  geom_text(aes(x = Y + 0.06, y = f(Y) / 2, label = \"Aceitar x\"), color = \"green\", size = 4) +\n  geom_text(aes(x = Y + 0.06, y = f(Y) + (c * g(Y) - f(Y)) / 2, label = \"Rejeitar x\"), color = \"red\", size = 4) +\n  \n  # Limites e rótulos\n  xlim(0, 1) +\n  ylim(0, 2.5) +\n  labs(x = \"x\", y = \"Densidade\", title = \"Amostragem por Rejeição para g uniforme\") +\n  \n  # Legenda\n  scale_color_manual(values = c(\"f(x)\" = \"black\", \"c * g(x)\" = \"blue\"), name = \"Funções\") +\n  \n  theme_minimal() +\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import minimize_scalar\n\n# Função densidade alvo f(x)\ndef f(x):\n    return 20 * x * (1 - x)**3\n\n# Função densidade proposta g(x) (distribuição uniforme)\ndef g(x):\n    return 1  # g(x) é uniforme no intervalo (0, 1)\n\n# Constante c\nresult = minimize_scalar(lambda x: -f(x), bounds=(0, 1), method='bounded')\nc = f(result.x)\n\n# Gerar valores de x\nx = np.linspace(0, 1, 1000)\n\n# Valor de Y para aceitar/rejeitar (escolhido aleatoriamente)\nY = 0.6\nU = 0.8\naccept_threshold = f(Y) / (c * g(Y))\n\n# Plotando as funções f(x) e a linha horizontal c*g(x)\n# Ajustando o código para truncar o eixo y no zero\nplt.plot(x, f(x), label='f(x)', color='black')\nplt.hlines(c * g(x), 0, 1, color='blue', label='c*g(x)', linewidth=2)  # Linha horizontal c*g(x)\n\n# Destacar a área de aceitação e rejeição\nplt.vlines(Y, 0, f(Y), colors='green', label='Aceitar $x$', linewidth=2)\nplt.vlines(Y, f(Y), c * g(Y), colors='red', label='Rejeitar $x$', linewidth=2)\n\n# Adicionar rótulo de Y na posição da linha vertical\nplt.text(Y+0.025, 0.05, 'Y', color='black', fontsize=12, horizontalalignment='center')\n\n# Adicionar rótulos de Aceitar/Rejeitar\nplt.text(Y + 0.01, f(Y) / 2, 'Aceitar x', color='green', fontsize=10, verticalalignment='center')\nplt.text(Y + 0.01, f(Y) + (c * g(Y) - f(Y)) / 2, 'Rejeitar x', color='red', fontsize=10, verticalalignment='center')\n\n# Limites e rótulos\nplt.xlim(0, 1)\n\n\n(0.0, 1.0)\n\n\nMostrar código\nplt.ylim(0, 2.5)  # Truncando o eixo y no zero\n\n\n(0.0, 2.5)\n\n\nMostrar código\nplt.xlabel('x')\nplt.ylabel('Densidade')\n\n# Adicionar a legenda para f(x) e c*g(x)\nplt.legend(['f(x)', 'c*g(x)'])\n\n# Mostrar gráfico\nplt.title('Amostragem por Rejeição para g uniforme')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "6_continuous_rejection.html#exemplo",
    "href": "6_continuous_rejection.html#exemplo",
    "title": "8  Método da Rejeição para Variáveis Contínuas",
    "section": "8.2 Exemplo",
    "text": "8.2 Exemplo\nVamos demonstrar a amostragem por rejeição gerando amostras de uma distribuição alvo \\(f(x)\\), utilizando a distribuição uniforme como distribuição proposta.\nA função densidade alvo que utilizaremos é: \\[\nf(x) = 20x(1 - x)^3 \\quad \\text{para} \\quad 0 &lt; x &lt; 1\n\\] E a distribuição proposta será \\(g(x) = 1 \\quad \\text{para} \\quad 0 &lt; x &lt; 1\\), que é uma distribuição uniforme.\nImplementamos o seguinte algoritmo:\n\nRPython\n\n\n\n\nMostrar código\nlibrary(ggplot2)\n\n# Função densidade alvo f(x)\nf &lt;- function(x) {\n  20 * x * (1 - x)^3\n}\n\n# Amostragem por rejeição\namostragem_rejeicao &lt;- function(f, c, n_amostras) {\n  amostras &lt;- numeric(0)\n  while (length(amostras) &lt; n_amostras) {\n    # Gere Y ~ g(x) (uniforme entre 0 e 1)\n    Y &lt;- runif(1, 0, 1)\n    \n    # Gere U ~ Uniforme(0, 1)\n    U &lt;- runif(1, 0, 1)\n    \n    # Verifica se aceitamos Y\n    if (U &lt;= f(Y) / (c)) {\n      amostras &lt;- c(amostras, Y)\n    }\n  }\n  return(amostras)\n}\n\n# A constante c é o limite superior de f(x)\nc &lt;- 135 / 64\n\n# Gere 1000 amostras usando o método de aceitação e rejeição\nset.seed(123)\namostras &lt;- amostragem_rejeicao(f, c, 1000)\n\n# Criação do data frame para o ggplot2\nx_vals &lt;- seq(0, 1, length.out = 1000)\nf_vals &lt;- f(x_vals)\ndf &lt;- data.frame(x = x_vals, y = f_vals)\n\n# Gráfico com ggplot2\nggplot() +\n  geom_line(data = df, aes(x = x, y = y), color = 'blue', size = 1, linetype = 'solid') +\n  geom_histogram(aes(x = amostras, y = ..density..), bins = 30, fill = 'orange', alpha = 0.5, color = 'black') +\n  ggtitle(\"Amostragem por Rejeição\") +\n  xlab(\"x\") +\n  ylab(\"Densidade\") +\n  theme_minimal() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Função densidade alvo f(x)\ndef f(x):\n    return 20 * x * (1 - x)**3\n\n# Função densidade proposta g(x) (distribuição uniforme)\ndef g(x):\n    return 1  # g(x) é uniforme no intervalo (0, 1)\n\n# Amostragem por rejeição\ndef amostragem_rejeicao(f, g, c, n_amostras):\n    amostras = []\n    while len(amostras) &lt; n_amostras:\n        # Gere Y ~ g(x)\n        Y = np.random.uniform(0, 1)\n        \n        # Gere U ~ Uniforme(0, 1)\n        U = np.random.uniform(0, 1)\n        \n        # Verifica se aceitamos Y\n        if U &lt;= f(Y) / (c * g(Y)):\n            amostras.append(Y)\n     \n    return np.array(amostras)\n \n# A constante c é o limite superior de f(x)/g(x)\nc = 135 / 64  # Pré-calculado\n\n# Gere 1000 amostras usando o método de aceitação e rejeição\namostras = amostragem_rejeicao(f, g, c, 1000)\n\n# Plotando os resultados\nx = np.linspace(0, 1, 1000)\nplt.plot(x, f(x), label='Distribuição Alvo f(x)')\nplt.hist(amostras, bins=30, density=True, alpha=0.5, label='Amostragem por Rejeição')\nplt.legend()\nplt.title(\"Amostragem por Rejeição\")\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "6_continuous_rejection.html#resultados-teóricos",
    "href": "6_continuous_rejection.html#resultados-teóricos",
    "title": "8  Método da Rejeição para Variáveis Contínuas",
    "section": "8.3 Resultados Teóricos",
    "text": "8.3 Resultados Teóricos\n\n8.3.1 Correção do Método de Aceitação e Rejeição\nTeorema:\nA variável aleatória \\(Y\\) gerada pelo método da rejeição tem densidade \\(f(x)\\).\nProva:\nConsidere a função de distribuição acumulada (CDF) de \\(X\\), a variável gerada pelo método:\n\\[\nP(X \\leq x) = P(Y \\leq x \\mid \\text{aceitar } Y)\n\\]\nPodemos escrever essa probabilidade como:\n\\[\nP(X \\leq x) = \\frac{P(Y \\leq x, U \\leq \\frac{f(Y)}{c \\cdot g(Y)})}{P(U \\leq \\frac{f(Y)}{c \\cdot g(Y)})}\n\\]\nUsando a probabilidade condicional, o numerador pode ser expresso como:\n\\[\nP(Y \\leq x, U \\leq \\frac{f(Y)}{c \\cdot g(Y)}) = \\int_{-\\infty}^x \\int_0^{\\frac{f(y)}{c \\cdot g(y)}} g(y) \\, du \\, dy\n\\]\nResolvendo a integral em \\(u\\):\n\\[\nP(Y \\leq x, U \\leq \\frac{f(Y)}{c \\cdot g(Y)}) = \\int_{-\\infty}^x \\frac{f(y)}{c \\cdot g(y)} g(y) \\, dy = \\frac{1}{c} \\int_{-\\infty}^x f(y) \\, dy\n\\]\nDe maneira semelhante, o denominador é dado por:\n\\[\nP\\left(U \\leq \\frac{f(Y)}{c \\cdot g(Y)}\\right) = \\int_{-\\infty}^{\\infty} \\frac{f(y)}{c \\cdot g(y)} g(y) \\, dy = \\frac{1}{c} \\int_{-\\infty}^{\\infty} f(y) \\, dy\n\\]\nComo \\(\\int_{-\\infty}^{\\infty} f(y) \\, dy = 1\\) (pois \\(f(x)\\) é uma função densidade), o denominador resulta em \\(\\frac{1}{c}\\). Substituindo essas expressões na equação original, obtemos:\n\\[\nP(X \\leq x) = \\frac{\\frac{1}{c} \\int_{-\\infty}^x f(y) \\, dy}{\\frac{1}{c}} = \\int_{-\\infty}^x f(y) \\, dy\n\\]\nPortanto, a variável \\(X\\) gerada pelo método de aceitação e rejeição tem função de distribuição acumulada \\(\\int_{-\\infty}^x f(y) \\, dy\\), o que implica que \\(X\\) tem densidade \\(f(x)\\). Assim, o método gera amostras corretamente distribuídas de acordo com \\(f(x)\\), como desejado.\n\n\n8.3.2 Eficiência computacional\nTeorema:\nA variável aleatória gerada pelo método de aceitação e rejeição tem função de densidade \\(f(x)\\). O número de passos que o algoritmo necessita para gerar \\(X\\) tem distribuição geométrica com média \\(c\\), onde \\(c\\) é a constante de normalização que define o limite superior da razão \\(\\frac{f(x)}{g(x)}\\).\nProva:\nSeja \\(Y\\) a variável aleatória gerada pela distribuição proposta \\(g(x)\\), e \\(U \\sim \\text{Unif}(0, 1)\\) uma variável aleatória uniforme. O método de aceitação e rejeição aceita \\(Y\\) como amostra de \\(f(x)\\) se \\(U \\leq \\frac{f(Y)}{c g(Y)}\\), caso contrário, o valor é rejeitado e o processo é repetido.\nA probabilidade de aceitar uma amostra \\(Y\\), dado que \\(Y \\leq x\\), é dada por:\n\\[\nP(Y \\leq x \\text{ e aceitar}) = P\\left(Y \\leq x , U \\leq \\frac{f(Y)}{c g(Y)}\\right)\n\\]\nPodemos reescrever essa probabilidade como uma integral:\n\\[\nP(Y \\leq x \\text{ e aceitar}) = \\int_{-\\infty}^x \\int_{0}^{\\frac{f(y)}{c g(y)}} g(y) \\, du \\, dy\n\\]\nResolvendo a integral em \\(u\\), temos:\n\\[\nP(Y \\leq x \\text{ e aceitar}) = \\int_{-\\infty}^x \\frac{f(y)}{c g(y)} g(y) \\, dy = \\frac{1}{c} \\int_{-\\infty}^x f(y) \\, dy\n\\]\nA probabilidade de aceitar qualquer valor \\(Y\\) é dada por:\n\\[\nP(\\text{aceitar}) = P\\left(U \\leq \\frac{f(Y)}{c g(Y)}\\right) = \\int_{-\\infty}^{\\infty} \\int_{0}^{\\frac{f(y)}{c g(y)}} g(y) \\, du \\, dy\n\\]\nSimplificando:\n\\[\nP(\\text{aceitar}) = \\int_{-\\infty}^{\\infty} \\frac{f(y)}{c g(y)} g(y) \\, dy = \\frac{1}{c} \\int_{-\\infty}^{\\infty} f(y) \\, dy = \\frac{1}{c}\n\\]\nAssim, a cada passo, a probabilidade de aceitar um valor é \\(\\frac{1}{c}\\), o que implica que o número de passos necessários para aceitar uma amostra tem distribuição geométrica com média \\(c\\).\nPor fim, sabemos que a função de distribuição acumulada da variável \\(X\\), dado que ela foi aceita, é:\n\\[\nP(X \\leq x) = P(Y \\leq x \\mid \\text{aceitou}) = \\frac{P(Y \\leq x , \\text{aceitou})}{P(\\text{aceitar})}\n\\]\nSubstituindo as expressões:\n\\[\nP(X \\leq x) = \\frac{\\frac{1}{c} \\int_{-\\infty}^x f(y) \\, dy}{\\frac{1}{c}} = \\int_{-\\infty}^x f(y) \\, dy\n\\]\nPortanto, a variável \\(X\\) gerada pelo método de aceitação e rejeição tem função de densidade \\(f(x)\\), como desejado.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "6_continuous_rejection.html#exercícios",
    "href": "6_continuous_rejection.html#exercícios",
    "title": "8  Método da Rejeição para Variáveis Contínuas",
    "section": "8.4 Exercícios",
    "text": "8.4 Exercícios\nExercício 1. Seja \\(X\\sim Gama(3/2,1)\\) com função densidade dada por \\[f(x)=\\frac{1}{\\Gamma(3/2)}x^{1/2}e^{-x}, \\text{ para } x &gt; 0.\\]\n\nEscreva um pseudo-algoritmo para simular um valor da distribuição de \\(X\\) usando o método da aceitação e rejeição usando como distribuição proposta a distribuição exponencial de parâmetro \\(2/3\\).\n\nObservação: Note que \\(\\mathbb E[X]=3/2\\) e \\(\\mathbb E[Y]=3/2\\), por isso o parâmetro da distribuição exponencial proposta foi tomado como \\(2/3\\).\n\nCrie uma função para gerar um valor de \\(X\\).\nQual foi o número de passos necessários para gerar um valor de \\(X\\)? Compare com o valor real.\nCrie uma função para gerar uma amostra de tamanho \\(n\\) de \\(X\\).\nQual foi o número médio de passos necessários para gerar a amostra de tamanho \\(n\\)?\nCompare a distribuição empírica dos valores simulados com a distribuição real de \\(X\\).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Método da Rejeição para Variáveis Contínuas</span>"
    ]
  },
  {
    "objectID": "7_transf.html",
    "href": "7_transf.html",
    "title": "9  Transformações e Misturas",
    "section": "",
    "text": "9.1 Exercícios\nExercício 1.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Transformações e Misturas</span>"
    ]
  },
  {
    "objectID": "8_box_muller.html",
    "href": "8_box_muller.html",
    "title": "10  Método de Box-Muller",
    "section": "",
    "text": "10.1 Exercícios\nExercício 1.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Método de Box-Muller</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html",
    "href": "9_monte_carlo.html",
    "title": "11  Método de Monte Carlo",
    "section": "",
    "text": "11.1 Exemplo 1: Estimativa de uma Integral\nQueremos obter uma estimativa para\n\\[\n\\theta = \\int\\limits_{0}^{1}e^{-x} dx\n\\]\nPara isso, basta observar que se \\(U \\sim Unif(0,1)\\), então \\(\\theta = \\mathbb{E}[e^{-U}]\\). De fato, se \\(U \\in Unif(0,1)\\), \\[\n\\theta=\\int\\limits_{0}^{1}e^{-x} dx= \\int\\limits_{0}^{1}e^{-u}f(u) du.\n\\] Assim, o estimador desta integral via MMC pode ser obtido da seguinte forma:\nVamos verificar como o valor de \\(n\\) influencia na aproximação:\nEsse gráfico mostra a evolução da estimativa à medida que o número de variáveis aleatórias \\(n\\) aumenta, comparando com o valor real da integral.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#exemplo-1-estimativa-de-uma-integral",
    "href": "9_monte_carlo.html#exemplo-1-estimativa-de-uma-integral",
    "title": "11  Método de Monte Carlo",
    "section": "",
    "text": "RPython\n\n\n\n\nMostrar código\nn &lt;- 100\nu &lt;- runif(n, min = 0, max = 1)\ntheta_hat &lt;- mean(exp(-u))\n\nvalor_real &lt;- 1 - exp(-1)\ntheta_hat\n\n\n[1] 0.6138417\n\n\nMostrar código\nvalor_real\n\n\n[1] 0.6321206\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nn = 100\nu = np.random.uniform(0, 1, n)\ntheta_hat = np.mean(np.exp(-u))\n\nvalor_real = 1 - np.exp(-1)\ntheta_hat, valor_real\n\n\n(np.float64(0.6379445215357002), np.float64(0.6321205588285577))\n\n\n\n\n\n\n\nRPython\n\n\n\n\nMostrar código\nlibrary(ggplot2)\n\nset.seed(58)\nN &lt;- 1:2000\ntheta_hat &lt;- numeric(length(N))\nu &lt;- numeric(length(N))  # Pré-alocação do vetor\n\n# Preenchendo o vetor u e calculando theta_hat\nfor (i in seq_along(N)) {\n  u[i] &lt;- runif(1)\n  theta_hat[i] &lt;- mean(exp(-u[1:i]))\n}\n\n# Criando o dataframe para o ggplot\ndf &lt;- data.frame(N = N, theta_hat = theta_hat)\n\n# Plotar o gráfico usando ggplot2\nggplot(df, aes(x = N, y = theta_hat)) +\n  geom_line(color = \"blue\") +\n  geom_hline(yintercept = 1 - exp(-1), color = \"red\", linetype = \"dashed\") +\n  labs(x = \"n\", y = expression(hat(theta)[n]), title = expression(Aproximação~de~theta)) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(58)\nN = np.arange(1, 2001, 1)\ntheta_hat = np.zeros(len(N))\nu = np.array([])\n\nfor i in range(len(N)):\n    u = np.append(u, np.random.uniform(0, 1))\n    theta_hat[i] = np.mean(np.exp(-u))\n\nplt.plot(N, theta_hat)\nplt.axhline(y=1 - np.exp(-1), color='red', linestyle='--')\nplt.xlabel('n')\nplt.ylabel(r'$\\hat{\\theta}_n$')\nplt.title(r'Aproximação de $\\theta$')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#exemplo-2-aproximando-uma-probabilidade",
    "href": "9_monte_carlo.html#exemplo-2-aproximando-uma-probabilidade",
    "title": "11  Método de Monte Carlo",
    "section": "11.2 Exemplo 2: Aproximando uma Probabilidade",
    "text": "11.2 Exemplo 2: Aproximando uma Probabilidade\nSeja \\(X \\sim Gama(2,3)\\). Queremos aproximar o valor de \\(\\mathbb{P}(X \\geq 0.4)\\) usando o método de Monte Carlo. Note que \\[\\theta:= \\mathbb{P}(X \\geq 0.4) = \\int g(x)f(x)dx,\\] em que \\(g(x)=I(x \\geq 0.4)\\) e \\(f(x)\\) é a densidade da Gama(2,3). Assim, podemos aproximar a probabilidade gerada via MC.\nNeste caso, o algoritmo corresponde a gerar \\(X_i \\sim Gama(2,3)\\), defir e definir uma variável indicadora \\(Y_i\\) que vale 1 quando \\(X_i \\geq 0.4\\) e 0 caso contrário. A estimativa de Monte Carlo é dada pela média dos \\(Y_i\\)’s:\n\nRPython\n\n\n\n\nMostrar código\nset.seed(58)\nlibrary(ggplot2)\n\nN &lt;- 50000\nx &lt;- rgamma(N, shape = 2, rate = 3)  # Usando rate = 1/scale\ny &lt;- as.integer(x &gt;= 0.4)\n\nvalor_aproximado &lt;- mean(y)\nvalor_real &lt;- 1 - pgamma(0.4, shape = 2, rate = 3)\n\nvalor_aproximado\n\n\n[1] 0.66282\n\n\nMostrar código\nvalor_real\n\n\n[1] 0.6626273\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nfrom scipy.stats import gamma\n\n\nN = 50000\nx = gamma.rvs(2, scale=1/3, size=N)\ny = (x &gt;= 0.4).astype(int)\n\nvalor_aproximado = np.mean(y)\nvalor_real = 1 - gamma.cdf(0.4, 2, scale=1/3)\n\nvalor_aproximado, valor_real\n\n\n(np.float64(0.66098), np.float64(0.6626272662068446))",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#exemplo-3-aproximando-o-valor-de-pi",
    "href": "9_monte_carlo.html#exemplo-3-aproximando-o-valor-de-pi",
    "title": "11  Método de Monte Carlo",
    "section": "11.3 Exemplo 3: Aproximando o valor de \\(\\pi\\)",
    "text": "11.3 Exemplo 3: Aproximando o valor de \\(\\pi\\)\nNeste exemplo, queremos aproximar o valor de \\(\\pi\\) utilizando o método de Monte Carlo. A ideia é gerar pontos aleatórios em um quadrado e contar quantos caem dentro de um círculo inscrito no quadrado. Vamos seguir o raciocínio a partir da geometria básica.\n\n11.3.0.1 Geometria\n\nConsidere um quadrado com lado 2 centrado na origem, ou seja, o quadrado vai de \\((-1, -1)\\) até \\((1, 1)\\).\nDentro deste quadrado, inscreva um círculo de raio 1, também centrado na origem.\nA área do quadrado é \\(4\\) (já que \\(2 \\times 2 = 4\\)) e a área do círculo é \\(\\pi \\cdot r^2 = \\pi \\cdot 1^2 = \\pi\\).\n\nA razão entre a área do círculo e a área do quadrado é dada por:\n\\[\n\\frac{\\text{Área do círculo}}{\\text{Área do quadrado}} = \\frac{\\pi}{4}\n\\]\n\nRPython\n\n\n\n\nMostrar código\nrequire(plotrix)\nrequire(grid)\n\nplot(c(-1, 1), c(-1,1), type = \"n\", asp=1,xlab=\"\",yla=\"\")\nrect( -1, -1, 1, 1,border=\"blue\") \ndraw.circle( 0, 0, 1 ,border=\"red\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle, Circle\n\n# Configura o gráfico\nfig, ax = plt.subplots()\nax.set_aspect('equal')  # Define o aspecto como 1:1 (quadrado)\nax.set_xlim(-1, 1)\n\n\n(-1.0, 1.0)\n\n\nMostrar código\nax.set_ylim(-1, 1)\n\n\n(-1.0, 1.0)\n\n\nMostrar código\nax.set_xlabel('')\nax.set_ylabel('')\n\n# Desenha o retângulo\nrect = Rectangle((-1, -1), 2, 2, edgecolor='blue', facecolor='none')\nax.add_patch(rect)\n\n# Desenha o círculo\ncircle = Circle((0, 0), 1, edgecolor='red', facecolor='none')\nax.add_patch(circle)\n\n# Mostra o gráfico\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nPara estimar \\(\\pi\\) usando Monte Carlo, procedemos da seguinte forma:\n\nGeramos pontos aleatórios \\((x, y)\\) no quadrado \\([-1, 1] \\times [-1, 1]\\).\nVerificamos se cada ponto está dentro do círculo, o que ocorre se \\(x^2 + y^2 \\leq 1\\).\nA fração de pontos que caem dentro do círculo aproxima a razão \\(\\frac{\\pi}{4}\\).\nMultiplicamos essa fração por 4 para obter uma estimativa de \\(\\pi\\).\n\n\n\n11.3.0.2 Matemática do Estimador\nFormalmente, se \\((X,Y) \\sim Unif(-1,1) \\times Unif(-1,1)\\) e \\(g(x,y)=I(\\text{(x,y) está no círculo})\\), temos que \\[\\theta:=\\int g(x,y)f(x,y) dxy =  \\frac{\\text{Área do círculo}}{\\text{Área do quadrado}} = \\frac{\\pi}{4} \\] Assim, se \\((X_i,Y_i)\\) é um ponto gerado uniformemente dentro do quadrado, o estimador de Monte Carlo para \\(\\frac{\\pi}{4}\\) é dado por: \\[\n\\hat{\\theta}_n = \\frac{1}{n} \\sum_{i=1}^n g(x_i,y_i)= \\frac{1}{n} \\sum_{i=1}^n z_i,\n\\] em que \\(z_i = 1\\) se o ponto \\(i\\) está dentro do círculo (i.e., se \\(x_i^2 + y_i^2 \\leq 1\\)) e \\(z_i = 0\\) caso contrário.\nMultiplicando por 4, obtemos a estimativa de \\(\\pi\\):\n\\[\n\\hat{\\pi}_n = 4 \\cdot \\hat{\\theta}_n = 4 \\cdot \\frac{1}{n} \\sum_{i=1}^n z_i\n\\]\nDe acordo com a Lei Forte dos Grandes Números, sabemos que:\n\\[\n\\hat{\\pi}_n \\longrightarrow \\pi \\quad \\text{(quase certamente, quando $n \\to \\infty$)}.\n\\]\nOu seja, à medida que o número de pontos simulados \\(n\\) aumenta, a estimativa \\(\\hat{\\pi}_n\\) convergirá para o valor verdadeiro de \\(\\pi\\).\nImplementação\nOs trechos de código fornecidos em R e Python simulam esse processo, gerando \\(n\\) pontos e calculando a aproximação de \\(\\pi\\) com base nos pontos que caem dentro do círculo. Além disso, são gerados gráficos que mostram como a estimativa de \\(\\pi\\) melhora conforme o número de simulações aumenta, evidenciando a convergência mencionada.\nAgora que todos os detalhes matemáticos do exemplo estão claros, o código para simulação pode ser executado para observar a aproximação prática de \\(\\pi\\).\n\nRPython\n\n\n\n\nMostrar código\nset.seed(459)\nlibrary(ggplot2)\n\nN &lt;- 1:80000\nz &lt;- numeric(length(N))\n\n# Loop para gerar os pontos e verificar se estão dentro do círculo\nfor (i in seq_along(N)) {\n  x &lt;- 2 * runif(1) - 1\n  y &lt;- 2 * runif(1) - 1\n  z[i] &lt;- (x^2 + y^2 &lt;= 1)\n}\n\n# Cálculo da estimativa de pi\ntheta_hat &lt;- cumsum(z) / N\npi_hat &lt;- theta_hat * 4\n\n# Criando o dataframe para o ggplot\ndf &lt;- data.frame(N = N, pi_hat = pi_hat)\n\n# Plotar o gráfico usando ggplot2\nggplot(df, aes(x = N, y = pi_hat)) +\n  geom_line(color = \"blue\") +\n  geom_hline(yintercept = pi, color = \"red\", linetype = \"dashed\") +\n  labs(x = \"n\", y = expression(hat(pi)[n]), title = expression(Aproximacao~de~pi)) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(459)\nN = np.arange(1, 80001, 1)\nz = np.zeros(len(N))\n\nfor i in range(len(N)):\n    x = 2 * np.random.uniform(0, 1) - 1\n    y = 2 * np.random.uniform(0, 1) - 1\n    z[i] = (x**2 + y**2 &lt;= 1)\n\ntheta_hat = np.cumsum(z) / N\npi_hat = theta_hat * 4\n\nplt.plot(N, pi_hat)\nplt.axhline(y=np.pi, color='red', linestyle='--')\nplt.xlabel('n')\nplt.ylabel(r'$\\hat{\\pi}_n$')\nplt.title(r'Aproximação de $\\pi$')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nEsse gráfico mostra como a estimativa de \\(\\pi\\) melhora conforme o número de pontos simulados \\(n\\) aumenta.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#intervalos-de-confiança-para-estimativas-de-monte-carlo",
    "href": "9_monte_carlo.html#intervalos-de-confiança-para-estimativas-de-monte-carlo",
    "title": "11  Método de Monte Carlo",
    "section": "11.4 Intervalos de Confiança para Estimativas de Monte Carlo",
    "text": "11.4 Intervalos de Confiança para Estimativas de Monte Carlo\nO Método de Monte Carlo possibilita quantificar a incerteza em nossas estimativas. Para isso, podemos utilizar intervalos de confiança.\nSuponha que temos uma sequência de amostras \\(X_1, X_2, \\dots, X_n\\) de uma variável aleatória \\(X\\), e calculamos a média amostral \\(\\hat{\\theta}_n = \\frac{1}{n} \\sum_{i=1}^n g(X_i)\\). Pelo Teorema Central do Limite, sabemos que, para \\(n\\) suficientemente grande, a média amostral \\(\\hat{\\theta}_n\\) é aproximadamente normalmente distribuída:\n\\[\n\\hat{\\theta}_n \\sim N\\left( \\theta, \\frac{\\sigma^2}{n} \\right)\n\\]\nonde \\(\\sigma^2 = \\text{Var}[g(X)]\\) é a variância de \\(g(X)\\). Essa aproximação permite a construção de um intervalo de confiança para \\(\\theta\\).\nO intervalo de confiança aproximado para \\(\\theta\\) com nível de confiança \\((1 - \\alpha) \\times 100\\%\\) é dado por:\n\\[\n\\hat{\\theta}_n \\pm z_{\\alpha/2} \\frac{\\hat{\\sigma}}{\\sqrt{n}}\n\\]\nonde \\(z_{\\alpha/2}\\) é o quantil da distribuição normal padrão associado à probabilidade \\(\\alpha/2\\) e \\(\\hat{\\sigma}\\) é a estimativa da variância de \\(g(X)\\), obtida a partir das amostras.\nPseudo-Algoritmo para construir um intervalo de confiança:\n\nGere \\(X_1, \\dots, X_n\\) amostras i.i.d. da v.a. \\(X\\).\nCalcule \\(\\hat{\\theta}_n = \\frac{1}{n} \\sum_{i=1}^n g(X_i)\\).\nEstime a variância de \\(g(X)\\) como: \\[\n\\hat{\\sigma}^2 = \\frac{1}{n} \\sum_{i=1}^n (g(X_i) - \\hat{\\theta}_n)^2\n\\]\nCalcule o intervalo de confiança: \\[\n\\hat{\\theta}_n \\pm z_{\\alpha/2} \\frac{\\hat{\\sigma}}{\\sqrt{n}}\n\\]\n\n\n11.4.1 Exemplo: Intervalo de Confiança para a Estimativa de \\(\\pi\\)\nNeste exemplo, construímos um intervalo de confiança para a estimativa de \\(\\pi\\) usando o método de Monte Carlo, seguindo os passos acima.\n\nRPython\n\n\n\n\nMostrar código\nset.seed(0)\nN &lt;- 10000  # número de amostras\nz &lt;- numeric(N)\n\n# Loop para gerar os pontos e verificar se estão dentro do círculo\nfor (i in 1:N) {\n  x &lt;- 2 * runif(1) - 1\n  y &lt;- 2 * runif(1) - 1\n  z[i] &lt;- (x^2 + y^2 &lt;= 1)\n}\n\ntheta_hat &lt;- mean(z)\nsigma_hat &lt;- sqrt(var(z) / N)\nalpha &lt;- 0.05  # Nível de significância\nz_alpha2 &lt;- qnorm(1 - alpha / 2)\n\n# Intervalo de confiança\nIC &lt;- c(theta_hat - z_alpha2 * sigma_hat, theta_hat + z_alpha2 * sigma_hat) * 4\n\ntheta_hat * 4  # Estimativa de pi\n\n\n[1] 3.1308\n\n\nMostrar código\nIC  # Intervalo de confiança\n\n\n[1] 3.098466 3.163134\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nfrom scipy.stats import norm\n\nnp.random.seed(0)\nN = 10000  # número de amostras\nz = np.zeros(N)\n\n# Loop para gerar os pontos e verificar se estão dentro do círculo\nfor i in range(N):\n    x = 2 * np.random.uniform(0, 1) - 1\n    y = 2 * np.random.uniform(0, 1) - 1\n    z[i] = (x**2 + y**2 &lt;= 1)\n\ntheta_hat = np.mean(z)\nsigma_hat = np.sqrt(np.var(z) / N)\nalpha = 0.05  # Nível de significância\nz_alpha2 = norm.ppf(1 - alpha / 2)\n\n# Intervalo de confiança\nIC = (theta_hat - z_alpha2 * sigma_hat, theta_hat + z_alpha2 * sigma_hat)\nIC = [i * 4 for i in IC]\n\ntheta_hat * 4  # Estimativa de pi\n\n\nnp.float64(3.1228)\n\n\nMostrar código\nIC  # Intervalo de confiança\n\n\n[np.float64(3.090360848359833), np.float64(3.1552391516401666)]\n\n\n\n\n\nNeste caso, o intervalo de confiança construído em torno da estimativa \\(\\hat{\\pi}_n\\) oferece uma ideia de quão próxima nossa estimativa está do valor verdadeiro de \\(\\pi\\), com uma certa confiança.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#exemplo-4-problema-das-figurinhas",
    "href": "9_monte_carlo.html#exemplo-4-problema-das-figurinhas",
    "title": "11  Método de Monte Carlo",
    "section": "11.5 Exemplo 4: Problema das Figurinhas",
    "text": "11.5 Exemplo 4: Problema das Figurinhas\nUm colecionador está juntando figurinhas para completar um álbum da Copa. Qual é a probabilidade de que, ao comprar \\(n\\) pacotes, pelo menos um deles contenha duas ou mais figurinhas iguais? Durante o curso de probabilidade, você aprenderá como calcular essa probabilidade. Outra abordagem possível é o uso do método de Monte Carlo. Nesse caso, simulamos a compra de \\(n\\) pacotes, cada um com 5 figurinhas, de um total de 640 figurinhas disponíveis no álbum. Repetimos essa simulação \\(B=1000\\) vezes e contamos quantas vezes ocorreu pelo menos uma repetição de figurinhas em algum dos pacotes. A proporção de simulações com repetições é a estimativa de Monte Carlo da probabilidade que estamos interessados em calcular.\n\nRPython\n\n\n\n\nMostrar código\nnFigurinhas &lt;- 640\nB &lt;- 1000\nnPacotes &lt;- 1:50\naoMenosUmaRepetidaNoMesmoPacote &lt;- matrix(NA, length(nPacotes), B)\nfor(ii in 1:length(nPacotes)) {\n  for(jj in 1:B) {\n    figurinhas &lt;- sample(1:nFigurinhas, nPacotes[ii] * 5, replace = TRUE)\n    figurinhas &lt;- matrix(figurinhas, nPacotes[ii], 5)\n    aoMenosUmaRepetidaNoMesmoPacote[ii,jj] &lt;- sum(apply(figurinhas, 1, function(xx) length(unique(xx)) != length(xx)) &gt; 0)\n  }\n}\n\nprobCoincidencia &lt;- apply(aoMenosUmaRepetidaNoMesmoPacote, 1, mean)\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport random\n\nnFigurinhas = 640\nB = 1000\nnPacotes = np.arange(1, 51)  # Intervalo de 1 a 50 (Python é exclusivo no final)\naoMenosUmaRepetidaNoMesmoPacote = np.empty((len(nPacotes), B))\n\nfor ii in range(len(nPacotes)):\n    for jj in range(B):\n        figurinhas = [random.choices(range(1, nFigurinhas + 1), k=5) for _ in range(nPacotes[ii])]\n        figurinhas = np.array(figurinhas)\n        aoMenosUmaRepetidaNoMesmoPacote[ii, jj] = np.sum([len(set(pacote)) != len(pacote) for pacote in figurinhas])\n\nprobCoincidencia = np.mean(aoMenosUmaRepetidaNoMesmoPacote, axis=1)\n\n\n\n\n\nAgora podemos visualizar os resultados obtidos por meio do gráfico a seguir:\n\nRPython\n\n\n\n\nMostrar código\ndados &lt;- data.frame(probCoincidencia = probCoincidencia, nPacotes = nPacotes)\n\nlibrary(ggplot2)\nggplot(dados, aes(x = nPacotes, y = probCoincidencia)) +\n  geom_point(aes(size = 1.1)) +\n  xlab(\"Número de Pacotes\") +\n  ylab(\"Prob de ao menos 1 repetida no mesmo pacote\") + \n  theme(legend.position = \"none\")+\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Criação do DataFrame\ndados = pd.DataFrame({'nPacotes': nPacotes, 'probCoincidencia': probCoincidencia})\n\n# Criação do gráfico\nplt.figure(figsize=(8, 6))\nplt.scatter(dados['nPacotes'], dados['probCoincidencia'], s=70)  # 's' ajusta o tamanho dos pontos\nplt.xlabel('Número de Pacotes')\nplt.ylabel('Prob de ao menos 1 repetida no mesmo pacote')\nplt.grid(True, which='both', linestyle='--', linewidth=0.7)\nplt.gca().set_facecolor('white')  # Para seguir o tema minimalista\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nSimulação para completar o álbum\nUma segunda pergunta que também podemos responder via simulação é: quantos pacotes necessitamos em média para completar o álbum? A solução estimada pode ser obtida com o código abaixo:\n\nRPython\n\n\n\n\nMostrar código\nnumeroPacotes &lt;- rep(NA, B)\nfor(jj in 1:B) {\n  albumCompleto &lt;- FALSE\n  nPacotes &lt;- 0\n  figurinhas &lt;- NULL\n  while(!albumCompleto) {\n    figurinhas &lt;- c(figurinhas, sample(1:nFigurinhas, 5, replace = TRUE))\n    if(length(unique(figurinhas)) == nFigurinhas) {\n      albumCompleto &lt;- TRUE\n    }\n    nPacotes &lt;- nPacotes + 1\n  }\n  numeroPacotes[jj] &lt;- nPacotes\n}\n\n\n\n\n\n\nMostrar código\nimport numpy as np\nimport random\n\nnFigurinhas = 640\nB = 1000\nnumeroPacotes = np.empty(B)\n\nfor jj in range(B):\n    albumCompleto = False\n    nPacotes = 0\n    figurinhas = []\n\n    while not albumCompleto:\n        figurinhas.extend(random.choices(range(1, nFigurinhas + 1), k=5))\n        if len(set(figurinhas)) == nFigurinhas:\n            albumCompleto = True\n        nPacotes += 1\n\n    numeroPacotes[jj] = nPacotes\n\n\n\n\n\nO número médio de pacotes necessários para completar o álbum é:\n\nRPython\n\n\n\n\nMostrar código\nmean(numeroPacotes)\n\n\n[1] 901.629\n\n\n\n\n\n\nMostrar código\nmean_numeroPacotes = np.mean(numeroPacotes)\nmean_numeroPacotes\n\n\nnp.float64(903.997)\n\n\n\n\n\nCom essa simulação, também podemos estimar as seguintes probabilidades:\n\nRPython\n\n\n\n\nMostrar código\ncat(\"Probabilidade de precisar de mais de 800 pacotes: \", mean(numeroPacotes &gt; 800) * 100, \"%\", sep = \"\")\n\n\nProbabilidade de precisar de mais de 800 pacotes: 69.3%\n\n\nMostrar código\ncat(\"Probabilidade de precisar de mais de 1000 pacotes: \", mean(numeroPacotes &gt; 1000) * 100, \"%\", sep = \"\")\n\n\nProbabilidade de precisar de mais de 1000 pacotes: 23.2%\n\n\n\n\n\n\nMostrar código\nprob_mais_800 = np.mean(numeroPacotes &gt; 800) * 100\nprob_mais_1000 = np.mean(numeroPacotes &gt; 1000) * 100\n\nprint(f\"Probabilidade de precisar de mais de 800 pacotes: {prob_mais_800}%\")\n\n\nProbabilidade de precisar de mais de 800 pacotes: 71.39999999999999%\n\n\nMostrar código\nprint(f\"Probabilidade de precisar de mais de 1000 pacotes: {prob_mais_1000}%\")\n\n\nProbabilidade de precisar de mais de 1000 pacotes: 24.4%",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "9_monte_carlo.html#exercícios",
    "href": "9_monte_carlo.html#exercícios",
    "title": "11  Método de Monte Carlo",
    "section": "11.6 Exercícios",
    "text": "11.6 Exercícios\nExercício 1.\nUtilize o método de Monte Carlo para aproximar a integral \\[\nI = \\int_0^{10} \\sin(x^2) \\, dx\n\\]\nForneça um intervalo de confiança para avaliar a precisão da estimativa.\nExercício 1.\nUtilize o método de Monte Carlo para aproximar a integral \\[\nI = \\int_1^{\\infty} \\frac{1}{x^3} \\, dx\n\\]\nForneça um intervalo de confiança para avaliar a precisão da estimativa.\nExercício 2.\nSeja \\(X \\sim \\text{Exp}(\\lambda)\\) com \\(\\lambda = 2\\). Estime a esperança \\(\\mathbb{E}[X^2]\\) utilizando o método de Monte Carlo. Forneça um intervalo de confiança para avaliar a precisão da estimativa. Compare com o valor real dessa quantidade.\nExercício 3.\nConsidere que \\(X\\) tem distribuição Normal(0,1) e \\(Y\\) tem distribuição Gamma(1,1). Estime \\(P(X\\times Y &gt; 3)\\). Forneça um intervalo de confiança para avaliar a precisão da estimativa.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Método de Monte Carlo</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Ross, Sheldon M. 2006. Simulation, Fourth Edition. USA:\nAcademic Press, Inc.",
    "crumbs": [
      "References"
    ]
  }
]