[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso de Programação Estatística",
    "section": "",
    "text": "Curso de Programação Estatística"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "intro.html#objetivo-da-aula",
    "href": "intro.html#objetivo-da-aula",
    "title": "1  Geração de Números Aleatórios e Aplicação em Problemas Estatísticos",
    "section": "1.1 Objetivo da Aula",
    "text": "1.1 Objetivo da Aula\nNesta aula, vamos introduzir o conceito de números pseudoaleatórios e como eles podem ser usados para resolver problemas estatísticos por meio de simulação. Vamos abordar a importância da aleatoriedade em estatísticas e em algoritmos de Monte Carlo."
  },
  {
    "objectID": "intro.html#conteúdo-teórico",
    "href": "intro.html#conteúdo-teórico",
    "title": "1  Geração de Números Aleatórios e Aplicação em Problemas Estatísticos",
    "section": "1.2 Conteúdo Teórico",
    "text": "1.2 Conteúdo Teórico\nA geração de números aleatórios é essencial em várias áreas da estatística e da ciência de dados. Esses números são utilizados em simulações estocásticas, amostragem e para resolver problemas que envolvem incerteza. Contudo, em computadores, os números “aleatórios” gerados são na verdade pseudoaleatórios, pois seguem uma sequência previsível, gerada por um algoritmo determinístico.\nOs números pseudoaleatórios são amplamente usados em algoritmos de Monte Carlo, que dependem da simulação repetida de processos aleatórios para estimar soluções para problemas matemáticos e estatísticos."
  },
  {
    "objectID": "intro.html#exemplo-de-problema",
    "href": "intro.html#exemplo-de-problema",
    "title": "1  Geração de Números Aleatórios e Aplicação em Problemas Estatísticos",
    "section": "1.3 Exemplo de Problema",
    "text": "1.3 Exemplo de Problema\nVamos resolver o problema de estimar o valor de π (Pi) usando um método de Monte Carlo. A ideia é simular a área de um quarto de círculo inscrito em um quadrado. Gerando pontos aleatórios dentro do quadrado, podemos calcular a proporção desses pontos que também caem dentro do círculo e usar essa proporção para estimar o valor de Pi.\nComo fazer isso?\n\nRPython\n\n\n\n# Definindo o número de pontos a serem gerados\nn_pontos &lt;- 1000\n\n# Gerando pontos aleatórios (x, y) no intervalo [0, 1]\nx &lt;- runif(n_pontos, 0, 1)\ny &lt;- runif(n_pontos, 0, 1)\n\n# Calculando a distância de cada ponto à origem\ndistancia &lt;- sqrt(x^2 + y^2)\n\n# Contando quantos pontos estão dentro do quarto de círculo (distância &lt;= 1)\ndentro_circulo &lt;- distancia &lt;= 1\npi_estimado &lt;- 4 * sum(dentro_circulo) / n_pontos\n\n# Exibindo o valor estimado de Pi\ncat(\"Valor estimado de π:\", pi_estimado, \"\\n\")\n\nValor estimado de π: 3.18 \n\n# Visualizando a distribuição dos pontos\nlibrary(ggplot2)\n\ndados &lt;- data.frame(x = x, y = y, dentro_circulo = dentro_circulo)\n\nggplot(dados, aes(x = x, y = y, color = dentro_circulo)) +\n  geom_point(size = 1) +\n  scale_color_manual(values = c(\"red\", \"blue\")) +\n  ggtitle(paste0(\"Estimativa de π usando Monte Carlo\\nValor estimado: \", round(pi_estimado, 5))) +\n  theme_minimal() +\n  coord_equal() +\n  labs(x = \"x\", y = \"y\")\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n/home/rizbicki/.local/lib/python3.10/site-packages/matplotlib/projections/__init__.py:63: UserWarning: Unable to import Axes3D. This may be due to multiple versions of Matplotlib being installed (e.g. as a system package and as a pip package). As a result, the 3D projection is not available.\n  warnings.warn(\"Unable to import Axes3D. This may be due to multiple versions of \"\n\n# Definindo o número de pontos a serem gerados\nn_pontos = 1000\n\n# Gerando pontos aleatórios (x, y) no intervalo [0, 1]\nx = np.random.uniform(0, 1, n_pontos)\ny = np.random.uniform(0, 1, n_pontos)\n\n# Calculando a distância de cada ponto à origem\ndistancia = np.sqrt(x**2 + y**2)\n\n# Contando quantos pontos estão dentro do quarto de círculo (distância &lt;= 1)\ndentro_circulo = distancia &lt;= 1\npi_estimado = 4 * np.sum(dentro_circulo) / n_pontos\n\n# Exibindo o valor estimado de Pi\nprint(f\"Valor estimado de π: {pi_estimado}\")\n\nValor estimado de π: 3.064\n\n# Visualizando a distribuição dos pontos\nplt.figure(figsize=(6,6))\nplt.scatter(x, y, c=dentro_circulo, cmap='coolwarm', s=1)\nplt.title(f'Estimativa de π usando Monte Carlo\\nValor estimado: {pi_estimado}')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()"
  },
  {
    "objectID": "intro.html#exemplo-simulação-de-um-jogo-de-dados-com-dado-viciado",
    "href": "intro.html#exemplo-simulação-de-um-jogo-de-dados-com-dado-viciado",
    "title": "1  Geração de Números Aleatórios e Aplicação em Problemas Estatísticos",
    "section": "1.4 Exemplo: Simulação de um Jogo de Dados com Dado “Viciado”",
    "text": "1.4 Exemplo: Simulação de um Jogo de Dados com Dado “Viciado”\nImagine que estamos jogando um jogo em que o dado é “viciado” e não segue uma distribuição uniforme, ou seja, alguns números têm uma chance maior de serem sorteados. Por exemplo, o número 6 pode ter uma probabilidade maior, e os outros números, menores.\nIsso nos permite mostrar como alterar a probabilidade de ocorrência de eventos em uma distribuição discreta.\n\nRPython\n\n\n\n# Definindo as faces do dado e as probabilidades\nfaces &lt;- 1:6\nprobabilidades &lt;- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.25)  # Probabilidades associadas às faces do dado\n\n# Verificando que a soma das probabilidades é 1\ncat(\"Soma das probabilidades:\", sum(probabilidades), \"\\n\")\n\nSoma das probabilidades: 1 \n\n# Simulando 10000 lançamentos de um dado viciado\nn_lancamentos &lt;- 10000\nset.seed(123)  # Definindo seed para reprodutibilidade\nresultados &lt;- sample(faces, size = n_lancamentos, replace = TRUE, prob = probabilidades)\n\n# Contando as frequências de cada face\nfrequencias &lt;- table(resultados) / n_lancamentos\n\n# Exibindo os resultados da simulação\ncat(\"Frequências de cada face após\", n_lancamentos, \"lançamentos:\\n\")\n\nFrequências de cada face após 10000 lançamentos:\n\nfor (face in faces) {\n  cat(\"Face\", face, \":\", frequencias[as.character(face)], \"vezes\\n\")\n}\n\nFace 1 : 0,0473 vezes\nFace 2 : 0,0975 vezes\nFace 3 : 0,1504 vezes\nFace 4 : 0,1991 vezes\nFace 5 : 0,2582 vezes\nFace 6 : 0,2475 vezes\n\n# Visualizando os resultados em um gráfico de barras\nlibrary(ggplot2)\n\ndados &lt;- data.frame(faces = as.factor(faces), frequencias = as.numeric(frequencias))\n\nggplot(dados, aes(x = faces, y = frequencias)) +\n  geom_bar(stat = \"identity\", fill = \"lightcoral\", color = \"black\") +\n  ggtitle(paste0(\"Simulação de Lançamentos de um Dado Viciado\\n\", n_lancamentos, \" lançamentos\")) +\n  xlab(\"Face do Dado\") +\n  ylab(\"Frequência de Ocorrência\") +\n  theme_minimal() +\n  geom_text(aes(label = round(frequencias, 4)), vjust = -0.5) +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo as faces do dado e as probabilidades\nfaces = [1, 2, 3, 4, 5, 6]\nprobabilidades = [0.05, 0.1, 0.15, 0.2, 0.25, 0.25]  # Probabilidades associadas às faces do dado\n\n# Verificando que a soma das probabilidades é 1\nprint(f\"Soma das probabilidades: {sum(probabilidades)}\")\n\nSoma das probabilidades: 1.0\n\n# Simulando 10000 lançamentos de um dado viciado\nn_lancamentos = 10000\nresultados = np.random.choice(faces, size=n_lancamentos, p=probabilidades)\n\n# Contando as frequências de cada face\nfrequencias = [np.sum(resultados == face) / n_lancamentos for face in faces]\n\n# Exibindo os resultados da simulação\nprint(f\"Frequências de cada face após {n_lancamentos} lançamentos:\")\n\nFrequências de cada face após 10000 lançamentos:\n\nfor face, freq in zip(faces, frequencias):\n    print(f\"Face {face}: {freq} vezes\")\n\nFace 1: 0.0489 vezes\nFace 2: 0.1007 vezes\nFace 3: 0.1508 vezes\nFace 4: 0.1975 vezes\nFace 5: 0.2539 vezes\nFace 6: 0.2482 vezes\n\n# Visualizando os resultados em um gráfico de barras\nplt.figure(figsize=(8,6))\nplt.bar(faces, frequencias, color='lightcoral', edgecolor='black')\nplt.title(f'Simulação de Lançamentos de um Dado Viciado\\n{n_lancamentos} lançamentos')\nplt.xlabel('Face do Dado')\nplt.ylabel('Frequência de Ocorrência')\nplt.grid(True)\nplt.show()"
  },
  {
    "objectID": "intro.html#pergunta-precisamos-da-função-np.random.choiceset.seed",
    "href": "intro.html#pergunta-precisamos-da-função-np.random.choiceset.seed",
    "title": "1  Geração de Números Aleatórios e Aplicação em Problemas Estatísticos",
    "section": "1.5 Pergunta: precisamos da função np.random.choice/set.seed?",
    "text": "1.5 Pergunta: precisamos da função np.random.choice/set.seed?\n\nRPython\n\n\n\n# Definindo as faces do dado e as probabilidades associadas (não uniformes)\nfaces &lt;- 1:6\nprobabilidades &lt;- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.25)  # Probabilidades associadas às faces do dado\n\n# Função para gerar uma amostra baseada em intervalos de probabilidades\ngerar_amostra_por_intervalos &lt;- function(probabilidades, faces) {\n  u &lt;- runif(1)  # Gerando um número aleatório uniforme\n  limite_inferior &lt;- 0  # Limite inferior do intervalo\n  \n  # Percorrendo as probabilidades e verificando em qual intervalo o número cai\n  for (i in seq_along(probabilidades)) {\n    limite_superior &lt;- limite_inferior + probabilidades[i]  # Definindo o limite superior do intervalo\n    if (limite_inferior &lt;= u && u &lt; limite_superior) {\n      return(faces[i])  # Retorna a face correspondente ao intervalo\n    }\n    limite_inferior &lt;- limite_superior  # Atualiza o limite inferior para o próximo intervalo\n  }\n}\n\n# Simulando lançamentos do dado viciado utilizando a verificação dos intervalos\nn_lancamentos &lt;- 10000\nset.seed(123)  # Definindo seed para reprodutibilidade\nresultados &lt;- replicate(n_lancamentos, gerar_amostra_por_intervalos(probabilidades, faces))\n\n# Contando as frequências de cada face\nfrequencias &lt;- sapply(faces, function(face) sum(resultados == face) / n_lancamentos)\n\n# Exibindo os resultados da simulação\ncat(\"Frequências de cada face após\", n_lancamentos, \"lançamentos:\\n\")\n\nFrequências de cada face após 10000 lançamentos:\n\nfor (i in seq_along(faces)) {\n  cat(\"Face\", faces[i], \":\", frequencias[i], \"vezes\\n\")\n}\n\nFace 1 : 0,0521 vezes\nFace 2 : 0,0964 vezes\nFace 3 : 0,1527 vezes\nFace 4 : 0,2045 vezes\nFace 5 : 0,2508 vezes\nFace 6 : 0,2435 vezes\n\n# Visualizando os resultados em gráficos\n\nlibrary(ggplot2)\n\n# Gráfico das probabilidades ajustadas\ndados_probabilidades &lt;- data.frame(faces = as.factor(faces), probabilidades = probabilidades)\nggplot(dados_probabilidades, aes(x = faces, y = probabilidades)) +\n  geom_bar(stat = \"identity\", fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Probabilidades Ajustadas para o Dado Viciado\") +\n  xlab(\"Face do Dado\") +\n  ylab(\"Probabilidade\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n# Gráfico das frequências obtidas\ndados_frequencias &lt;- data.frame(faces = as.factor(faces), frequencias = frequencias)\nggplot(dados_frequencias, aes(x = faces, y = frequencias)) +\n  geom_bar(stat = \"identity\", fill = \"lightcoral\", color = \"black\") +\n  ggtitle(paste0(\"Simulação de Lançamentos de um Dado Viciado\\n\", n_lancamentos, \" lançamentos\")) +\n  xlab(\"Face do Dado\") +\n  ylab(\"Frequência de Ocorrência\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo as faces do dado e as probabilidades associadas (não uniformes)\nfaces = [1, 2, 3, 4, 5, 6]\nprobabilidades = [0.05, 0.1, 0.15, 0.2, 0.25, 0.25]  # Probabilidades associadas às faces do dado\n\n# Gerando um número aleatório e verificando em qual intervalo ele cai\ndef gerar_amostra_por_intervalos(probabilidades, faces):\n    u = np.random.uniform(0, 1)  # Gerando um número aleatório uniforme\n    limite_inferior = 0  # Limite inferior do intervalo\n    \n    # Percorrendo as probabilidades e verificando em qual intervalo o número cai\n    for i, p in enumerate(probabilidades):\n        limite_superior = limite_inferior + p  # Definindo o limite superior do intervalo\n        if limite_inferior &lt;= u &lt; limite_superior:\n            return faces[i]  # Retorna a face correspondente ao intervalo\n        limite_inferior = limite_superior  # Atualiza o limite inferior para o próximo intervalo\n\n# Simulando lançamentos do dado viciado utilizando a verificação dos intervalos\nn_lancamentos = 10000\nresultados = [gerar_amostra_por_intervalos(probabilidades, faces) for _ in range(n_lancamentos)]\n\n# Contando as frequências de cada face\nfrequencias = [np.sum(np.array(resultados) == face) / n_lancamentos for face in faces]\n\n# Exibindo os resultados da simulação\nprint(f\"Frequências de cada face após {n_lancamentos} lançamentos:\")\n\nFrequências de cada face após 10000 lançamentos:\n\nfor face, freq in zip(faces, frequencias):\n    print(f\"Face {face}: {freq} vezes\")\n\nFace 1: 0.0498 vezes\nFace 2: 0.0957 vezes\nFace 3: 0.1504 vezes\nFace 4: 0.2033 vezes\nFace 5: 0.2498 vezes\nFace 6: 0.251 vezes\n\n# Gráfico das probabilidades ajustadas\nplt.figure(figsize=(8,6))\nplt.bar(faces, probabilidades, color='skyblue', edgecolor='black')\nplt.title('Probabilidades Ajustadas para o Dado Viciado')\nplt.xlabel('Face do Dado')\nplt.ylabel('Probabilidade')\nplt.grid(True)\nplt.show()\n\n\n\n# Gráfico das frequências obtidas\nplt.figure(figsize=(8,6))\nplt.bar(faces, frequencias, color='lightcoral', edgecolor='black')\nplt.title(f'Simulação de Lançamentos de um Dado Viciado\\n{n_lancamentos} lançamentos')\nplt.xlabel('Face do Dado')\nplt.ylabel('Frequência de Ocorrência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\nOu seja, se conseguimos simular uma distribuição uniforme, conseguimos simular uma distribuição discreta. Isso vale de forma mais geral?"
  },
  {
    "objectID": "index.html#objetivo-geral",
    "href": "index.html#objetivo-geral",
    "title": "Curso de Programação Estatística",
    "section": "Objetivo Geral",
    "text": "Objetivo Geral\nEste curso visa explorar o impacto das representações numéricas nos resultados de algoritmos de análise estatística. O foco será na programação, visualização e preparação de dados, além de discutir tópicos importantes como aleatoriedade, pseudoaleatoriedade, erros de truncamento e arredondamento, entre outros. O curso inclui ainda uma introdução à inferência por simulação estocástica, utilizando métodos como Monte Carlo e integrações numéricas.\nAutor: Andressa Cerqueira, Rafael Izbicki, Thiago Rodrigo Ramos"
  }
]