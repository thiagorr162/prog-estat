# Geração de Variáveis Aleatórias Contínuas Usando a Técnica da Inversão e Transformações

Os valores que uma variável aleatória $X$ pode assumir são chamados de **suporte**.

As **Variáveis Aleatórias Contínuas** têm suporte em um conjunto não enumerável de valores, como intervalos na reta real, $\mathbb{R}$, ou $(0,\infty)$, por exemplo.

Uma variável aleatória $X$ é considerada contínua se sua função de distribuição acumulada (f.d.a.) puder ser expressa como:
$$
P(X \leq a) = F(a) = \int_{-\infty}^{a} f(x) dx, \quad \forall a \in \mathbb{R},
$$
para uma função integrável $f: \mathbb{R} \to [0, \infty)$.

## Função Inversa

Sabemos que $F: \mathbb{R} \to [0,1]$, e, portanto, podemos definir a função inversa $F^{-1}: [0,1] \to \mathbb{R}$. A seguir, mostramos como isso funciona.

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Definindo a função de distribuição acumulada F(x)
def F(x):
    return 1 / (1 + np.exp(-x))  # Função logística como exemplo de F(x)

# Definindo a inversa da função de distribuição acumulada F_inv(u)
def F_inv(u):
    return -np.log((1 / u) - 1)

# Gerando valores de x e u para plotar
x = np.linspace(-4, 10, 400)
u = np.linspace(0.01, 0.99, 400)  # U entre 0 e 1 (evitando extremos para evitar erros na inversa)

# Plotando a função de distribuição acumulada F(x) com truncamento do eixo y no zero
plt.figure(figsize=(8, 6))
plt.plot(x, F(x), color="black")

# Adicionando linhas pontilhadas para representar U e F_inv(U)
u_value = 0.7  # Exemplo de valor de U
x_value = F_inv(u_value)

plt.hlines(u_value, min(x), x_value, linestyles='dotted', colors='red')
plt.vlines(x_value, 0, u_value, linestyles='dotted', colors='red')

# Etiquetas
plt.text(x_value-0.4 , -0.05, r"$F^{-1}(u)$", fontsize=12, color='red')
plt.text(-5.5, u_value - 0.02, r"$u$", fontsize=14, color='red')

# Rótulos e estilo do gráfico
plt.title(r'Representação da Função de Distribuição Acumulada e sua Inversa', fontsize=14)
plt.xlabel(r'$x$', fontsize=12)
plt.ylabel(r'$F(x)$', fontsize=12)
plt.ylim(0, 1.2)
plt.xlim(-4, 10)
plt.grid(True)

# Exibir o gráfico
plt.show()
```

## Método da Inversão

Para gerar valores de uma variável aleatória contínua $X$, usamos o **método da inversão**, que segue a seguinte proposição:

**Proposição:**
Seja $U \sim \text{Unif}(0,1)$. Para qualquer variável aleatória contínua com função de distribuição acumulada $F$, a variável:
$$
X = F^{-1}(U)
$$
tem distribuição $F$.

**Prova**:
$$
\mathbb{P}(X \leq x) = \mathbb{P}(F^{-1}(U) \leq x) = \mathbb{P}(F(F^{-1}(U)) \leq F(x)) = \mathbb{P}(U \leq F(x)) = F(x).
$$

O método da inversão consiste em:

1. Gerar $U \sim \text{Unif}(0,1)$.
2. Calcular $X = F^{-1}(U)$.

## Exemplo 1

Seja $X$ uma v.a. com:
$$
F(x) = x^n, \quad \text{para } 0 < x < 1.
$$

A função inversa é:
$$
u = F(x) = x^n \implies x = u^{1/n}.
$$

Portanto, o pseudo-algoritmo para gerar $X$ é:

1. Gere $U \sim \text{Unif}(0,1)$.
2. Calcule $X = U^{1/n}$.

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Parâmetro n da distribuição F(x) = x^n
n = 3

# Gerando 1000 valores U de uma distribuição uniforme (0,1)
U = np.random.uniform(0, 1, 1000)

# Calculando X = U^(1/n)
X = U**(1/n)

# Plotando um histograma dos valores gerados
plt.figure(figsize=(10, 6))
plt.hist(X, bins=30, color='skyblue', edgecolor='black', density=True)
plt.title('Histograma de variáveis geradas pela inversão: F(x) = x^n, n = 3')
plt.xlabel('Valor de X')
plt.ylabel('Frequência')
plt.grid(True)
plt.show()
```

### Exemplo 2

Seja $X \sim \text{Exp}(\lambda)$, com:
$$
F(x) = 1 - e^{-\lambda x}, \quad \text{para } x > 0.
$$

A função inversa é:
$$
u = F(x) = 1 - e^{-\lambda x} \implies x = -\frac{\log(1 - u)}{\lambda}.
$$

O pseudo-algoritmo para gerar $X$ é:

1. Gere $U \sim \text{Unif}(0,1)$.
2. Calcule $X = -\frac{\log(1 - U)}{\lambda}$.

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Parâmetro lambda da distribuição exponencial
lambd = 2

# Gerando 1000 valores U de uma distribuição uniforme (0,1)
U = np.random.uniform(0, 1, 1000)

# Calculando X usando a inversa da CDF da exponencial
X = -np.log(1 - U) / lambd

# Plotando um histograma dos valores gerados
plt.figure(figsize=(10, 6))
plt.hist(X, bins=30, color='lightcoral', edgecolor='black', density=True)
plt.title('Histograma de variáveis geradas pela inversão: Distribuição Exponencial')
plt.xlabel('Valor de X')
plt.ylabel('Frequência')
plt.grid(True)
plt.show()
```

## Simulação de transformações de variáveis aleatórias

Agora que já sabemos como simular uma variável aleatória $X$, o próximo passo é gerar valores de uma transformação dessa variável, ou seja, $g(X)$.

---

### Exemplo 1: Simulando $Y \sim Unif(1, 2)$

Para gerar valores de $Y \sim Unif(1, 2)$, usamos o fato de que $Y$ é uma simples transformação de $U \sim Unif(0, 1)$. A relação é:
$$
Y = U + 1.
$$

O pseudo-algoritmo é:

1. Gere $U \sim Unif(0,1)$.
2. Calcule $Y = U + 1$.

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Gerando 1000 valores U de uma distribuição uniforme (0,1)
U = np.random.uniform(0, 1, 1000)

# Calculando Y = U + 1 para ter Y ~ Unif(1, 2)
Y = U + 1

# Plotando um histograma dos valores gerados
plt.figure(figsize=(10, 6))
plt.hist(Y, bins=30, color='skyblue', edgecolor='black', density=True)
plt.title('Histograma de variáveis geradas: Y ~ Unif(1, 2)')
plt.xlabel('Valor de Y')
plt.ylabel('Frequência')
plt.grid(True)
plt.show()
```

### Exemplo 2: Simulando $Y \sim Gamma(n, \lambda)$

Para gerar valores de $Y \sim \Gamma(n, \lambda)$, somamos $n$ variáveis aleatórias $X_1, \dots, X_n$, onde cada $X_i \sim Exp(\lambda)$. A relação é:
$$
Y = X_1 + X_2 + \dots + X_n.
$$

O pseudo-algoritmo é:

1. Gere $U_1, \dots, U_n \sim Unif(0,1)$ independentemente.
2. Calcule $X_i = -\frac{\log(1 - U_i)}{\lambda}$ para $i = 1, \dots, n$.
3. Calcule $Y = X_1 + X_2 + \dots + X_n$.

```{python}
import numpy as np
import matplotlib.pyplot as plt



# Definindo parâmetros
n = 5  # número de somas
lambd = 2  # parâmetro da distribuição exponencial

# Gerando 1000 valores U para cada uma das n somas
U = np.random.uniform(0, 1, (1000, n))

# Calculando X_i = -log(1 - U_i) / lambda para cada U_i
X = -np.log(1 - U) / lambd

# Somando os valores de X para obter Y ~ Gamma(n, lambda)
Y = np.sum(X, axis=1)

# Plotando um histograma dos valores gerados
plt.figure(figsize=(10, 6))
plt.hist(Y, bins=30, color='lightcoral', edgecolor='black', density=True)
plt.title(f'Histograma de variáveis geradas: Y ~ Gamma({n}, {lambd})')
plt.xlabel('Valor de Y')
plt.ylabel('Frequência')
plt.grid(True)
plt.show()
```

